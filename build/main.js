/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Prj
});
module.exports = __toCommonJS(main_exports);
var import_obsidian16 = require("obsidian");

// src/libs/MarkdownBlockProcessor.ts
var import_obsidian13 = require("obsidian");

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/libs/FileCache.ts
var import_obsidian = require("obsidian");
var FileCache = class {
  /**
   * Creates a new FileCache instance
   * @constructor
   */
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.fileCachePromise = null;
    this.fileCache = null;
    this.duplicateNames = null;
    this.fileCacheReady = false;
    this.eventsRegistered = false;
    if (!this.fileCache) {
      this.buildFileCache().then(() => {
        this.logger.debug("File Cache built");
      });
    }
    this.createEventHandler = this.createEventHandler.bind(this);
    this.renameEventHandler = this.renameEventHandler.bind(this);
    this.deleteEventHandler = this.deleteEventHandler.bind(this);
    this.registerEvents();
  }
  /**
   * Returns the FileCache instance if it exists, otherwise creates a new instance
   * @returns The FileCache instance
   */
  static getInstance() {
    if (!FileCache.instance) {
      FileCache.instance = new FileCache();
    }
    return FileCache.instance;
  }
  /**
   * Deconstructs the FileCache instance
   * unregisters all events
   */
  static deconstructor() {
    if (!FileCache.instance) {
      Global.getInstance().logger.error("FileCache instance not loaded");
      return;
    }
    const instance = FileCache.instance;
    if (instance.eventsRegistered) {
      instance.app.vault.off("rename", instance.renameEventHandler);
      instance.app.vault.off("delete", instance.deleteEventHandler);
      instance.app.vault.off("create", instance.createEventHandler);
      instance.eventsRegistered = false;
      Global.getInstance().logger.debug("File cache events unregistered");
      return;
    }
    Global.getInstance().logger.debug("File cache events not registered");
  }
  /**
   * Wait for the file cache to be ready
   * @returns {Promise<void>} Promise that resolves when the file cache is ready
   * @description This method returns a promise that resolves when the file cache is ready.
   */
  async waitForCacheReady() {
    while (!this.fileCacheReady) {
      await new Promise((resolve) => setTimeout(resolve, 5));
    }
  }
  /**
   * Builds the file cache
   * @returns Promise that resolves when the file cache is built
   * @private
   */
  async buildFileCache() {
    const startTime = Date.now();
    const allFiles = this.app.vault.getFiles();
    this.fileCache = /* @__PURE__ */ new Map();
    this.duplicateNames = /* @__PURE__ */ new Map();
    for (const file of allFiles) {
      this.addEntry(file);
    }
    this.fileCacheReady = true;
    const endTime = Date.now();
    this.logger.debug(`File cache for ${allFiles.length} files built in ${endTime - startTime}ms`);
  }
  /**
   * Updates the file cache with the new file
   * @param file The file to add to the cache
   * @returns True if the file was added to the cache, false otherwise
   * @private
   */
  addEntry(file) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    let state = true;
    const existingFile = this.fileCache.get(file.name);
    if (existingFile === void 0) {
      this.fileCache.set(file.name, file);
    } else if (existingFile === null) {
      state && (state = this.addDuplicateEntry([file]));
    } else {
      state && (state = this.addDuplicateEntry([existingFile, file]));
      this.fileCache.set(file.name, null);
    }
    return state;
  }
  /**
   * Updates the duplicate cache with the new file
   * @param file The files to add to the cache
   * @returns True if the file was added to the cache, false otherwise
   * @private
   */
  addDuplicateEntry(file) {
    var _a;
    const fileName = (_a = file.first()) == null ? void 0 : _a.name;
    if (!fileName) {
      this.logger.error("File name not available");
      return false;
    }
    if (!this.duplicateNames) {
      this.logger.error("Duplicate cache not available");
      return false;
    }
    const duplicateEntry = this.duplicateNames.get(fileName);
    if (duplicateEntry) {
      file.forEach((f) => duplicateEntry.push(f));
    } else {
      this.duplicateNames.set(fileName, file);
    }
    return true;
  }
  /**
   * Removes the file from the duplicate cache
   * @param file The file to remove from the cache
   * @param oldPath The old path of the file
   * @returns True if the file was removed from the cache, false otherwise
   * @private
   */
  removeDuplicateEntry(file, oldPath = null) {
    if (!this.duplicateNames) {
      this.logger.error("Duplicate cache not available");
      return false;
    }
    const duplicateEntry = this.duplicateNames.get(file.name);
    if (!duplicateEntry) {
      this.logger.error("File ${file.name} not found in duplicate cache");
      return false;
    }
    const path = oldPath != null ? oldPath : file.path;
    const index = duplicateEntry.findIndex((f) => f.path === path);
    if (index > -1) {
      duplicateEntry.splice(index, 1);
    } else {
      this.logger.error(`File ${file.name} not found in duplicate cache`);
      return false;
    }
    return true;
  }
  /**
   * Removes the file from the file cache
   * @param file The file to remove from the cache
   * @returns True if the file was removed from the cache, false otherwise
   * @private
   */
  removeEntry(file) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    let state = true;
    const existingFile = this.fileCache.get(file.name);
    if (existingFile) {
      this.fileCache.delete(file.name);
    } else if (existingFile === void 0) {
      this.logger.warn(`File ${file.name} not found in cache`);
      return false;
    } else if (existingFile === null) {
      state && (state = this.removeDuplicateEntry(file));
    }
    return state;
  }
  /**
   * Renames the file in the file cache
   * @param file The file to rename
   * @param oldPath The old path of the file
   * @returns True if the file was renamed in the cache, false otherwise
   * @private
   */
  renameEntry(file, oldPath) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    const oldFileName = this.getFileNameFromPath(oldPath);
    if (!oldFileName) {
      this.logger.error("Old file name not available");
      return false;
    }
    const existingFile = this.fileCache.get(oldFileName);
    let state = true;
    if (existingFile) {
      this.fileCache.delete(oldFileName);
      state && (state = this.addEntry(file));
    } else if (existingFile === void 0) {
      this.logger.warn(`File ${oldFileName} not found in cache`);
      state && (state = this.addEntry(file));
    } else if (existingFile === null) {
      state && (state = this.removeDuplicateEntry(file, oldPath));
      state && (state = this.addDuplicateEntry([file]));
    }
    return state;
  }
  /**
   * Event handler for the create event
   * @param file The file to create in the file cache
   * @private
   */
  createEventHandler(file) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      state && (state = this.addEntry(file));
    }
    if (state) {
      this.logger.debug(`File ${file.name} create in file cache event handler success`);
    } else {
      this.logger.error(`Error creating file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Event handler for the rename event
   * @param file The file to rename in the file cache
   * @param oldPath The old path of the file
   * @private
   */
  renameEventHandler(file, oldPath) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      const oldFileName = oldPath.split("/").last();
      if (!oldFileName) {
        this.logger.error("Cannot extract old file name from the path");
        return;
      }
      state && (state = this.renameEntry(file, oldFileName));
    }
    if (state) {
      this.logger.debug(`File ${file.name} renamed in file cache event handler success`);
    } else {
      this.logger.error(`Error renaming file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Event handler for the delete event
   * @param file The file to delete in the file cache
   * @private
   */
  deleteEventHandler(file) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      state && (state = this.removeEntry(file));
    }
    if (state) {
      this.logger.debug(`File ${file.name} delete in file cache event handler success`);
    } else {
      this.logger.error(`Error deleting file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Registers the events for the file cache
   * @private
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.app.vault.on("rename", this.renameEventHandler);
      this.app.vault.on("delete", this.deleteEventHandler);
      this.app.vault.on("create", this.createEventHandler);
      this.eventsRegistered = true;
      this.logger.debug("File cache events registered");
    }
  }
  /**
   * Returns the file name from the file path
   * @param filePath The file path to extract the file name from
   * @returns The file name
   * @private
   */
  getFileNameFromPath(filePath) {
    const oldFileName = filePath.split("/").last();
    if (!oldFileName) {
      this.logger.error("Cannot extract old file name from the path");
      return;
    }
    return oldFileName;
  }
  /**
   * Returns the file from the file cache
   * @param fileName The name of the file to find
   * @returns The file/s if found, undefined otherwise
   */
  findFileByName(fileName) {
    var _a, _b;
    const foundFile = (_a = this.fileCache) == null ? void 0 : _a.get(fileName);
    if (foundFile) {
      return foundFile;
    } else if (foundFile === null) {
      const duplicateEntry = (_b = this.duplicateNames) == null ? void 0 : _b.get(fileName);
      if (!duplicateEntry) {
        this.logger.error(`File ${fileName} not found in duplicate cache`);
        return void 0;
      }
      return duplicateEntry;
    } else {
      return void 0;
    }
  }
  /**
   * Returns the file from the file cache
   * @param filePath The path of the file to find
   * @returns The file/s if found, undefined otherwise
   */
  findFileByPath(filePath) {
    const fileName = this.getFileNameFromPath(filePath);
    if (!fileName) {
      this.logger.error("File name not available");
      return void 0;
    }
    return this.findFileByName(fileName);
  }
};

// src/libs/MetadataCache.ts
var MetadataCache = class {
  /**
   * Constructor for the MetadataCache class
   * @description This constructor is private because the MetadataCache class is a singleton. Use the getInstance() method to get the singleton instance.
   */
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.metadataCachePromise = null;
    this.metadataCache = null;
    this.metadataCacheReady = false;
    this.eventsRegistered = false;
    this.changedEventHandler = this.changedEventHandler.bind(this);
    this.renameEventHandler = this.renameEventHandler.bind(this);
    this.deleteEventHandler = this.deleteEventHandler.bind(this);
    if (!this.metadataCache) {
      this.buildMetadataCache().then(() => {
        this.logger.debug("Metadata cache built");
        this.registerEvents();
      });
    }
  }
  /**
   * Get the metadata cache
   * @returns {FileMetadata[]} Array of FileMetadata objects
   * @description This method returns the metadata cache as an array of FileMetadata objects. The FileMetadata object contains the file and the cached metadata.
   */
  get Cache() {
    if (this.metadataCacheReady && this.metadataCache) {
      return Array.from(this.metadataCache.values());
    } else {
      this.logger.error("Metadata cache not initialized");
      return [];
    }
  }
  /**
   * Get the singleton instance of the MetadataCache class
   * @returns {MetadataCache} The MetadataCache instance
   */
  static getInstance() {
    if (!MetadataCache.instance) {
      MetadataCache.instance = new MetadataCache();
    }
    return MetadataCache.instance;
  }
  /**
   * Deconstructor for the MetadataCache class
   * @description This method is used to unregister the event handlers for the metadata cache.
   */
  static deconstructor() {
    if (!MetadataCache.instance) {
      Global.getInstance().logger.error("Metadata cache instance not loaded");
      return;
    }
    const instance = MetadataCache.instance;
    if (instance.eventsRegistered) {
      instance.app.vault.off("rename", instance.renameEventHandler);
      instance.app.metadataCache.off("changed", instance.changedEventHandler);
      instance.app.metadataCache.off("deleted", instance.deleteEventHandler);
      instance.eventsRegistered = false;
      Global.getInstance().logger.debug("Metadata cache events unregistered");
      return;
    }
    Global.getInstance().logger.debug("Metadata cache events not registered");
  }
  /**
   * Check if the metadata cache is ready
   * @returns {boolean} True if the metadata cache is ready, false otherwise
   */
  isCacheReady() {
    return this.metadataCacheReady;
  }
  /**
   * Wait for the metadata cache to be ready
   * @returns {Promise<void>} Promise that resolves when the metadata cache is ready
   * @description This method returns a promise that resolves when the metadata cache is ready.
   */
  async waitForCacheReady() {
    while (!this.metadataCacheReady) {
      await new Promise((resolve) => setTimeout(resolve, 5));
    }
  }
  /**
   * Build the metadata cache
   * @returns {Promise<void>} Promise that resolves when the metadata cache is built
   */
  async buildMetadataCache() {
    const startTime = Date.now();
    this.metadataCache = /* @__PURE__ */ new Map();
    const allFiles = this.app.vault.getFiles();
    const addEntryPromises = allFiles.map((file) => this.addEntry(file));
    await Promise.all(addEntryPromises);
    this.metadataCacheReady = true;
    const endTime = Date.now();
    this.logger.debug(`Metadata cache for ${allFiles.length} files built in ${endTime - startTime}ms`);
  }
  /**
   * Add a file to the metadata cache
   * @param file The file to add to the metadata cache
   */
  async addEntry(file) {
    if (this.metadataCache) {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata) {
        this.metadataCache.set(file.path, { file, metadata });
      } else {
        this.logger.warn(`No metadata found for file ${file.path}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
  }
  /**
   * Delete a file from the metadata cache
   * @param file The file to delete from the metadata cache
   */
  deleteEntry(file) {
    if (this.metadataCache) {
      this.metadataCache.delete(file.path);
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${file.path} deleted`);
  }
  /**
   * Update a file in the metadata cache
   * @param file The file to update in the metadata cache
   */
  async updateEntry(file) {
    if (this.metadataCache) {
      const entry = this.metadataCache.get(file.path);
      const metadata = this.app.metadataCache.getFileCache(file);
      if (entry && metadata) {
        entry.metadata = metadata;
      } else if (!entry) {
        this.logger.warn(`No metadata cache entry found for file ${file.path}`);
      } else {
        this.logger.warn(`No metadata found for file ${file.path}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${file.path} updated`);
  }
  /**
   * Rename a file in the metadata cache
   * @param newFile The new file object
   * @param oldPath The old path of the file
   */
  async renameEntry(newFile, oldPath) {
    if (this.metadataCache) {
      const entry = this.metadataCache.get(oldPath);
      if (entry) {
        entry.file = newFile;
      } else {
        this.logger.warn(`No metadata cache entry found for file ${oldPath}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${oldPath} renamed to ${newFile.path}`);
  }
  /**
   * Event handler for the rename event
   * @param file New file object
   * @param oldPath Old path of the file
   */
  renameEventHandler(file, oldPath) {
    this.logger.debug(`File ${file.path} renamed to ${oldPath}`);
    this.renameEntry(file, oldPath);
  }
  /**
   * Event handler for the delete event
   * @param file Deleted file object
   */
  deleteEventHandler(file) {
    this.logger.debug(`File ${file.path} deleted`);
    this.deleteEntry(file);
  }
  /**
   * Event handler for the changed event
   * @param file Changed file object
   */
  changedEventHandler(file) {
    if (this.metadataCache) {
      const existingEntry = this.metadataCache.get(file.path);
      if (existingEntry) {
        this.updateEntry(file);
      } else {
        this.addEntry(file);
      }
    }
  }
  redrawMarkdownView() {
    this.logger.debug(`Redrawing markdown view`);
    this.app.workspace.updateOptions();
  }
  /**
   * Register event handlers for the metadata cache
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.app.vault.on("rename", this.renameEventHandler);
      this.app.metadataCache.on("changed", this.changedEventHandler);
      this.app.metadataCache.on("deleted", this.deleteEventHandler);
      this.eventsRegistered = true;
      this.logger.debug("Metadata cache events registered");
    }
  }
};

// src/classes/Logging.ts
var Logging = class {
  /**
   * Creates a new Logging instance
   * @param logLevel The log level to use. Defaults to "info"
   */
  constructor(logLevel = "info", logPrefix = "") {
    this.logLevel = logLevel;
    this.logPrefix = `${logPrefix}: `;
    if (this.logLevel === "none") {
      console.info("Logging disabled");
    }
    Logging.instance = this;
  }
  setLogLevel(logLevel) {
    this.logLevel = logLevel;
    console.info(`Log level set to ${logLevel}`);
  }
  /**
   * Returns the Logging instance
   */
  static getInstance() {
    if (!Logging.instance) {
      Logging.instance = new Logging();
    }
    return Logging.instance;
  }
  /**
   * Logs a message to the console if the log level is "trace"
   * @param message 
   * @param optionalParams 
   */
  trace(message, ...optionalParams) {
    if (this.logLevelActive("trace")) {
      const logMessage = this.constructLogMessage(message);
      console.debug(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "debug"
   * @param message 
   * @param optionalParams 
   */
  debug(message, ...optionalParams) {
    if (this.logLevelActive("debug")) {
      const logMessage = this.constructLogMessage(message);
      console.debug(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info" or "debug"
   * @param message 
   * @param optionalParams 
   */
  info(message, ...optionalParams) {
    if (this.logLevelActive("info")) {
      const logMessage = this.constructLogMessage(message);
      console.info(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info", "debug" or "warn"
   * @param message 
   * @param optionalParams 
   */
  warn(message, ...optionalParams) {
    if (this.logLevelActive("warn")) {
      const logMessage = this.constructLogMessage(message);
      console.warn(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info", "debug", "warn" or "error"
   * @param message 
   * @param optionalParams 
   */
  error(message, ...optionalParams) {
    if (this.logLevelActive("error")) {
      const logMessage = this.constructLogMessage(message);
      console.error(logMessage, ...optionalParams);
    }
  }
  constructLogMessage(message) {
    return `${this.logPrefix}${message}`;
  }
  logLevelActive(logLevel) {
    if (this.logLevel === "none") {
      return false;
    }
    if (this.logLevel === "trace") {
      return true;
    }
    if (this.logLevel === "debug") {
      return logLevel !== "trace";
    }
    if (this.logLevel === "info") {
      return logLevel !== "trace" && logLevel !== "debug";
    }
    if (this.logLevel === "warn") {
      return logLevel !== "trace" && logLevel !== "debug" && logLevel !== "info";
    }
    if (this.logLevel === "error") {
      return logLevel !== "trace" && logLevel !== "debug" && logLevel !== "info" && logLevel !== "warn";
    }
    return true;
  }
};

// src/classes/Global.ts
var Global = class {
  constructor(prj, app, settings) {
    if (Global.instance) {
      return Global.instance;
    }
    this.plugin = prj;
    this.app = app;
    this.settings = settings;
    this.logger = new Logging(this.settings.logLevel, "Prj");
    Global.instance = this;
    this.fileCache = FileCache.getInstance();
    this.metadataCache = MetadataCache.getInstance();
  }
  async awaitCacheInitialization() {
    this.logger.debug("Waiting for cache initialization");
    await this.fileCache.waitForCacheReady();
    await this.metadataCache.waitForCacheReady();
    this.logger.debug("Cache initialized");
  }
  static deconstructor() {
    FileCache.deconstructor();
    MetadataCache.deconstructor();
  }
  static getInstance(prj = null, app = null, settings = null) {
    if (!Global.instance) {
      if (!prj || !app || !settings) {
        throw new Error("Global instance not initialized and no app provided");
      }
      Global.instance = new Global(prj, app, settings);
    }
    return Global.instance;
  }
};

// src/models/DocumentModel.ts
var import_obsidian3 = require("obsidian");

// src/models/TransactionModel.ts
var TransactionModel = class {
  /**
   * Creates a new instance of the TransactionModel class.
   * @param writeChanges A function that writes the changes to the file.
   */
  constructor(writeChanges) {
    this.logger = Global.getInstance().logger;
    this.transactionActive = false;
    this.changes = {};
    this.transactionActive = false;
    this.writeChanges = writeChanges;
  }
  /**
   * Starts a transaction
   * @remarks - If a transaction is already active, this method does nothing and logs a warning.
   */
  startTransaction() {
    if (this.isTransactionActive) {
      this.logger.warn("Transaction already active");
      return;
    }
    this.transactionActive = true;
  }
  /**
   * Finishes a transaction
   * @remarks - If no transaction is active, this method does nothing and logs a warning.
   * - This method writes the changes to the file.
   * @remarks - If the `writeChanges` method throws an error, the error is logged and the transaction is aborted.
   */
  finishTransaction() {
    if (!this.isTransactionActive) {
      this.logger.warn("No transaction active");
      return;
    }
    try {
      this.writeChanges(this.changes);
    } catch (error) {
      this.logger.error("`writeChanges` failed with error:", error);
    } finally {
      this.changes = {};
      this.transactionActive = false;
    }
  }
  /**
   * Aborts a transaction
   * @remarks - If no transaction is active, this method does nothing and logs a warning.
   * - This method discards all changes.
   */
  abortTransaction() {
    if (!this.isTransactionActive) {
      this.logger.warn("No transaction active");
      return;
    }
    this.changes = {};
    this.transactionActive = false;
  }
  /**
   * Updates the value of the given key.
   * @param key The key to update as path. Example: `data.title`
   * @param value The value to set.
   */
  updateKeyValue(key, value) {
    const keys = key.split(".");
    let current = this.changes;
    keys.forEach((k, index) => {
      if (index === keys.length - 1) {
        current[k] = value;
      } else {
        current[k] = current[k] || {};
        current = current[k];
      }
    });
    if (!this.isTransactionActive) {
      this.writeChanges(this.changes);
      this.changes = {};
    }
  }
  /**
   * Returns whether a transaction is active.
   * @returns `true` if a transaction is active, otherwise `false`.
   */
  get isTransactionActive() {
    return this.transactionActive;
  }
};

// src/models/BaseModel.ts
var BaseModel = class extends TransactionModel {
  /**
   * Creates a new BaseModel instance.
   * @param file The file to create the model for.
   * @param ctor The constructor of the data object.
   * @param yamlKeyMap The yaml key map to use.
   */
  constructor(file, ctor, yamlKeyMap) {
    super((update) => {
      this.frontmatter = update;
    });
    this.global = Global.getInstance();
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this._file = file;
    this.ctor = ctor;
    this.initYamlKeyMap(yamlKeyMap);
  }
  get file() {
    return this._file;
  }
  /**
   * Returns the data object as a proxy.
   * @returns The data object as a proxy.
   */
  get _data() {
    if (this.dataProxy) {
      return this.dataProxy;
    }
    const frontmatter = this.getMetadata();
    if (!frontmatter) {
      this.logger.error("Frontmatter not found");
      const emptyObject = new this.ctor();
      return emptyObject;
    }
    if (this.yamlKeyMap) {
      for (const key in this.yamlKeyMap) {
        if (frontmatter[this.yamlKeyMap[key]]) {
          frontmatter[key] = frontmatter[this.yamlKeyMap[key]];
          delete frontmatter[this.yamlKeyMap[key]];
        }
      }
    }
    const dataObject = new this.ctor(frontmatter);
    this.dataProxy = this.createProxy(dataObject);
    return this.dataProxy;
  }
  set _data(values) {
    const dataObject = new this.ctor(values);
    for (const key in dataObject) {
      this._data[key] = values[key];
    }
  }
  get frontmatter() {
    var _a;
    return (_a = this.getMetadata()) != null ? _a : {};
  }
  set frontmatter(value) {
    (async () => {
      try {
        await this.app.fileManager.processFrontMatter(this._file, (frontmatter) => {
          this.updateNestedFrontmatterObjects(frontmatter, value);
          return frontmatter;
        });
        this.logger.debug(`Frontmatter for file ${this._file.path} successfully updated.`);
      } catch (error) {
        this.logger.error(`Error updating the frontmatter for file ${this._file.path}:`, error);
      }
    })();
  }
  /**
   * Creates a proxy for the given object.
   * @param obj The object to create a proxy for.
   * @param path The path of the object. e.g. `data.title`
   * @returns The proxy object.
   */
  createProxy(obj, path = "") {
    return new Proxy(obj, {
      get: (target, property, receiver) => {
        const propertyKey = this.getPropertyKey(property);
        const value = Reflect.get(target, property, receiver);
        const newPath = path ? `${path}.${propertyKey}` : `${propertyKey}`;
        if (value && typeof value === "object") {
          return this.createProxy(value, newPath);
        }
        return value;
      },
      set: (target, property, value, receiver) => {
        const propertyKey = this.getPropertyKey(property);
        const newPath = path ? `${path}.${propertyKey}` : `${propertyKey}`;
        Reflect.set(target, property, value, receiver);
        this.updateKeyValue(newPath, value);
        return true;
      }
    });
  }
  /**
   * Updates the `yamlKeyMap` with the given value.
   * @param yamlKeyMap The new `yamlKeyMap` to set.
   */
  initYamlKeyMap(yamlKeyMap) {
    if (yamlKeyMap) {
      this.yamlKeyMap = yamlKeyMap;
    }
  }
  getPropertyKey(property) {
    return typeof property === "symbol" ? property.toString() : property;
  }
  getMetadata() {
    var _a, _b;
    const cachedMetadata = (_b = (_a = this.app) == null ? void 0 : _a.metadataCache) == null ? void 0 : _b.getCache(this._file.path);
    if (cachedMetadata && cachedMetadata.frontmatter) {
      return cachedMetadata.frontmatter;
    } else {
      this.logger.warn(`No Metadata found for ${this._file.path}`);
      return null;
    }
  }
  updateNestedFrontmatterObjects(frontmatter, updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (this.yamlKeyMap && this.yamlKeyMap[key]) {
        key = this.yamlKeyMap[key];
      }
      if (typeof value === "object" && value !== void 0 && value !== null && frontmatter[key]) {
        this.updateNestedFrontmatterObjects(frontmatter[key], value);
      } else if (value !== void 0) {
        frontmatter[key] = value;
      }
    });
  }
};

// src/types/DocumentData.ts
var DocumentData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.date = data.date !== void 0 ? data.date : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.sender = data.sender !== void 0 ? data.sender : void 0;
    this.recipient = data.recipient !== void 0 ? data.recipient : void 0;
    this.dateOfDelivery = data.dateOfDelivery !== void 0 ? data.dateOfDelivery : void 0;
    this.hide = data.hide !== void 0 ? data.hide : void 0;
    this.file = data.file !== void 0 ? data.file : void 0;
    this.relatedFiles = data.relatedFiles !== void 0 ? data.relatedFiles : void 0;
    this.citationTitle = data.citationTitle !== void 0 ? data.citationTitle : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.annotationTarget = data.annotationTarget !== void 0 ? data.annotationTarget : void 0;
  }
};
DocumentData.yamlKeyMap = {
  "annotationTarget": "annotation-target"
};

// src/libs/Helper.ts
var import_obsidian2 = require("obsidian");
var Helper = class {
  /**
   * Extracts the date, filename, file extension and display text from a wikilink
   * @param wikilink Wikilink to extract the data from, eg. [[2021.01.01 - file.txt|Display text]]
   * @returns {WikilinkData} Object containing the date, filename, file extension and display text
   * 
   */
  static extractDataFromWikilink(wikilink) {
    if (wikilink && typeof wikilink === "string") {
      const dismantledLinkMatch = wikilink.match(/\[\[(.+?)(?:\.(\w+))?(?:\|(.*))?\]\]/);
      let date = void 0;
      if (!dismantledLinkMatch) {
        return {
          date: void 0,
          basename: void 0,
          extension: void 0,
          filename: void 0,
          displayText: void 0
        };
      } else {
        const dateMatch = dismantledLinkMatch[1].match(/(\d{4})\.(\d{2})\.(\d{2})/);
        if (dateMatch) {
          date = new Date(`${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`);
        }
        return {
          date,
          basename: dismantledLinkMatch[1],
          extension: dismantledLinkMatch[2],
          filename: `${dismantledLinkMatch[1]}.${dismantledLinkMatch[2]}`,
          displayText: dismantledLinkMatch[3]
        };
      }
    } else {
      return {
        date: void 0,
        basename: void 0,
        extension: void 0,
        filename: void 0,
        displayText: void 0
      };
    }
  }
  /**
   * Generates a UID from the given input
   * @param input The input to generate the UID from
   * @param length The length of the UID
   * @returns The generated UID with the given length
   * @remarks - This method uses the MD5 hash algorithm to generate the UID
   * - The UID is prefixed with a "U" to prevent the UID from starting with a number. The "U" counts to the length of the UID
   */
  static generateUID(input, length = 8) {
    const hash = "U" + this.md5(input).toString();
    return hash.substring(0, length);
  }
  static formatDate(date, format) {
    const regexDate = /^\d{4}-\d{2}-\d{2}$/;
    if (!regexDate.test(date)) {
      return date;
    }
    const formatedDate = (0, import_obsidian2.moment)(date).format(format);
    if (formatedDate === "Invalid date") {
      return date;
    }
    return formatedDate;
  }
  /**
   * Sleeps for the given amount of milliseconds
   * @param ms The amount of milliseconds to sleep
   * @returns A promise that resolves after the given amount of milliseconds
   */
  static async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Checks if the given text is possibly markdown
   * @param text The text to check
   * @returns Whether the text is possibly markdown (true or false)
   * @remarks - This method checks if the text contains any of the following symbols:
   * - `*`, `_`, `[`, `]`, `=` and `-` if there is a line break
   */
  static isPossiblyMarkdown(text) {
    let regexMarkdownSymbols;
    const regexLineBreak = /\r?\n/;
    const lineBreak = regexLineBreak.test(text);
    if (lineBreak) {
      regexMarkdownSymbols = /[*_\-[\]=]/;
    } else {
      regexMarkdownSymbols = /[*_[\]=]/;
    }
    return regexMarkdownSymbols.test(text);
  }
  /**
   * Checks if any of the tags in `tagsToCheck` is a substring of any tag in `tagsToBeChecked`
   * @param tagsToCheck The tags to check as substrings
   * @param tagsToBeChecked The tags to be checked against
   * @returns Whether any tag from `tagsToCheck` is a substring of any tag in `tagsToBeChecked`
   */
  static isTagIncluded(tagsToCheck, tagsToBeChecked) {
    const _tagsToCheck = Array.isArray(tagsToCheck) ? tagsToCheck : tagsToCheck ? [tagsToCheck] : [];
    const _tagsToBeChecked = Array.isArray(tagsToBeChecked) ? tagsToBeChecked : tagsToBeChecked ? [tagsToBeChecked] : [];
    return _tagsToCheck.some(
      (tagToCheck) => _tagsToBeChecked.some(
        (tagToBeChecked) => tagToBeChecked == null ? void 0 : tagToBeChecked.includes(tagToCheck)
      )
    );
  }
  /**
   * Checks if the given string is an emoji
   * @param str The string to check
   * @returns Whether the string is an emoji (true or false)
   */
  static isEmoji(str2) {
    const emojiRegex = /(\p{Emoji_Presentation}|\p{Emoji}\uFE0F)/u;
    return emojiRegex.test(str2);
  }
};
Helper.md5 = require_md5();

// src/models/DocumentModel.ts
var DocumentModel = class extends BaseModel {
  constructor(file) {
    super(file, DocumentData, DocumentData.yamlKeyMap);
    this.fileCache = Global.getInstance().fileCache;
    this._relatedFiles = void 0;
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
  }
  get relatedFiles() {
    if (this._relatedFiles === void 0) {
      this._relatedFiles = [];
      const relatedFiles = this.data.relatedFiles;
      if (relatedFiles) {
        relatedFiles.map((relatedFile) => {
          var _a;
          const wikilinkData = Helper.extractDataFromWikilink(relatedFile);
          const mdFilename = wikilinkData.basename ? `${wikilinkData.basename}.md` : "";
          const file = this.fileCache.findFileByName(mdFilename);
          if (file instanceof import_obsidian3.TFile && file.path !== this.file.path) {
            (_a = this._relatedFiles) == null ? void 0 : _a.push(new DocumentModel(file));
          }
          return null;
        });
      } else {
        this._relatedFiles = null;
      }
    }
    return this._relatedFiles;
  }
  toString() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    let allText = (_a = this.data.title) != null ? _a : "";
    allText += (_b = this.data.description) != null ? _b : "";
    allText += (_c = this.data.date) != null ? _c : "";
    allText += (_d = this.data.dateOfDelivery) != null ? _d : "";
    allText += (_e = this.data.file) != null ? _e : "";
    allText += (_f = this.data.tags) != null ? _f : "";
    allText += (_g = this.data.sender) != null ? _g : "";
    allText += (_h = this.data.recipient) != null ? _h : "";
    allText += (_i = this.data.relatedFiles) != null ? _i : "";
    return allText;
  }
  getWikilink(text) {
    if (text) {
      return `[[${this.file.name}|${text}]]`;
    } else {
      return `[[${this.file.name}]]`;
    }
  }
  /**
   * Returns the file contents of the document
   * @returns String containing the file contents
   */
  async getFileContents() {
    return this.app.vault.read(this.file);
  }
  getCorospondingSymbol() {
    if (this.data.type === "Metadata") {
      if (this.data.subType === "Cluster") {
        return this.global.settings.documentSettings.clusterSymbol;
      } else if (this.data.hide) {
        return this.global.settings.documentSettings.hideSymbol;
      } else {
        return this.global.settings.documentSettings.symbol;
      }
    }
    return "x-circle";
  }
  /**
   * Returns the description of the document
   * @returns String containing the description
   */
  getDescription() {
    var _a;
    return (_a = this.data.description) != null ? _a : "";
  }
  /**
   * Returns `Input` if the document is addressed to the user or `Output` if it comes from the user. Otherwise `null`.
   * @returns State of the document.
   * E.g. `Input` if the document is addressed to the user or `Output` if it comes from the user. Otherwise `null`.
   */
  getInputOutputState() {
    const username = this.global.settings.user.name;
    const shortUsername = this.global.settings.user.shortName;
    if (this.data && (this.data.sender || this.data.recipient)) {
      if (this.data.sender === username || this.data.sender === shortUsername) {
        return "Output";
      } else if (this.data.recipient === username || this.data.recipient === shortUsername) {
        return "Input";
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  /**
   * Returns the linked file of the document
   * @returns TFile of the linked file
   */
  getFile() {
    var _a, _b;
    const fileLinkData = Helper.extractDataFromWikilink(this.data.file);
    const file = this.fileCache.findFileByName((_a = fileLinkData.filename) != null ? _a : "");
    if (file instanceof import_obsidian3.TFile) {
      return file;
    } else if (Array.isArray(file)) {
      this.logger.warn(`Multiple files found for ${fileLinkData.filename}`);
      return (_b = file.first()) != null ? _b : this.file;
    }
    this.logger.warn(`No files found for ${fileLinkData.filename}`);
    return this.file;
  }
  /**
   * Returns the tags of the document as an array of strings
   * @returns Array of strings containing the tags
   */
  getTags() {
    const tags = this.data.tags;
    let formattedTags = [];
    if (tags && typeof tags === "string") {
      formattedTags = [tags];
    } else if (Array.isArray(tags)) {
      formattedTags = [...tags];
    }
    return formattedTags;
  }
  /**
   * Sorts the documents by date descending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   */
  static sortDocumentsByDateDesc(documents) {
    documents.sort((a, b) => {
      if (a.data.date && b.data.date) {
        const dateA = new Date(a.data.date);
        const dateB = new Date(b.data.date);
        return dateB.getTime() - dateA.getTime();
      } else if (a.data.date) {
        return -1;
      } else if (b.data.date) {
        return 1;
      } else {
        return 0;
      }
    });
  }
  /**
   * Sorts the documents by date ascending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   */
  static sortDocumentsByDateAsc(documents) {
    documents.sort((a, b) => {
      if (a.data.date && b.data.date) {
        const dateA = new Date(a.data.date);
        const dateB = new Date(b.data.date);
        return dateA.getTime() - dateB.getTime();
      } else if (a.data.date) {
        return 1;
      } else if (b.data.date) {
        return -1;
      } else {
        return 0;
      }
    });
  }
};

// src/libs/BlockRenderComponents/TableBlockRenderComponent.ts
var import_obsidian4 = require("obsidian");

// src/translations.json
var translations_default = [
  {
    lang: "en",
    translations: {
      DocumentType: "Type",
      Date: "Date",
      Subject: "Subject",
      Sender: "Sender",
      Recipient: "Recipient",
      SendRecip: "Snd./Rcp.",
      Content: "Content",
      DeliveryDate: "Delivery date",
      Tags: "Tags",
      From: "from:",
      To: "to:",
      Refresh: "Refresh",
      Documents: "Documents",
      HideDocuments: "Hide documents",
      Cluster: "Document Cluster",
      Filter: "Filter:",
      MaxShownEntrys: "Max. shown entries",
      Search: "Search",
      DocumentDate: "Document date",
      MetadataFile: "Metadata file",
      PDFFile: "PDF file",
      TraficLight: "\u{1F6A6}",
      Description: "Description",
      Priority: "Prio.",
      Status: "Status",
      DueDate: "Due date",
      PriorityText: "Priority",
      HighPriority: "High priority",
      MediumPriority: "Medium priority",
      LowPriority: "Low priority",
      NoPriority: "No priority",
      Title: "Title",
      StatusActive: "Active",
      StatusWaiting: "Waiting",
      StatusLater: "Later",
      StatusSomeday: "Someday",
      StatusDone: "Done",
      Done: "Done",
      Topic: "Topic",
      Project: "Project",
      Task: "Task",
      ShowMetadataFile: "Show metadata file"
    }
  },
  {
    lang: "de",
    translations: {
      DocumentType: "Typ",
      Date: "Datum",
      Subject: "Betreff",
      Sender: "Absender",
      Recipient: "Empf\xE4nger",
      SendRecip: "Abs./Empf.",
      Content: "Inhalt",
      DeliveryDate: "Zustelldatum",
      Tags: "Tags",
      From: "von:",
      To: "an:",
      Refresh: "Aktualisieren",
      Documents: "Dokumente",
      HideDocuments: "Ausgeblendete Dokumente",
      Cluster: "Dokumenten Cluster",
      Filter: "Filter:",
      MaxShownEntrys: "Max. angezeigte Eintr\xE4ge",
      Search: "Suche",
      DocumentDate: "Dokumenten Datum",
      MetadataFile: "Metadaten Datei",
      PDFFile: "PDF Datei",
      TraficLight: "\u{1F6A6}",
      Description: "Beschreibung",
      Priority: "Prio.",
      Status: "Status",
      DueDate: "F\xE4lligk.-Datum",
      PriorityText: "Priorit\xE4t",
      HighPriority: "Hohe Priorit\xE4t",
      MediumPriority: "Mittlere Priorit\xE4t",
      LowPriority: "Niedrige Priorit\xE4t",
      NoPriority: "Keine Priorit\xE4t",
      Title: "Titel",
      StatusActive: "Aktiv",
      StatusWaiting: "Warten",
      StatusLater: "Sp\xE4ter",
      StatusSomeday: "Irgendwann",
      StatusDone: "Erledigt",
      Done: "Erledigt",
      Topic: "Thema",
      Project: "Projekt",
      Task: "Aufgabe",
      ShowMetadataFile: "Metadaten Datei anzeigen"
    }
  }
];

// src/classes/Lng.ts
var Lng = class {
  /**
   * Returns a translation for the given key.
   * @param key The key to translate.
   * @returns The translation.
   * @remarks - If the translation is not found, the key is returned.
   * - Look at the `translations.json` file to see all available translations.
   */
  static gt(key) {
    const logger = Global.getInstance().logger;
    const lang = Global.getInstance().settings.language;
    const translation = translations_default;
    const language = translation.find((v) => v.lang === lang);
    if (language) {
      if (language.translations.hasOwnProperty(key)) {
        return language.translations[key];
      }
    }
    logger.warn(`Translation for key ${key} not found`);
    return key;
  }
};

// src/libs/BlockRenderComponents/TableBlockRenderComponent.ts
var TableBlockRenderComponent = class {
  //#endregion
  constructor(settings) {
    //#region General properties
    this.global = Global.getInstance();
    this.logger = this.global.logger;
    this.metadataCache = this.global.metadataCache.Cache;
    this.fileCache = this.global.fileCache;
    this.processorSettings = settings;
    this.component = new import_obsidian4.MarkdownRenderChild(this.processorSettings.container);
  }
  /**
   * Builds the component first time.
   * @remarks Calls the `draw` method.
   */
  async build() {
    return this.draw();
  }
  /**
   * Builds the `tableContainer` and `headerContainer` elements.
   * @remarks - Call this method to build the base structure first.
   * - Override this method to build the other elements.
   * @remarks - Build the `tableContainer` and `headerContainer` elements.
   * - Build the `controle block` => add a refresh button which calls the `redraw` method.
   */
  async draw() {
    this.headerContainer = document.createElement("div");
    this.processorSettings.container.appendChild(this.headerContainer);
    this.headerContainer.classList.add("header-container");
    const blockControle = document.createElement("div");
    this.headerContainer.appendChild(blockControle);
    blockControle.classList.add("block-controle");
    const refreshButton = document.createElement("a");
    blockControle.appendChild(refreshButton);
    refreshButton.classList.add("refresh-button");
    refreshButton.title = Lng.gt("Refresh");
    refreshButton.href = "#";
    (0, import_obsidian4.setIcon)(refreshButton, "refresh-cw");
    this.component.registerDomEvent(refreshButton, "click", async (event) => {
      event.preventDefault();
      this.redraw();
    });
    this.tableContainer = document.createElement("div");
    this.processorSettings.container.appendChild(this.tableContainer);
    this.tableContainer.classList.add("table-container");
  }
  /**
   * Redraws the component on request. Clears the container and calls the `draw` method.
   * @remarks This methode clears the container and calls the `draw` methode.
   */
  async redraw() {
    this.processorSettings.container.innerHTML = "";
    return this.draw();
  }
  /**
   * Normalizes the header.
   * @remarks - Removes the `disable` class from the header.
   * - The header is not grayed out anymore.
   */
  normalizeHeader() {
    this.headerContainer.removeClass("disable");
  }
  /**
   * Grays out the header.
   * @remarks - Adds the `disable` class to the header.
   * - The header is grayed out.
   */
  grayOutHeader() {
    this.headerContainer.addClass("disable");
  }
  getUID(model) {
    return Helper.generateUID(model.file.path);
  }
};

// src/libs/Search.ts
var Search = class {
  /**
   * Parses the search text into an array of objects that represent the search terms
   * @param searchText The search text to parse
   * @returns An array of objects with the following properties:
   * - term: The search term
   * - negate: Whether the term should be negated
   * - isOperator: Whether the term is an operator
   */
  static parseSearchText(searchText) {
    searchText = searchText.toLowerCase();
    if (!searchText.includes('"')) {
      return [{ term: searchText.trim(), negate: false, isOperator: false }];
    }
    const terms = [];
    let term = "";
    let inQuotes = false;
    let negate = false;
    for (const char of searchText) {
      if (char === '"') {
        if (inQuotes) {
          terms.push({ term: term.toLowerCase(), negate, isOperator: false });
          term = "";
          negate = false;
        }
        inQuotes = !inQuotes;
      } else if (inQuotes) {
        term += char;
      } else if (char === " ") {
        continue;
      } else if (["&", "|", "!"].includes(char)) {
        if (term.length > 0) {
          terms.push({ term, negate, isOperator: false });
          term = "";
          negate = false;
        }
        if (char === "!") {
          negate = true;
        } else {
          terms.push({ term: char, negate: false, isOperator: true });
        }
      } else {
        term += char;
      }
    }
    if (term.length > 0) {
      terms.push({ term, negate, isOperator: false });
    }
    if (terms.length > 1) {
      let i = 0;
      while (i < terms.length - 1) {
        if (!terms[i].isOperator && !terms[i + 1].isOperator) {
          terms.splice(i + 1, 0, { term: "&", negate: false, isOperator: true });
        }
        i += 2;
      }
    }
    return terms;
  }
  /**
   * Applies the search logic to the given text content
   * @param terms The search terms
   * @param textContent The text content to apply the search logic to
   * @returns Whether the text content matches the search terms (true or false)
   */
  static applySearchLogic(terms, textContent) {
    textContent = textContent.toLowerCase();
    let result = terms[0].negate ? !textContent.includes(terms[0].term) : textContent.includes(terms[0].term);
    for (let i = 1; i < terms.length; i += 2) {
      const operatorObj = terms[i];
      const nextTermObj = terms[i + 1];
      const nextTermMatch = nextTermObj.negate ? !textContent.includes(nextTermObj.term) : textContent.includes(nextTermObj.term);
      if (operatorObj.term === "&") {
        result = result && nextTermMatch;
      } else if (operatorObj.term === "|") {
        result = result || nextTermMatch;
      }
    }
    return result;
  }
};

// src/libs/Table.ts
var Table = class {
  // // //// // //// // //
  /**
   * Creates a new table
   * @param tableHeaders A list of table headers
   * @param id The ID of the table
   * @param classList The class list of the table
   */
  constructor(tableHeaders, id, classList) {
    this.logger = Global.getInstance().logger;
    /**
     * A list of row placeholders
     * @remarks - The row placeholders are used to keep the order of the rows when hiding and showing rows.
     * - The placeholders rows are empty and have the id `defaultIds.placeholder` (default: `placeholder-row`).
     */
    this._rowPlaceholders = [];
    this._visibleRows = 0;
    this._hiddenRows = 0;
    //   Default classes  //
    this.defaultClasses = {
      table: ["prj-table"],
      header: ["prj-table-header"],
      headerRow: ["prj-table-header-row"],
      headerCell: ["prj-table-header-cell"],
      body: ["prj-table-body"],
      row: ["prj-table-row", "prj-table-row-hover"],
      cell: ["prj-table-cell"],
      emojiCell: ["emoji-cell"],
      hiddenRow: "hidden-row",
      evenRow: "even-row",
      oddRow: "odd-row"
    };
    // Default IDs 
    this.defaultIds = {
      placeholder: "placeholder-row"
    };
    this._headers = tableHeaders;
    this._tableId = id;
    this._tableClassList = classList;
    this._table = this.createTable();
  }
  get data() {
    return this._table;
  }
  /**
   * Delte the complete table
   */
  deconstructor() {
    this._table.table.remove();
  }
  createTable() {
    const table = document.createElement("table");
    table.id = this._tableId;
    table.classList.add(...this.defaultClasses.table);
    if (this._tableClassList) {
      this._tableClassList.forEach((classItem) => {
        table.classList.add(classItem);
      });
    }
    const tableHeader = table.createTHead();
    tableHeader.classList.add(...this.defaultClasses.header);
    const tableHeaderRow = tableHeader.insertRow();
    tableHeaderRow.classList.add(...this.defaultClasses.headerRow);
    const tableHeaderCells = [];
    this._headers.forEach((header) => {
      const tableHeaderCell = document.createElement("th");
      tableHeaderCell.classList.add(...this.defaultClasses.headerCell);
      tableHeaderCell.id = this.makeSafeForId(header.text);
      tableHeaderCell.textContent = header.text;
      if (header.headerClass) {
        header.headerClass.forEach((classItem) => {
          tableHeaderCell.classList.add(classItem);
        });
      }
      tableHeaderCells.push(tableHeaderCell);
      tableHeaderRow.appendChild(tableHeaderCell);
    });
    const tableBody = table.createTBody();
    tableBody.classList.add(...this.defaultClasses.body);
    const structedTable = {
      table,
      header: tableHeader,
      headerRow: tableHeaderRow,
      headerCells: tableHeaderCells,
      body: tableBody,
      rows: []
    };
    return structedTable;
  }
  /**
   * Adds a row to the table
   * @param rowUid The UID of the new row
   * @param rowData The data of the new row
   * @param rowClassList The class list of the new row
   * @param hidden Whether the new row should be hidden
   */
  addRow(row) {
    this._addRow(row.rowUid, row.rowData, row.rowClassList, row.hidden);
  }
  /**
   * Adds multiple rows to the table
   * @param rows The rows to add
   * @param rows.rowUid The UID of the new row
   * @param rows.rowData The data of the new row
   * @param rows.rowClassList The class list of the new row
   * @param rows.hidden Whether the new row should be hidden
   * @remarks - The rows are added in the order of the array.
   * - The rows are added to the internal array.
   * - If the row is hidden, the row content is replaced with a placeholder.
   */
  addRows(rows) {
    const collectedRows = document.createDocumentFragment();
    rows.forEach((row) => {
      const rowFragment = this.createRow(row.rowUid, row.rowData, row.rowClassList, row.hidden);
      if (rowFragment) {
        this._table.rows.push(rowFragment);
        if (row.hidden) {
          collectedRows.append(this._getPlaceholder(row.rowUid));
        } else {
          collectedRows.append(rowFragment);
        }
      }
    });
    this._table.body.append(collectedRows);
  }
  /**
   * Adds a row to the table
   * @param rowUid The UID of the new row
   * @param rowData The data of the new row as an array of DocumentFragments. Each DocumentFragment represents a cell.
   * @param rowClassList The class list of the new row
   * @param hidden Whether the new row should be hidden
   * @remarks - The row is added to the internal array.
   * - If the row is hidden, the row content is replaced with a placeholder.
   */
  _addRow(rowUid, rowData, rowClassList, hidden) {
    const tableRow = this.createRow(rowUid, rowData, rowClassList, hidden);
    this._table.rows.push(tableRow);
    if (hidden) {
      this._table.body.append(this._getPlaceholder(rowUid));
    } else {
      this._table.body.append(tableRow);
    }
  }
  /**
   * Creates a row
   * @param rowUid The UID of the row 
   * @param rowData The data of the row as an array of DocumentFragments. Each DocumentFragment represents a cell.
   * @param rowClassList The class list of the row
   * @param hidden Whether the row should be hidden.
   * @remarks **If true, the row is hidden and the row content is later replaced with a placeholder.**
   * @returns The created row as an HTMLTableRowElement
   */
  createRow(rowUid, rowData, rowClassList, hidden) {
    const tableRow = document.createElement("tr");
    tableRow.classList.add(...this.defaultClasses.row);
    tableRow.setAttribute("row-uid", rowUid);
    if (rowClassList) {
      rowClassList.forEach((classItem) => {
        tableRow.classList.add(classItem);
      });
    }
    if (hidden) {
      tableRow.classList.add(this.defaultClasses.hiddenRow);
      this._hiddenRows++;
    } else {
      this.setRowOddOrEven(tableRow);
      this._visibleRows++;
    }
    rowData.forEach((data, index) => {
      var _a;
      const tableCell = tableRow.insertCell();
      tableCell.classList.add(...this.defaultClasses.cell);
      if (this._headers[index] !== void 0 && this._headers[index].columnClass) {
        (_a = this._headers[index].columnClass) == null ? void 0 : _a.forEach((classItem) => {
          tableCell.classList.add(classItem);
        });
      }
      tableCell.setAttribute("data-label", this._headers[index].text);
      if (Helper.isEmoji(this._headers[index].text)) {
        tableCell.classList.add(...this.defaultClasses.emojiCell);
      }
      tableCell.appendChild(data);
    });
    return tableRow;
  }
  /**
   * Sets the row to odd or even
   * @param tableRow The row to set
   * @remarks - The row is set to odd or even based on the last visible row.
   * - If no visible row exists, the row is set to even.
   * @remarks It does not search for the last visible line in the HTML table itself, but in an internal array.
   */
  setRowOddOrEven(tableRow) {
    let lastVisibleRow;
    for (let i = this._table.rows.length - 1; i >= 0; i--) {
      if (!this._table.rows[i].classList.contains(this.defaultClasses.hiddenRow)) {
        lastVisibleRow = this._table.rows[i];
        break;
      }
    }
    if (lastVisibleRow) {
      tableRow.classList.add(lastVisibleRow.classList.contains(this.defaultClasses.evenRow) ? this.defaultClasses.oddRow : this.defaultClasses.evenRow);
    } else {
      tableRow.classList.add(this.defaultClasses.evenRow);
    }
  }
  /**
   * Returns the number of visible and hidden rows
   * @returns The number of visible and hidden rows
   * @returns visibleRows The number of visible rows
   * @returns hiddenRows The number of hidden rows
   */
  getRowStats() {
    return { visibleRows: this._visibleRows, hiddenRows: this._hiddenRows };
  }
  /**
   * Deletes the row with the given UID
   * @param rowUid The UID of the row
   * @remarks - The row is deleted from the table body and the internal array.
   * - If a placeholder exists, it is also deleted from the table body and the internal array.
   */
  deleteRow(rowUid) {
    const rowToDelete = this.getRow(rowUid);
    const rowVisible = rowToDelete && !rowToDelete.classList.contains(this.defaultClasses.hiddenRow);
    if (rowVisible) {
      if (rowToDelete) {
        try {
          this._table.body.removeChild(rowToDelete);
        } catch (error) {
          this.logger.warn("Row not active in the table. Error:", error);
        }
        this._table.rows = this._table.rows.filter((row) => row.getAttribute("row-uid") !== rowUid);
        this._removePlaceholder(rowUid);
      }
      this._visibleRows--;
      this.refreshRowEvenOddClass();
    } else {
      const placeholder = this._removePlaceholder(rowUid);
      if (placeholder) {
        try {
          this._table.body.removeChild(placeholder);
        } catch (error) {
          this.logger.warn("Placeholder row not active in the table. Error:", error);
        }
      }
      this._hiddenRows--;
    }
  }
  /**
   * Set a row to hidden
   * @param rowUid The UID of the row
   * @remarks - The row is set to hidden and the row content is replaced with a placeholder.
   * - Only if the state has changed, the calculation of the odd and even rows is updated.
   */
  hideRow(rowUid) {
    const changes = this._hideRow(rowUid);
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Set a row to hidden, replaces the row content with a placeholder and updates the row stats
   * @param rowUid The UID of the row
   * @returns Whether the state has changed. Returns `false` if the row is already hidden.
   */
  _hideRow(rowUid) {
    this.logger.trace(`Row ${rowUid} should be hidden.`);
    const changes = this.togleRowClass(rowUid, [this.defaultClasses.hiddenRow], true);
    this.logger.trace(`Row ${rowUid} changes: ${changes}`);
    if (changes) {
      this._removeRowContent(rowUid);
      this._visibleRows--;
      this._hiddenRows++;
    }
    return changes;
  }
  /**
   * Set a row to visible
   * @param rowUid The UID of the row
   * @remarks - The row is set to visible and the row content is replaced with the original content.
   * - Only if the state has changed, the calculation of the odd and even rows is updated.
   */
  showRow(rowUid) {
    const changes = this._showRow(rowUid);
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Set a row to visible, replaces the placeholder with the original row content and updates the row stats
   * @param rowUid The UID of the row
   * @returns Whether the state has changed. Returns `false` if the row is already visible.
   */
  _showRow(rowUid) {
    this.logger.trace(`Row ${rowUid} should be shown.`);
    const changes = this.togleRowClass(rowUid, [this.defaultClasses.hiddenRow], false);
    this.logger.trace(`Row ${rowUid} changes: ${changes}`);
    if (changes) {
      this._addRowContent(rowUid);
      this._visibleRows++;
      this._hiddenRows--;
    }
    return changes;
  }
  /**
   * Set the state of multiple rows to hidden or visible
   * @param rows The rows to change
   * @param rows.rowUid The UID of the row
   * @param rows.hidden Whether to hide or show the row
   */
  async changeShowHideStateRows(rows) {
    this.logger.trace(`Change Show/Hide state of ${rows.length} rows.`);
    let changes = false;
    rows.forEach((row) => {
      this.logger.trace(`Change Show/Hide state of Row: ${row.rowUid} to ${row.hidden}.`);
      if (row.hidden) {
        this.logger.trace(`Hide Row: ${row.rowUid}`);
        const result = this._hideRow(row.rowUid);
        changes || (changes = result);
      } else {
        this.logger.trace(`Show Row: ${row.rowUid}`);
        const result = this._showRow(row.rowUid);
        changes || (changes = result);
      }
    });
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Replaces the row in table body with a placeholder
   * @param rowUid The UID of the row
   * @remarks - Search the row in the internal array,
   * - If found, get the placeholder from the internal array and replace the row in the table body with the placeholder.
   */
  _removeRowContent(rowUid) {
    const row = this.getRow(rowUid);
    if (row) {
      const placeholder = this._getPlaceholder(rowUid);
      this._table.body.replaceChild(placeholder, row);
    }
  }
  /**
   * Replaces the placeholder in table body with the row
   * @param rowUid The UID of the row
   * @remarks - Search the row in the internal array,
   * - If found, get the placeholder from the internal array and replace the placeholder in the table body with the row.
   */
  _addRowContent(rowUid) {
    const row = this.getRow(rowUid);
    if (row) {
      const placeholder = this._getPlaceholder(rowUid);
      if (placeholder) {
        try {
          this._table.body.replaceChild(row, placeholder);
        } catch (error) {
          this.logger.warn("Placeholder row not active in the table. Error:", error);
        }
      }
    }
  }
  /**
   * Generates a placeholder row
   * @param rowUid The UID of the row
   * @returns The generated placeholder row
   * @remarks - The placeholder row is empty and has the id `defaultIds.placeholder` (default: `placeholder-row`).
   * - The placeholder row is added to the internal array.
   */
  _generatePlaceholder(rowUid) {
    const placeholder = document.createElement("tr");
    placeholder.id = this.defaultIds.placeholder;
    placeholder.setAttribute("row-uid", rowUid);
    this._rowPlaceholders.push({ rowUid, row: placeholder });
    return placeholder;
  }
  /**
   * Removes the placeholder row with the given UID from the internal array
   * @param rowUid The UID of the row
   */
  _removePlaceholder(rowUid) {
    var _a;
    const placeholder = (_a = this._rowPlaceholders.find((rowPlaceholder) => rowPlaceholder.rowUid === rowUid)) == null ? void 0 : _a.row;
    if (placeholder) {
      this._rowPlaceholders = this._rowPlaceholders.filter((rowPlaceholder) => rowPlaceholder.rowUid !== rowUid);
    }
    return placeholder;
  }
  /**
   * Returns the placeholder row with the given UID
   * @param rowUid The UID of the row
   * @returns - The placeholder row with the given UID
   * - or a new placeholder row if no placeholder row with the given UID exists
   * @remarks - If a new placeholder row is generated, it is added to the internal array.
   */
  _getPlaceholder(rowUid) {
    var _a;
    const placeholder = (_a = this._rowPlaceholders.find((rowPlaceholder) => rowPlaceholder.rowUid === rowUid)) == null ? void 0 : _a.row;
    if (placeholder)
      return placeholder;
    else {
      return this._generatePlaceholder(rowUid);
    }
  }
  /**
   * Returns the row with the given UID
   * @param rowUid The UID of the row
   * @returns The row with the given UID or undefined if no row with the given UID exists
   */
  getRow(rowUid) {
    return this._table.rows.find((row) => row.getAttribute("row-uid") === rowUid);
  }
  /**
   * Toggles the class of a row
   * @param rowUid The UID of the row
   * @param classList The class list to toggle
   * @param add Whether to add or remove the class
   */
  togleRowClass(rowUid, classList, add) {
    let changes = false;
    const row = this.getRow(rowUid);
    if (row) {
      changes = this.toggleClass(row, classList, add);
    }
    return changes;
  }
  /**
   * Refreshes the odd and even rows with the corosponding classes
   * @remarks - The odd and even rows are calculated based on the visible rows from the internal array.
   * - Change the classes only if necessary.
   */
  refreshRowEvenOddClass() {
    const visibleRows = this._table.rows.filter((row) => !row.classList.contains(this.defaultClasses.hiddenRow));
    visibleRows.forEach((row, index) => {
      if (index % 2 === 0) {
        this.toggleClass(row, [this.defaultClasses.evenRow], true);
        this.toggleClass(row, [this.defaultClasses.oddRow], false);
      } else {
        this.toggleClass(row, [this.defaultClasses.evenRow], false);
        this.toggleClass(row, [this.defaultClasses.oddRow], true);
      }
    });
  }
  toggleClass(element, classList, add) {
    let changes = false;
    const presentClasses = element.classList;
    if (add) {
      classList.forEach((classItem) => {
        if (!presentClasses.contains(classItem)) {
          element.classList.add(classItem);
          changes = true;
        }
      });
    } else {
      classList.forEach((classItem) => {
        if (presentClasses.contains(classItem)) {
          element.classList.remove(classItem);
          changes = true;
        }
      });
    }
    return changes;
  }
  /**
   * Changes the header of the table
   * @param header The header to change; the header text must match the original header text
   */
  changeHeader(header) {
    this.changeHeaderClass(header);
    this.changeColumnClass(header);
    this._headers[this._headers.findIndex((headerItem) => headerItem.text === header.text)] = header;
  }
  changeHeaderClass(header) {
    const headerIndex = this._headers.findIndex((headerItem) => headerItem.text === header.text);
    const oldHeaderClasses = this._headers[headerIndex].headerClass;
    const newHeaderClasses = header.headerClass;
    const headerCell = this._table.headerCells[headerIndex];
    if (oldHeaderClasses) {
      this.toggleClass(headerCell, oldHeaderClasses, false);
    }
    if (newHeaderClasses) {
      this.toggleClass(headerCell, newHeaderClasses, true);
    }
  }
  changeColumnClass(header) {
    const columnIndex = this._headers.findIndex((headerItem) => headerItem.text === header.text);
    const oldHeaderClasses = this._headers[columnIndex].headerClass;
    this._table.rows.forEach((row) => {
      const cell = row.cells[columnIndex];
      if (cell) {
        if (oldHeaderClasses) {
          this.toggleClass(cell, oldHeaderClasses, false);
        }
        if (header.columnClass) {
          this.toggleClass(cell, header.columnClass, true);
        }
      }
    });
  }
  makeSafeForId(input) {
    let result = "";
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (i === 0 && !isNaN(Number(char))) {
        result += "_";
      } else if (char.match(/[a-zA-Z]/)) {
        result += char.toLowerCase();
      } else if (char.match(/[0-9]/)) {
        result += char;
      } else {
        result += "_";
      }
    }
    return result;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/FilterButton.ts
var import_obsidian5 = require("obsidian");
var FilterButton = class {
  /**
   * Creates a new filter button.
   * @param component The component to register the events to.
   * @param type The type of the filter button.
   * @param symbol The symbol of the filter button.
   * @param status The initial status of the filter button.
   * @param onFilter The callback to call when the filter button is clicked. Passes the type of the filter button and the status of the filter button.
   * @returns The created filter button as `DocumentFragment`.
   * @remarks - The filter button consists of a filter button container and a filter button.
   * - CSS classes:
   * - `filter-symbol` - The filter button.
   * - `filter-symbol-hide` - Additional class for the filter button to hide it.
   */
  static create(component, type2, symbol, status, onFilter) {
    const headerItemContainer = document.createDocumentFragment();
    const filterButtonContainer = document.createElement("div");
    headerItemContainer.appendChild(filterButtonContainer);
    const filter = FilterButton.createFilterButton(status, type2, symbol, component, onFilter);
    filterButtonContainer.appendChild(filter);
    return headerItemContainer;
  }
  /**
   * Creates the filter button.
   * @param status The initial status of the filter button.
   * @param type The type of the filter button.
   * @param symbol The symbol of the filter button.
   * @param component The component to register the events to.
   * @param filterCallback The callback to call when the filter button is clicked. Passes the type of the filter button and the status of the filter button.
   * @returns The created filter button as `DocumentFragment`.
   * @remarks - The filter button is a `HTMLAnchorElement`.
   * - CSS classes:
   * - `filter-symbol` - The filter button.
   * - `filter-symbol-hide` - Additional class for the filter button to hide it.
   */
  static createFilterButton(status, type2, symbol, component, filterCallback) {
    const logger = Global.getInstance().logger;
    const filterButtonContainer = document.createDocumentFragment();
    const filter = document.createElement("a");
    filterButtonContainer.appendChild(filter);
    filter.classList.add("filter-symbol");
    if (!status) {
      filter.classList.add("filter-symbol-hide");
    }
    filter.title = Lng.gt(type2);
    filter.href = "#";
    (0, import_obsidian5.setIcon)(filter, symbol);
    component.registerDomEvent(filter, "click", async (event) => {
      filter.classList.toggle("filter-symbol-hide");
      try {
        await filterCallback(type2, filter.classList.contains("filter-symbol-hide"));
      } catch (error) {
        logger.error("The `onFilter` callback threw an error!", error);
      }
    });
    return filterButtonContainer;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/MaxShownModelsInput.ts
var import_obsidian6 = require("obsidian");
var MaxShownModelsInput = class {
  /**
   * Creates a new max shown models input component.
   * @param component The component to register the events to.
   * @param defaultValue The default value of the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onChange The callback to call when the max shown models number changes. Passes the max shown models number. You can return a new max shown models number.
   * @returns The created max shown models input component as `DocumentFragment`.
   * @remarks - The max shown models input component consists of a container, a minus symbol, a presentation span and a plus symbol.
   * - CSS classes:
   * - `filter-max-models` - The container of the max shown models input component.
   * - `filter-max-number` - The presentation span of the max shown models input component.
   * - `minus-batch-button` - The minus symbol of the max shown models input component.
   * - `plus-batch-button` - The plus symbol of the max shown models input component.
   */
  static create(component, defaultValue, batchSize, onChange) {
    const headerItemContainer = document.createDocumentFragment();
    const logger = Global.getInstance().logger;
    let debounceTimer;
    const maxShownModels = {
      maxShownModels: !isNaN(parseFloat(defaultValue)) && isFinite(defaultValue) ? Number(defaultValue) : 0
    };
    const filterMaxModelsContainer = document.createElement("div");
    headerItemContainer.appendChild(filterMaxModelsContainer);
    filterMaxModelsContainer.classList.add("filter-max-models");
    const number = this.createNumberPresentation(maxShownModels, component, batchSize);
    const debounceOnChange = () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        var _a;
        try {
          maxShownModels.maxShownModels = (_a = await onChange(maxShownModels.maxShownModels)) != null ? _a : maxShownModels.maxShownModels;
        } catch (error) {
          logger.error("The `onChange` callback threw an error!", error);
        } finally {
          number.number.textContent = maxShownModels.maxShownModels.toString();
        }
      }, 500);
    };
    MaxShownModelsInput.createNumberPresentationEvent(
      component,
      number.number,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    const minus = this.createSymbol(
      "minus",
      number.number,
      component,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    const plus = this.createSymbol(
      "plus",
      number.number,
      component,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    filterMaxModelsContainer.appendChild(minus);
    filterMaxModelsContainer.appendChild(number.container);
    filterMaxModelsContainer.appendChild(plus);
    return headerItemContainer;
  }
  /**
   * Create the presentation span for the max shown models number.
   * @param maxShownModels The container for the max shown models number.
   * @returns - The created presentation span as `DocumentFragment`
   * - The created presentation span as `HTMLSpanElement`
   * - The span element has the class `filter-max-number`.
   */
  static createNumberPresentation(maxShownModels, component, batchSize) {
    const filterMaxModelsContainer = document.createDocumentFragment();
    const maxShownNumber = document.createElement("span");
    filterMaxModelsContainer.appendChild(maxShownNumber);
    maxShownNumber.classList.add("filter-max-number");
    maxShownNumber.title = Lng.gt("MaxShownEntrys");
    maxShownNumber.textContent = maxShownModels.maxShownModels.toString();
    return { container: filterMaxModelsContainer, number: maxShownNumber };
  }
  /**
   * Creates the mouse wheel events for the max shown models number presentation span.
   * @param component The component to register the events to.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   */
  static createNumberPresentationEvent(component, maxShownNumber, maxShownModels, batchSize, onMaxShownModelsChange) {
    component.registerDomEvent(maxShownNumber, "wheel", async (event) => {
      event.preventDefault();
      if (event.deltaY > 0) {
        this.changeValue("minus", maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
      } else {
        this.changeValue("plus", maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
      }
    }, { passive: false });
  }
  /**
   * Creates a symbol for the max shown models number.
   * @param type The type of the symbol. Can be `plus` or `minus`.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param component The component to register the events to.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   * @returns The created symbol as `DocumentFragment`.
   * @remarks - The symbol is a `HTMLAnchorElement`.
   * - The symbol has the class `plus-batch-button` or `minus-batch-button`.
   */
  static createSymbol(type2, maxShownNumber, component, maxShownModels, batchSize, onMaxShownModelsChange) {
    const filterMaxModelsContainer = document.createDocumentFragment();
    const maxShownDocMinus = document.createElement("a");
    filterMaxModelsContainer.appendChild(maxShownDocMinus);
    maxShownDocMinus.classList.add(`${type2}-batch-button`);
    maxShownDocMinus.title = type2;
    maxShownDocMinus.href = "#";
    (0, import_obsidian6.setIcon)(maxShownDocMinus, type2);
    component.registerDomEvent(maxShownDocMinus, "click", async (event) => {
      this.changeValue(type2, maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
    });
    return filterMaxModelsContainer;
  }
  /**
   * Changes the max shown models number.
   * @param type The type of the symbol. Can be `plus` or `minus`.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   */
  static changeValue(type2, maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange) {
    if (type2 === "minus") {
      if (maxShownModels.maxShownModels >= batchSize) {
        maxShownModels.maxShownModels -= maxShownModels.maxShownModels % batchSize || batchSize;
      } else {
        maxShownModels.maxShownModels = 0;
      }
    } else {
      maxShownModels.maxShownModels += batchSize - maxShownModels.maxShownModels % batchSize;
    }
    maxShownNumber.textContent = maxShownModels.maxShownModels.toString();
    onMaxShownModelsChange();
  }
};

// src/libs/BlockRenderComponents/InnerComponents/SearchInput.ts
var SearchInput = class {
  /**
   * Creates a new search input component.
   * @param component The component to register the events to.
   * @param onSearch The callback to call when the search box value changes. Passes the search box value and the key that was pressed.
   * @returns The created search input component as `DocumentFragment`.
   * @remarks - The search input component consists of a label, an input sizer and a search box.
   * - CSS classes:
   *  - `filter-search` - The container of the search input component.
   *  - `filter-text` - The label of the search input component.
   *  - `search-box-sizer` - The sizer of the search input component.
   *  - `search-box` - The search box of the search input component.
   */
  static create(component, onSearch) {
    const logger = Global.getInstance().logger;
    const headerItemContainer = document.createDocumentFragment();
    const searchLabelContainer = document.createElement("div");
    headerItemContainer.appendChild(searchLabelContainer);
    searchLabelContainer.classList.add("filter-search");
    SearchInput.createSearchLabel(searchLabelContainer);
    const searchBoxSizer = SearchInput.createSearchBoxSizer(searchLabelContainer);
    const searchBoxInput = SearchInput.createSearchBoxInput(searchBoxSizer);
    component.registerDomEvent(searchBoxInput, "input", async (event) => {
      this.setSearchBoxSizerValue(searchBoxSizer, searchBoxInput.value);
    });
    component.registerDomEvent(searchBoxInput, "keydown", async (event) => {
      let value = searchBoxInput.value;
      try {
        value = await onSearch(searchBoxInput.value, event.key);
      } catch (error) {
        logger.error("The `onSearch` callback threw an error!", error);
      } finally {
        this.setSearchBoxSizerValue(searchBoxSizer, value);
        this.setSearchBoxInputValue(searchBoxInput, value);
      }
    });
    return headerItemContainer;
  }
  /**
   * Creates the search label.
   * @param searchLabelContainer The container to append the label to. 
   * @remarks - The label is a `HTMLSpanElement`.
   * - The label text is `Search`-value of the translation.
   * - The label element has the class `filter-text`.
   */
  static createSearchLabel(searchLabelContainer) {
    const filterLabel = document.createElement("span");
    searchLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-text");
    filterLabel.textContent = Lng.gt("Search") + ":";
  }
  /**
   * Creates the search box sizer.
   * @param searchLabelContainer The container to append the sizer to.
   * @returns The created search box sizer.
   * @remarks - The sizer is a `HTMLLabelElement`.
   * - The sizer has the class `search-box-sizer`.
   */
  static createSearchBoxSizer(searchLabelContainer) {
    const searchBoxSizer = document.createElement("label");
    searchLabelContainer.appendChild(searchBoxSizer);
    searchBoxSizer.classList.add("search-box-sizer");
    return searchBoxSizer;
  }
  /**
   * Creates the search box input.
   * @param searchBoxSizer The container to append the input to.
   * @returns The created search box input.
   * @remarks - The input is a `HTMLInputElement`.
   * - The input type is `text`.
   * - The input placeholder is `Search`-value of the translation.
   * - The input element has the class `search-box`.
   */
  static createSearchBoxInput(searchBoxSizer) {
    const searchBoxInput = document.createElement("input");
    searchBoxSizer.appendChild(searchBoxInput);
    searchBoxInput.classList.add("search-box");
    searchBoxInput.type = "text";
    searchBoxInput.placeholder = Lng.gt("Search");
    searchBoxInput.value = "";
    return searchBoxInput;
  }
  /**
   * Sets the search box sizer value.
   * @param searchBoxSizer The search box sizer to set the value to.
   * @param value The value to set.
   */
  static setSearchBoxSizerValue(searchBoxSizer, value) {
    searchBoxSizer.dataset.value = "_" + value + "_";
  }
  /**
   * Sets the search box input value.
   * @param searchBoxInput The search box input to set the value to.
   * @param value The value to set.
   */
  static setSearchBoxInputValue(searchBoxInput, value) {
    searchBoxInput.value = value;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/DocumentComponents.ts
var import_obsidian10 = require("obsidian");

// src/libs/EditableDataView/Components/BaseComponent.ts
var import_obsidian7 = require("obsidian");
var BaseComponent = class {
  //#endregion
  constructor(component) {
    this.cancelButton = void 0;
    this.saveButton = void 0;
    this.component = component;
    this.shippingContainer = document.createElement("div");
    this.shippingContainer.classList.add("editable-data-view", "container");
  }
  get container() {
    return this.shippingContainer;
  }
  /**
   * Creates the base structure of the component.
   * @param editabilityEnabled If `true`, the component will be created to allow editing.
   * @tutorial Run this methode in the `finalize`-methode of the child class before creating your elements.
   */
  createBaseStructure(editabilityEnabled = this.editabilityEnabled) {
    this.presentationContainer = document.createElement("div");
    this.presentationContainer.classList.add("editable-data-view", "presentation-container");
    this.shippingContainer.appendChild(this.presentationContainer);
    if (editabilityEnabled && (import_obsidian7.Platform.isMobile ? Global.getInstance().settings.mobile : true)) {
      this.buttonContainer = document.createElement("div");
      this.buttonContainer.classList.add("editable-data-view", "button-container");
      this.createEditButton();
      this.shippingContainer.appendChild(this.buttonContainer);
    }
  }
  /**
   * Creates the `edit` button and adds it to the `buttonContainer`.
   */
  createEditButton() {
    this.editButton = document.createElement("button");
    this.buttonContainer.appendChild(this.editButton);
    this.editButton.classList.add("editable-data-view");
    this.editButton.classList.add("button");
    (0, import_obsidian7.setIcon)(this.editButton, "pen");
    this.component.registerDomEvent(this.editButton, "click", () => this.enableEditMode());
  }
  /**
   * Creates the `save` and `cancel` buttons and the `input` container and adds them to the `buttonContainer`.
   */
  createComponentsForEdit() {
    this.dataInputContainer = document.createElement("div");
    this.dataInputContainer.classList.add("editable-data-view", "data-input-container", "hidden");
    this.shippingContainer.insertBefore(this.dataInputContainer, this.presentationContainer);
    this.cancelButton = document.createElement("button");
    this.buttonContainer.insertAfter(this.cancelButton, this.editButton);
    this.cancelButton.classList.add("editable-data-view");
    this.cancelButton.classList.add("button");
    this.cancelButton.classList.add("hidden");
    (0, import_obsidian7.setIcon)(this.cancelButton, "x");
    this.component.registerDomEvent(this.cancelButton, "click", () => this.disableEditMode());
    this.saveButton = document.createElement("button");
    this.buttonContainer.insertAfter(this.saveButton, this.cancelButton);
    this.saveButton.classList.add("editable-data-view");
    this.saveButton.classList.add("button");
    this.saveButton.classList.add("hidden");
    (0, import_obsidian7.setIcon)(this.saveButton, "check");
    this.component.registerDomEvent(this.saveButton, "click", () => this.saveChanges());
  }
  /**
   * This method is called after the final configuration of the component.
   */
  finalize() {
    var _a;
    this.createBaseStructure();
    (_a = this.onFinalize) == null ? void 0 : _a.call(this);
  }
  /**
   * This method is called when the user clicks on the `edit` button.
   * It should switch the component to edit mode and 
   * create the `save` and `cancel` buttons if not already created.
   * @remarks You can call this methode to simulate a click on the `edit` button.
   */
  enableEditMode() {
    var _a, _b;
    if (!this.cancelButton || !this.saveButton) {
      this.createComponentsForEdit();
      (_a = this.onFirstEdit) == null ? void 0 : _a.call(this);
    }
    if (this.cancelButton && this.saveButton) {
      this.presentationContainer.classList.add("hidden");
      this.dataInputContainer.classList.remove("hidden");
      this.cancelButton.classList.remove("hidden");
      this.saveButton.classList.remove("hidden");
      this.editButton.classList.add("hidden");
      (_b = this.onEnableEditCallback) == null ? void 0 : _b.call(this);
    }
  }
  /**
   * This method is called when the user clicks on the `cancel` button or 
   * after the `saveChanges`-methode is clicked.
   * @remarks You can call this methode to simulate a click on the `cancel` button.
   */
  disableEditMode() {
    var _a;
    if (this.cancelButton && this.saveButton) {
      this.presentationContainer.classList.remove("hidden");
      this.dataInputContainer.classList.add("hidden");
      this.cancelButton.classList.add("hidden");
      this.saveButton.classList.add("hidden");
      this.editButton.classList.remove("hidden");
      (_a = this.onDisableEditCallback) == null ? void 0 : _a.call(this);
    }
  }
  /**
   * This method is called when the user clicks on the `save` button.
   * @remarks You can call this methode to simulate a click on the `save` button.
   */
  async saveChanges() {
    var _a;
    if (this.cancelButton && this.saveButton) {
      await ((_a = this.onSaveCallback) == null ? void 0 : _a.call(this));
      this.disableEditMode();
    }
  }
};

// src/libs/EditableDataView/Components/DateComponent.ts
var DateComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = formator;
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("date-presentation");
    this.presentationSpan.textContent = this._onPresentation ? this._onPresentation(this._value) : this._value;
  }
  buildInput() {
    this.input = document.createElement("input");
    this.dataInputContainer.appendChild(this.input);
    this.input.type = "date";
    this.input.title = this._title;
    this.input.classList.add("editable-data-view");
    this.input.classList.add("date-input");
  }
  enableEdit() {
    this.input.value = this._value ? this._value : "";
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    this.presentationSpan.textContent = this._onPresentation ? this._onPresentation(this._value) : this._value;
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/DropdownComponent.ts
var DropdownComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  get _selectedOption() {
    const selectedOption = this._options.find((o) => o.value === this._value);
    if (selectedOption)
      return selectedOption;
    return { value: this._value, text: this._value };
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the options of the component.
   * @param options The options to set.
   * @returns The component itself.
   */
  setOptions(options) {
    this._options = options;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks - The formator is called when the component change in `not-edit` mode.
   * - `value` is the value of the selected option. (Not the text!)
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      const { text, html } = formator(value);
      if (html) {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.appendChild(html);
      } else {
        this.presentationSpan.textContent = text;
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks - The saver is called when the component save button is clicked.
   * - `value` is the value of the selected option. (Not the text!)
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  enableOptions() {
    const optionFound = this._options.find((o) => o.value === this._value);
    if (!optionFound) {
      const optionElement = document.createElement("option");
      optionElement.value = this._value;
      optionElement.textContent = `${this._value} (not in options)`;
      this.select.appendChild(optionElement);
    }
    this._options.forEach((option) => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      this.select.appendChild(optionElement);
    });
  }
  disableOptions() {
    this.select.innerHTML = "";
  }
  //#region Base Callbacks
  build() {
    var _a;
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("text-presentation");
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._selectedOption.value);
  }
  buildInput() {
    this.select = document.createElement("select");
    this.dataInputContainer.appendChild(this.select);
    this.select.title = this._title;
    this.select.classList.add("editable-data-view");
    this.select.classList.add("select-input");
  }
  enableEdit() {
    this.enableOptions();
    this.select.value = this._value ? this._value : "";
    this.select.focus();
  }
  disableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._selectedOption.value);
    this.disableOptions();
  }
  async save() {
    var _a;
    this._value = this.select.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/LinkComponent.ts
var LinkComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.linkType = "external";
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets suggestions for the input element.
   * @param suggestions The suggestions to set.
   * @returns The component itself.
   */
  setSuggestions(suggestions) {
    this._suggestions = suggestions;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the type of the link.
   * @param type The type to set. Can be `tag`, `file` or `external`.
   * @returns The component itself.
   */
  setLinkType(type2) {
    this.linkType = type2;
    return this;
  }
  /**
   * Sets the suggester of the component.
   * @param suggester The suggester to set.
   * @returns The component itself.
   * @remarks The suggester is called when the user types in the input element.
   */
  setSuggester(suggester) {
    this._suggester = suggester;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      const linkContent = formator(value);
      this.link.href = linkContent.href;
      if (linkContent.html) {
        this.link.innerHTML = "";
        this.link.appendChild(linkContent.html);
      } else
        this.link.textContent = linkContent.text;
      switch (this.linkType) {
        case "tag":
          break;
        case "file":
          this.link.setAttribute("aria-label", linkContent.href);
          this.link.setAttribute("data-href", linkContent.href);
          break;
        case "external":
          break;
      }
      if (this.input && this.label) {
        this.input.value = linkContent.text ? linkContent.text : "";
        this.label.dataset.value = linkContent.text ? linkContent.text : this._placeholder ? this._placeholder : "";
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  setSuggestionsList(suggestions) {
    if (!this.datalist)
      return;
    this.datalist.innerHTML = "";
    suggestions.forEach((suggestion) => {
      const option = document.createElement("option");
      option.value = suggestion;
      this.datalist.appendChild(option);
    });
  }
  //#region Base Callbacks
  build() {
    var _a;
    this.link = document.createElement("a");
    this.presentationContainer.appendChild(this.link);
    this.link.title = this._title;
    this.link.classList.add("editable-data-view");
    this.link.classList.add("link-presentation");
    switch (this.linkType) {
      case "tag":
        this.link.classList.add("tag");
        this.link.target = "_blank";
        this.link.rel = "noopener";
        break;
      case "file":
        this.link.setAttribute("data-tooltip-position", "top");
        this.link.classList.add("internal-link");
        this.link.target = "_blank";
        this.link.rel = "noopener";
        break;
      case "external":
        break;
    }
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("text-input-sizer");
    this.input = document.createElement("input");
    this.label.appendChild(this.input);
    this.input.classList.add("editable-data-view");
    this.input.classList.add("text-input");
    this.input.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.input, "input", () => {
      this.label.dataset.value = this.input.value ? this.input.value : this._placeholder ? this._placeholder : "";
      if (this._suggester && this.label.dataset.value !== this._placeholder && this.label.dataset.value !== "")
        this.setSuggestionsList(this._suggester(this.input.value));
    });
    this.component.registerDomEvent(this.input, "keydown", (event) => {
      if (event.key === "Enter") {
        this.saveChanges();
      } else if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
    if (this._suggestions && this._suggestions.length > 0 || this._suggester) {
      const id = Math.random().toString(36).substring(2, 10);
      this.input.setAttribute("list", id);
      this.datalist = document.createElement("datalist");
      this.datalist.id = id;
      this.input.appendChild(this.datalist);
      this.setSuggestionsList(this._suggestions);
    }
  }
  enableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/TextComponent.ts
var import_obsidian8 = require("obsidian");
var TextComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets suggestions for the input element.
   * @param suggestions The suggestions to set.
   * @returns The component itself.
   */
  setSuggestions(suggestions) {
    this._suggestions = suggestions;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the suggester of the component.
   * @param suggester The suggester to set.
   * @returns The component itself.
   * @remarks The suggester is called when the user types in the input element.
   */
  setSuggester(suggester) {
    this._suggester = suggester;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      this.presentationSpan.textContent = await formator(this._value);
    };
    return this;
  }
  /**
   * Sets the markdown formator of the component.
   * @param path The path of the file to resolve internal links.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   * - The custom formator is ignored if this method is called!
   */
  setRenderMarkdown(path = "") {
    this._onMarkdownPresentation = (value) => {
      if (Helper.isPossiblyMarkdown(value)) {
        const app = Global.getInstance().app;
        return import_obsidian8.MarkdownRenderer.render(app, value, this.presentationSpan, path, this.component);
      } else {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.textContent = value;
        return Promise.resolve();
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  setSuggestionsList(suggestions) {
    if (!this.datalist)
      return;
    this.datalist.innerHTML = "";
    if (!suggestions)
      return;
    suggestions.forEach((suggestion) => {
      const option = document.createElement("option");
      option.value = suggestion;
      this.datalist.appendChild(option);
    });
  }
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("text-presentation");
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("text-input-sizer");
    this.input = document.createElement("input");
    this.label.appendChild(this.input);
    this.input.classList.add("editable-data-view");
    this.input.classList.add("text-input");
    this.input.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.input, "input", () => {
      this.label.dataset.value = this.input.value ? this.input.value : this._placeholder ? this._placeholder : "";
      if (this._suggester && this.label.dataset.value !== this._placeholder && this.label.dataset.value !== "")
        this.setSuggestionsList(this._suggester(this.input.value));
    });
    this.component.registerDomEvent(this.input, "keydown", (event) => {
      if (event.key === "Enter") {
        this.saveChanges();
      } else if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
    if (this._suggestions && this._suggestions.length > 0 || this._suggester) {
      const id = Math.random().toString(36).substring(2, 10);
      this.input.setAttribute("list", id);
      this.datalist = document.createElement("datalist");
      this.datalist.id = id;
      this.input.appendChild(this.datalist);
      this.setSuggestionsList(this._suggestions);
    }
  }
  enableEdit() {
    this.input.value = this._value ? this._value : "";
    this.label.dataset.value = this._value ? this._value : this._placeholder ? this._placeholder : "";
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/TextareaComponent.ts
var import_obsidian9 = require("obsidian");
var TextareaComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      this.presentationSpan.textContent = await formator(this._value);
    };
    return this;
  }
  /**
   * Sets the markdown formator of the component.
   * @param path The path of the file to resolve internal links.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   * - The custom formator is ignored if this method is called!
   */
  setRenderMarkdown(path = "") {
    this._onMarkdownPresentation = (value) => {
      if (Helper.isPossiblyMarkdown(value)) {
        const app = Global.getInstance().app;
        return import_obsidian9.MarkdownRenderer.render(app, value, this.presentationSpan, path, this.component);
      } else {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.textContent = value;
        return Promise.resolve();
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("textarea-presentation");
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("textarea-input-sizer");
    this.textarea = document.createElement("textarea");
    this.label.appendChild(this.textarea);
    this.textarea.classList.add("editable-data-view");
    this.textarea.classList.add("textarea-input");
    this.textarea.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.textarea, "input", () => {
      this.label.dataset.value = this.textarea.value ? this.textarea.value : this._placeholder ? this._placeholder : "";
    });
    this.component.registerDomEvent(this.textarea, "keydown", (event) => {
      if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
  }
  enableEdit() {
    this.textarea.value = this._value ? this._value : "";
    this.label.dataset.value = this._value ? this._value : this._placeholder ? this._placeholder : "";
    this.textarea.focus();
    this.textarea.select();
  }
  disableEdit() {
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  async save() {
    var _a;
    this._value = this.textarea.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/EditableDataView.ts
var EditableDataView = class {
  constructor(container, component) {
    this.attributesList = {};
    this._container = container;
    this.component = component;
  }
  addText(configure) {
    const textComponent = new TextComponent(this.component);
    configure(textComponent);
    textComponent.finalize();
    this._container.append(textComponent.container);
    return this;
  }
  addTextarea(configure) {
    const textComponent = new TextareaComponent(this.component);
    configure(textComponent);
    textComponent.finalize();
    this._container.append(textComponent.container);
    return this;
  }
  addLink(configure) {
    const linkComponent = new LinkComponent(this.component);
    configure(linkComponent);
    linkComponent.finalize();
    this._container.appendChild(linkComponent.container);
    return this;
  }
  addDate(configure) {
    const dateComponent = new DateComponent(this.component);
    configure(dateComponent);
    dateComponent.finalize();
    this._container.append(dateComponent.container);
    return this;
  }
  addDropdown(configure) {
    const dropdownComponent = new DropdownComponent(this.component);
    configure(dropdownComponent);
    dropdownComponent.finalize();
    this._container.appendChild(dropdownComponent.container);
    return this;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/DocumentComponents.ts
var DocumentComponents = class {
  static createCellTags(tagContainer, component, tags) {
    tags.forEach((tag) => {
      new EditableDataView(tagContainer, component).addLink(
        (link) => link.setValue(tag).setTitle("Tag").setLinkType("tag").setFormator((value) => {
          return { href: `#${value}`, text: `#${value}` };
        })
      );
    });
  }
  static createCellSummary(documentModel, component, summaryRelatedFiles) {
    const description = documentModel.getDescription();
    new EditableDataView(summaryRelatedFiles, component).addTextarea(
      (textarea) => textarea.setValue(description).setTitle("Summary").enableEditability().setRenderMarkdown().onSave((value) => {
        documentModel.data.description = value;
        return Promise.resolve();
      })
    );
  }
  static createRelatedFilesList(relatedFilesList, component, documentModel, noneDocSymbol, dateFormatShort) {
    const relatedFiles = documentModel.relatedFiles;
    if (!relatedFiles || relatedFiles.length === 0)
      return;
    const container = document.createElement("div");
    relatedFilesList.appendChild(container);
    container.classList.add("related-files-container");
    const breakLine = document.createElement("hr");
    container.appendChild(breakLine);
    breakLine.classList.add("related-files-breakline");
    const list = document.createElement("ul");
    container.appendChild(list);
    list.classList.add("related-files-list");
    relatedFiles.forEach((relatedFile) => {
      const listEntry = document.createElement("li");
      list.append(listEntry);
      const gridContainer = document.createElement("div");
      listEntry.appendChild(gridContainer);
      gridContainer.classList.add("grid-container");
      const iconContainer = document.createElement("span");
      gridContainer.append(iconContainer);
      iconContainer.classList.add("icon-container");
      const inputOutputState = relatedFile.getInputOutputState();
      let listIconString = noneDocSymbol;
      if (inputOutputState === "Input") {
        listIconString = "corner-left-down";
      } else if (inputOutputState === "Output") {
        listIconString = "corner-right-up";
      }
      (0, import_obsidian10.setIcon)(iconContainer, listIconString);
      const metadataContainer = document.createElement("span");
      gridContainer.append(metadataContainer);
      metadataContainer.classList.add("metadata-file-container");
      const metadataFragment = document.createDocumentFragment();
      this.createCellMetadatalink(metadataFragment, component, relatedFile);
      metadataContainer.appendChild(metadataFragment);
      const dateContainer = document.createElement("span");
      gridContainer.append(dateContainer);
      dateContainer.classList.add("date-container");
      new EditableDataView(dateContainer, component).addDate((date) => {
        var _a;
        return date.setValue((_a = relatedFile.data.date) != null ? _a : "na").setTitle("Document Date").setFormator(
          (value) => Helper.formatDate(value, Helper.formatDate(value, dateFormatShort))
        );
      });
      const textContainer = document.createElement("span");
      gridContainer.append(textContainer);
      textContainer.classList.add("data-container");
      const linkFragment = document.createDocumentFragment();
      this.createCellFileLink(linkFragment, component, relatedFile, false);
      textContainer.append(linkFragment);
    });
  }
  static createCellSenderRecipient(documentModel, component, models) {
    var _a, _b;
    const senderRecipient = document.createDocumentFragment();
    const container = document.createElement("div");
    senderRecipient.appendChild(container);
    container.classList.add("senderRecipient");
    const inputOutputState = documentModel.getInputOutputState();
    const sender = (_a = documentModel.data.sender) != null ? _a : null;
    const recipient = (_b = documentModel.data.recipient) != null ? _b : null;
    if (sender && inputOutputState !== "Output") {
      const senderContainer = document.createElement("div");
      senderContainer.classList.add("container");
      const fromTo = document.createElement("span");
      fromTo.classList.add("fromTo");
      fromTo.textContent = Lng.gt("From");
      senderContainer.appendChild(fromTo);
      const name = document.createElement("span");
      name.classList.add("name");
      senderContainer.appendChild(name);
      this.createEDVSenderRecipient(name, component, sender, "Sender", (value) => {
        documentModel.data.sender = value;
        return Promise.resolve();
      }, models);
      container.appendChild(senderContainer);
    }
    if (recipient && inputOutputState !== "Input") {
      const recipientContainer = document.createElement("div");
      recipientContainer.classList.add("container");
      const fromTo = document.createElement("span");
      fromTo.classList.add("fromTo");
      fromTo.textContent = Lng.gt("To");
      recipientContainer.appendChild(fromTo);
      const name = document.createElement("span");
      name.classList.add("name");
      recipientContainer.appendChild(name);
      this.createEDVSenderRecipient(name, component, recipient, "Recipient", (value) => {
        documentModel.data.recipient = value;
        return Promise.resolve();
      }, models);
      container.appendChild(recipientContainer);
    }
    return senderRecipient;
  }
  static createEDVSenderRecipient(name, component, value, title, onSaveCallback, models = []) {
    return new EditableDataView(name, component).addText(
      (text) => text.setValue(value).setTitle(title).enableEditability().setSuggester((inputValue) => {
        const suggestions = models.flatMap((document2) => [document2.data.sender, document2.data.recipient]).filter((v) => v != null).filter((v, index, self2) => self2.indexOf(v) === index).filter((v) => v.includes(inputValue)).sort().splice(0, 10);
        return suggestions;
      }).onSave((newValue) => onSaveCallback(newValue))
    );
  }
  static createCellFileLink(fileLink, component, documentModel, editability = true) {
    const fileCache = Global.getInstance().fileCache;
    const app = Global.getInstance().app;
    new EditableDataView(fileLink, component).addLink((link) => {
      var _a;
      link.setValue((_a = documentModel.data.title) != null ? _a : "").setTitle(Lng.gt("PDFFile")).setLinkType("file").setFormator((value) => {
        var _a2, _b;
        const baseFileData = Helper.extractDataFromWikilink(documentModel.data.file);
        const baseFile = fileCache.findFileByName((_a2 = baseFileData.filename) != null ? _a2 : "");
        let baseFilePath = (_b = baseFileData.filename) != null ? _b : "";
        if (baseFile && baseFile instanceof import_obsidian10.TFile) {
          baseFilePath = baseFile.path;
        }
        let docFragment = void 0;
        if (Helper.isPossiblyMarkdown(value)) {
          docFragment = document.createDocumentFragment();
          const div = document.createElement("div");
          import_obsidian10.MarkdownRenderer.render(app, value != null ? value : "", div, "", component);
          docFragment.appendChild(div);
        }
        return { href: `${baseFilePath}`, text: `${value}`, html: docFragment };
      });
      if (editability) {
        link.enableEditability().onSave((value) => {
          documentModel.data.title = value;
          return Promise.resolve();
        });
      }
    });
  }
  static createCellMetadatalink(metadataLink, component, documentModel) {
    const settings = Global.getInstance().settings;
    new EditableDataView(metadataLink, component).addLink((link) => link.setValue(documentModel.file.path).setTitle("Open metadata file").setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        let iconString = "x-circle";
        if (documentModel.data.hide === true) {
          iconString = settings.documentSettings.hideSymbol;
        } else {
          if (documentModel.data.subType === "Cluster") {
            iconString = settings.documentSettings.clusterSymbol;
          } else {
            iconString = settings.documentSettings.symbol;
          }
        }
        (0, import_obsidian10.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
};

// src/libs/BlockRenderComponents/InnerComponents/GeneralComponents.ts
var import_obsidian11 = require("obsidian");
var GeneralComponents = class {
  /**
   * Creates a link to the file at `path` with the `corospondingSymbol` as icon.
   * @param container The container to append the link to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param type The type of the file.
   * @param corospondingSymbol The corosponding symbol for the file type.
   */
  static createMetadataLink(container, component, path, type2, corospondingSymbol) {
    new EditableDataView(container, component).addLink((link) => link.setValue(path).setTitle(Lng.gt(type2 != null ? type2 : "File")).setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        const iconString = corospondingSymbol;
        (0, import_obsidian11.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
  static createCellDate(date, component, title, format, onRead, onWrite) {
    new EditableDataView(date, component).addDate(
      (date2) => date2.setValue(onRead()).setTitle(title).enableEditability().setFormator((value) => Helper.formatDate(value, format)).onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      })
    );
  }
};

// src/libs/BlockRenderComponents/DocumentBlockRenderComponent.ts
var DocumentBlockRenderComponent = class extends TableBlockRenderComponent {
  constructor(settings) {
    super(settings);
    this.settings = {
      tags: [],
      docSymbol: this.global.settings.documentSettings.symbol,
      hideDocSymbol: this.global.settings.documentSettings.hideSymbol,
      clusterSymbol: this.global.settings.documentSettings.clusterSymbol,
      noneDocSymbol: "diamond",
      filter: ["Documents"],
      maxDocuments: this.global.settings.defaultMaxShow,
      search: void 0,
      batchSize: 8,
      sleepBetweenBatches: 10
    };
    /**
     * The table headers.
     * @remarks The table headers are used to create the table.
     * 
     */
    this.tableHeaders = [
      { text: Lng.gt("DocumentType"), headerClass: [], columnClass: ["dont-decorate-link", "font-medium"] },
      { text: Lng.gt("Date"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Subject"), headerClass: [], columnClass: [] },
      { text: Lng.gt("SendRecip"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Content"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("DeliveryDate"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Tags"), headerClass: [], columnClass: ["tags"] }
    ];
    this.parseSettings();
  }
  build() {
    return super.build();
  }
  /**
   * Draws the component and adds the documents to the table.
   * @returns A promise which is resolved when the documents are added to the table.
   * @remarks - Calls the `super.draw` method.
   * - Calls the `buildTable` method.
   * - Calls the `buildHeader` method.
   * - Calls the `addDocumentsToTable` method.
   */
  async draw() {
    const startTime = Date.now();
    const documentsPromise = this.getModels();
    await super.draw();
    await this.buildTable();
    await this.buildHeader();
    this.grayOutHeader();
    this.models = await documentsPromise;
    DocumentModel.sortDocumentsByDateDesc(this.models);
    await this.addDocumentsToTable();
    this.normalizeHeader();
    const endTime = Date.now();
    this.logger.debug(`Redraw Documents (for ${this.models.length} Docs.) runs for ${endTime - startTime}ms`);
  }
  /**
   * Builds the header.
   * @remarks - The header is saved in the `headerContainer` property.
   * - Creates the `filter container`.
   * - Creates the `filter label`.
   * - Creates the `filter buttons`: `Documents`, `HideDocuments` and `Cluster`.
   * - Creates the `max documents input`.
   * - Creates the `search box`.
   */
  async buildHeader() {
    const headerFilterButtons = document.createElement("div");
    this.headerContainer.appendChild(headerFilterButtons);
    headerFilterButtons.classList.add("header-item");
    headerFilterButtons.classList.add("filter-symbols");
    const filterLabelContainer = document.createElement("div");
    headerFilterButtons.appendChild(filterLabelContainer);
    const filterLabel = document.createElement("span");
    filterLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-symbol");
    filterLabel.textContent = Lng.gt("Filter");
    const documentFilterButton = FilterButton.create(
      this.component,
      "Documents",
      this.settings.docSymbol,
      this.settings.filter.includes("Documents"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(documentFilterButton);
    const hideDocumentFilterButton = FilterButton.create(
      this.component,
      "HideDocuments",
      this.settings.hideDocSymbol,
      this.settings.filter.includes("HideDocuments"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(hideDocumentFilterButton);
    const clusterFilterButton = FilterButton.create(
      this.component,
      "Cluster",
      this.settings.clusterSymbol,
      this.settings.filter.includes("Cluster"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(clusterFilterButton);
    const maxDocuments = MaxShownModelsInput.create(
      this.component,
      this.settings.maxDocuments,
      this.global.settings.defaultMaxShow,
      this.onMaxDocumentsChange.bind(this)
    );
    headerFilterButtons.appendChild(maxDocuments);
    const searchBox = SearchInput.create(
      this.component,
      this.onSearch.bind(this)
    );
    headerFilterButtons.appendChild(searchBox);
  }
  /**
   * This method is called when the filter button is clicked.
   * @param type The type of the filter button.
   * @param status The new status of the filter button.
   * @remarks Runs the `onFilter` method.
   */
  async onFilterButton(type2, status) {
    if (this.settings.filter.includes(type2)) {
      this.settings.filter = this.settings.filter.filter((v) => v !== type2);
    } else {
      this.settings.filter.push(type2);
    }
    this.onFilter();
  }
  /**
   * This method is called when the max documents input is changed.
   * @param maxDocuments The new max documents value.
   * @returns A promise which is resolved when the documents are filtered.
   * @remarks Runs the `onFilter` method.
   */
  async onMaxDocumentsChange(maxDocuments) {
    this.settings.maxDocuments = maxDocuments;
    this.onFilter();
    return void 0;
  }
  /**
   * This method is called when the search box is used.
   * @param search The search text.
   * @param key The key that was pressed.
   * @returns The search text.
   * @remarks - If the `Enter` key was pressed, the search is applied.
   * - If the `Escape` key was pressed, the search is reset.
   * - After the search is applied, the `onFilter` method is called.
   */
  async onSearch(search, key) {
    if (key === "Enter") {
      if (search !== "") {
        this.settings.search = Search.parseSearchText(search);
        this.onFilter();
      } else {
        this.settings.search = void 0;
        this.onFilter();
      }
    } else if (key === "Escape") {
      this.settings.search = void 0;
      this.onFilter();
      return "";
    }
    return search;
  }
  /**
   * Filters the documents and shows/hides them in the table.
   * @remarks - The documents are filtered by the `filter` setting,
   * searched by the `search` setting 
   * and the number of documents is limited by the `maxDocuments` if no search is applied.
   */
  async onFilter() {
    this.grayOutHeader();
    const batchSize = this.settings.batchSize;
    const sleepBetweenBatches = this.settings.sleepBetweenBatches;
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = this.models[i];
      const rowUid = this.getUID(document2);
      let hide = this.getHideState(document2, void 0);
      this.logger.trace(`Document ${rowUid} is hidden by state: ${hide}`);
      this.logger.trace(`Visible rows: ${visibleRows}; Max shown Docs: ${this.settings.maxDocuments}`);
      if (visibleRows >= this.settings.maxDocuments) {
        hide = true;
      }
      this.logger.trace(`Document ${rowUid} is hidden by max counts: ${hide}`);
      if (hide) {
        rows.push({ rowUid, hidden: true });
      } else {
        visibleRows++;
        rows.push({ rowUid, hidden: false });
      }
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.logger.trace(`Batchsize reached. Change rows: ${rows.length}`);
        await this.table.changeShowHideStateRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
    this.normalizeHeader();
  }
  /**
   * Adds the documents to the table.
   * @param batchSize The batch size.
   * @param sleepBetweenBatches The sleep time between the batches.
   * @returns A promise which is resolved when the documents are added to the table.
   * @remarks - The documents are added to the table in batches.
   * - The batch size is defined in the `batchSize` parameter. Default is `settings.batchSize`.
   * - The sleep time between the batches is defined in the `sleepBetweenBatches` parameter. Default is `settings.sleepBetweenBatches`.
   */
  async addDocumentsToTable(batchSize = this.settings.batchSize, sleepBetweenBatches = this.settings.sleepBetweenBatches) {
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let rowPromise = void 0;
    if (documentsLength > 0) {
      rowPromise = this.generateTableRow(this.models[0]);
    } else {
      return;
    }
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = i + 1 < documentsLength ? this.models[i + 1] : null;
      const row = await rowPromise;
      rowPromise = document2 ? this.generateTableRow(document2) : void 0;
      if (row && !row.hidden) {
        if (visibleRows < this.settings.maxDocuments) {
          visibleRows++;
        } else {
          row.hidden = true;
        }
      }
      if (row)
        rows.push(row);
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.table.addRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
  }
  /**
   * Generates a table row for the given document.
   * @param documentModel The document to generate the table row for.
   * @returns The generated table row.
   */
  async generateTableRow(documentModel) {
    const rowClassList = [];
    const rowData = [];
    const rowUid = this.getUID(documentModel);
    const metadataLink = document.createDocumentFragment();
    rowData.push(metadataLink);
    DocumentComponents.createCellMetadatalink(
      metadataLink,
      this.component,
      documentModel
    );
    const date = document.createDocumentFragment();
    rowData.push(date);
    GeneralComponents.createCellDate(
      date,
      this.component,
      Lng.gt("DocumentDate"),
      this.global.settings.dateFormat,
      () => {
        var _a;
        return (_a = documentModel.data.date) != null ? _a : "na";
      },
      async (value) => documentModel.data.date = value
    );
    const fileLink = document.createDocumentFragment();
    rowData.push(fileLink);
    DocumentComponents.createCellFileLink(
      fileLink,
      this.component,
      documentModel
    );
    const senderRecipient = DocumentComponents.createCellSenderRecipient(
      documentModel,
      this.component,
      this.models
    );
    rowData.push(senderRecipient);
    const summaryRelatedFiles = document.createDocumentFragment();
    rowData.push(summaryRelatedFiles);
    DocumentComponents.createCellSummary(
      documentModel,
      this.component,
      summaryRelatedFiles
    );
    DocumentComponents.createRelatedFilesList(
      summaryRelatedFiles,
      this.component,
      documentModel,
      this.settings.noneDocSymbol,
      this.global.settings.dateFormatShort
    );
    const deliveryDate = document.createDocumentFragment();
    rowData.push(deliveryDate);
    GeneralComponents.createCellDate(
      deliveryDate,
      this.component,
      Lng.gt("DeliveryDate"),
      this.global.settings.dateFormat,
      () => {
        var _a;
        return (_a = documentModel.data.dateOfDelivery) != null ? _a : "na";
      },
      async (value) => documentModel.data.dateOfDelivery = value
    );
    const tags = document.createDocumentFragment();
    rowData.push(tags);
    DocumentComponents.createCellTags(
      tags,
      this.component,
      documentModel.getTags()
    );
    const hide = this.getHideState(documentModel, void 0);
    const row = {
      rowUid,
      rowData,
      rowClassList,
      hidden: hide
    };
    return row;
  }
  getHideState(document2, maxVisibleRows) {
    let searchResult = false;
    let maxRows = false;
    if (this.settings.search) {
      const text = document2.toString();
      searchResult = Search.applySearchLogic(this.settings.search, text);
    }
    if (maxVisibleRows && maxVisibleRows > 0) {
      const rowStats = this.table.getRowStats();
      maxRows = rowStats.visibleRows >= maxVisibleRows;
    }
    const hide = this.determineHideState(document2);
    if (searchResult && !hide) {
      return false;
    } else if (this.settings.search) {
      return true;
    } else if (!searchResult) {
      return maxRows || hide;
    }
    return hide;
  }
  /**
   * Determines if the document should be hidden.
   * @param document The document to check.
   * @returns If the document should be hidden returns `true`, else `false`.
   * @remarks - The document is hidden if the `filter` setting not includes the document type.
   */
  determineHideState(document2) {
    if (this.settings.filter.includes("Documents") && document2.data.hide !== true && document2.data.subType !== "Cluster") {
      return false;
    }
    if (this.settings.filter.includes("Cluster") && document2.data.subType === "Cluster") {
      return false;
    }
    if (this.settings.filter.includes("HideDocuments") && document2.data.hide === true) {
      return false;
    }
    return true;
  }
  /**
   * Builds the table.
   * @remarks - The table is saved in the `table` property.
   * - The table is appended to the `tableContainer`.
   * - The table has the CSS class `document-table`.
   * - The table has the headers from the `tableHeaders` property.
   */
  async buildTable() {
    this.table = new Table(this.tableHeaders, "document-table", void 0);
    this.tableContainer.appendChild(this.table.data.table);
  }
  redraw() {
    return super.redraw();
  }
  /**
   * Parses the settings given by the user per YAML in code block.
   * @remarks The settings are parsed and saved in the `settings` property.
   * @remarks Settings:
   * - `tags`: Can be `all`, `this` or a list of tags.
   * `this` means the tags of the current document.
   * - `maxDocuments`: The maximum number of documents to show on same time.
   * - `filter`: Must be an array. You can add the following values:
   * `Documents`, `HideDocuments` or `Cluster`. The values present the document types.
   * All values that are in the array are shown.
   */
  parseSettings() {
    this.processorSettings.options.forEach((option) => {
      var _a, _b;
      switch (option.label) {
        case "tags":
          if (option.value === "all") {
            this.settings.tags = [];
          } else if (option.value === "this") {
            const tags = (_b = (_a = this.processorSettings) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags;
            if (Array.isArray(tags)) {
              this.settings.tags.push(...tags);
            } else if (tags) {
              this.settings.tags.push(tags);
            }
          } else {
            this.settings.tags = option.value;
          }
          break;
        case "maxDocuments":
          this.settings.maxDocuments = option.value;
          break;
        case "filter":
          this.settings.filter = option.value;
          break;
        default:
          break;
      }
    });
  }
  /**
   * Returns the models for the table.
   * @returns The models for the table.
   * @remarks - The models are the documents.
   * - The documents are filtered by the `tags` setting. 
   * If tags are empty, all documents are returned, 
   * else only the documents with the tags are returned.
   */
  async getModels() {
    const templateFolder = this.global.settings.templateFolder;
    const allDocumentFiles = this.metadataCache.filter((file) => {
      var _a, _b;
      const defaultFilter = ((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) === "Metadata" && file.file.path !== this.processorSettings.source && !file.file.path.startsWith(templateFolder);
      if (this.settings.tags.length > 0) {
        const tagFilter = Helper.isTagIncluded(this.settings.tags, (_b = file.metadata.frontmatter) == null ? void 0 : _b.tags);
        return defaultFilter && tagFilter;
      }
      return defaultFilter;
    });
    const documents = allDocumentFiles.map((file) => new DocumentModel(file.file));
    return documents;
  }
  /**
   * Returns if the file tags are included in the setting tags.
   * @param fileTags The tags of the file.
   * @param settingTags The tags of the settings.
   * @returns If the file tags are included in the setting tags.
   * @remarks - If the file tags are an array, one tag must be included.
   * - If the file tags are a string, the string must be included.
   */
  isTagIncluded(fileTags, settingTags) {
    if (Array.isArray(fileTags)) {
      return fileTags.some((tag) => settingTags.includes(tag));
    } else {
      return settingTags.includes(fileTags);
    }
  }
};

// src/models/PrjTaskManagementModel.ts
var PrjTaskManagementModel = class extends BaseModel {
  constructor(file, ctor) {
    super(file, ctor, void 0);
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
  }
  toString() {
    var _a, _b, _c, _d, _e;
    let allText = (_a = this.data.title) != null ? _a : "";
    allText += (_b = this.data.description) != null ? _b : "";
    allText += (_c = this.data.status) != null ? _c : "";
    allText += (_d = this.data.due) != null ? _d : "";
    allText += (_e = this.data.tags) != null ? _e : "";
    return allText;
  }
  getCorospondingSymbol() {
    switch (this.data.type) {
      case "Topic":
        return this.global.settings.prjSettings.topicSymbol;
      case "Project":
        return this.global.settings.prjSettings.projectSymbol;
      case "Task":
        return this.global.settings.prjSettings.taskSymbol;
      default:
        return "x-circle";
    }
  }
  /**
   * Sorts the models by urgency descending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   * @see {@link statusToNumber}
   * @see {@link calculateUrgency}
   * @see {@link getLastHistoryDate}
   * @remarks The sorting is done as follows:
   * - If both are `done`, sort by last history entry
   * - If `a` or `b` is done, sort it lower
   * - Both are not done, sort by urgency
   * - Both have the same urgency, sort by status
   * - Both have the same status, sort by priority
   * - Fallback to sorting by last history entry
   * - Fallback to stop sorting
   */
  static sortModelsByUrgency(models) {
    models.sort((a, b) => {
      var _a, _b;
      const aDate = PrjTaskManagementModel.getLastHistoryDate(a);
      const bDate = PrjTaskManagementModel.getLastHistoryDate(b);
      if (a.data.status === "Done" && b.data.status === "Done") {
        if (aDate && bDate) {
          return bDate.getTime() - aDate.getTime();
        }
      }
      if (a.data.status === "Done") {
        return 1;
      }
      if (b.data.status === "Done") {
        return -1;
      }
      const aUrgency = PrjTaskManagementModel.calculateUrgency(a);
      const bUrgency = PrjTaskManagementModel.calculateUrgency(b);
      if (bUrgency !== aUrgency) {
        return bUrgency - aUrgency;
      }
      const aStatus = PrjTaskManagementModel.statusToNumber(a.data.status);
      const bStatus = PrjTaskManagementModel.statusToNumber(b.data.status);
      if (bStatus !== aStatus) {
        return bStatus - aStatus;
      }
      const aPrirority = (_a = a.data.priority) != null ? _a : 0;
      const bPrirority = (_b = b.data.priority) != null ? _b : 0;
      if (bPrirority !== aPrirority) {
        return bPrirority - aPrirority;
      }
      if (aDate && bDate) {
        return bDate.getTime() - aDate.getTime();
      }
      return 0;
    });
  }
  /**
   * Returns the number representation of the status.
   * @param status The status to convert.
   * @returns The number representation of the status.
   * @remarks The number representation is:
   * - `Active` = 3
   * - `Waiting` = 2
   * - `Later` = 1
   * - `Someday` = 0
   * - `undefined` = -1
   */
  static statusToNumber(status) {
    switch (status) {
      case "Active":
        return 3;
      case "Waiting":
        return 2;
      case "Later":
        return 1;
      case "Someday":
        return 0;
      default:
        return -1;
    }
  }
  getUrgency() {
    return PrjTaskManagementModel.calculateUrgency(this);
  }
  /**
   * Returns the tags of the model as an array of strings
   * @returns Array of strings containing the tags
   */
  getTags() {
    const tags = this.data.tags;
    let formattedTags = [];
    if (tags && typeof tags === "string") {
      formattedTags = [tags];
    } else if (Array.isArray(tags)) {
      formattedTags = [...tags];
    }
    return formattedTags;
  }
  /**
   * Calculates the urgency of the model.
   * @param model The model to calculate the urgency for.
   * @returns The urgency of the model.
   * @remarks The urgency is calculated as follows:
   * - No `status` or `status` is 'Done' = -2
   * - No `due` or `status` is 'Someday' = -1
   * - Due date is today or in the past = 3
   * - Due date is in the next 3 days = 2
   * - Due date is in the next 7 days = 1
   * - Due date is in more the future = 0
   */
  static calculateUrgency(model) {
    if (!model.data.status || model.data.status === "Done") {
      return -2;
    }
    if (!model.data.due || model.data.status === "Someday") {
      return -1;
    }
    const dueDate = new Date(model.data.due);
    dueDate.setHours(0, 0, 0, 0);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const differenceInDays = (dueDate.getTime() - today.getTime()) / (1e3 * 3600 * 24);
    let urgency = 0;
    if (differenceInDays <= 0) {
      urgency = 3;
    } else if (differenceInDays <= 3) {
      urgency = 2;
    } else if (differenceInDays <= 7) {
      urgency = 1;
    }
    return urgency;
  }
  /**
   * Returns the date of the last history entry.
   * @param model The model to get the last history entry date from.
   * @returns The date of the last history entry.
   */
  static getLastHistoryDate(model) {
    if (model.data.history && Array.isArray(model.data.history) && model.data.history.length > 0) {
      const history = model.data.history;
      const lastEntry = history[history.length - 1];
      return new Date(lastEntry.date);
    } else {
      return null;
    }
  }
};

// src/types/TopicData.ts
var TopicData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/TopicModel.ts
var TopicModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, TopicData);
  }
};

// src/types/ProjectData.ts
var ProjectData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/ProjectModel.ts
var ProjectModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, ProjectData);
  }
};

// src/types/TaskData.ts
var TaskData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/TaskModel.ts
var TaskModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, TaskData);
  }
};

// src/libs/BlockRenderComponents/InnerComponents/ProjectComponents.ts
var import_obsidian12 = require("obsidian");
var ProjectComponents = class {
  /**
   * Creates a title component.
   * @param container The container to append the title to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param onRead On read callback. Returns the title.
   * @param onWrite On write callback. Passes the new title.
   */
  static createTitle(container, component, path, onRead, onWrite) {
    new EditableDataView(container, component).addLink((link) => {
      link.setValue(onRead()).setTitle(Lng.gt("Title")).setPlaceholder(Lng.gt("Title")).setLinkType("file").setFormator((value) => {
        let title = document.createDocumentFragment();
        if (value === "") {
          (0, import_obsidian12.setIcon)(title, "paperclip");
        } else if (Helper.isPossiblyMarkdown(value)) {
          const div = document.createElement("div");
          import_obsidian12.MarkdownRenderer.render(Global.getInstance().app, value != null ? value : "", div, "", component);
          title.appendChild(div);
        } else {
          title = void 0;
        }
        return { href: `${path}`, text: `${value}`, html: title };
      }).enableEditability().onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      });
    });
  }
  /**
   * Creates a summary component.
   * @param container The container to append the summary to.
   * @param component The component to register the events to.
   * @param description The description to display.
   * @param onWrite On write callback. Passes the new description.
   */
  static createSummary(container, component, description, onWrite) {
    new EditableDataView(container, component).addText(
      (text) => text.setValue(description).setTitle(Lng.gt("Description")).setPlaceholder(Lng.gt("Description")).enableEditability().setRenderMarkdown().onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      })
    );
  }
  static createStatus(container, component, onRead, onWrite) {
    new EditableDataView(container, component).addDropdown((dropdown) => dropdown.setOptions([
      { value: "Active", text: Lng.gt("StatusActive") },
      { value: "Waiting", text: Lng.gt("StatusWaiting") },
      { value: "Later", text: Lng.gt("StatusLater") },
      { value: "Someday", text: Lng.gt("StatusSomeday") },
      { value: "Done", text: Lng.gt("StatusDone") }
    ]).setTitle(Lng.gt("Status")).setValue(onRead()).onSave(async (value) => {
      onWrite(value);
    }).enableEditability().setFormator(
      (value) => {
        const status = value;
        let iconString;
        switch (status) {
          case "Active":
            iconString = "\u26A1";
            break;
          case "Waiting":
            iconString = "\u23F3";
            break;
          case "Later":
            iconString = "\u{1F51C}";
            break;
          case "Someday":
            iconString = "\u{1F4C6}";
            break;
          case "Done":
            iconString = "\u2714\uFE0F";
            break;
          default:
            iconString = "\u26A1";
            break;
        }
        return { text: `${iconString}`, html: void 0 };
      }
    ));
  }
  /**
   * Creates a priority component.
   * @param container The container to append the priority to.
   * @param component The component to register the events to.
   * @param onRead On read callback. Returns the priority.
   * @param onWrite On write callback. Passes the new priority.
   */
  static createPriority(container, component, onRead, onWrite) {
    new EditableDataView(container, component).addDropdown((dropdown) => dropdown.setOptions([
      { value: "3", text: Lng.gt("HighPriority") },
      { value: "2", text: Lng.gt("MediumPriority") },
      { value: "1", text: Lng.gt("LowPriority") },
      { value: "0", text: Lng.gt("NoPriority") }
    ]).setTitle(Lng.gt("PriorityText")).setValue(onRead()).onSave(async (value) => {
      onWrite(value);
    }).enableEditability().setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        let iconString;
        switch (value) {
          case "3":
            iconString = "signal";
            break;
          case "2":
            iconString = "signal-medium";
            break;
          case "1":
            iconString = "signal-low";
            break;
          case "0":
            iconString = "signal-zero";
            break;
          default:
            iconString = "signal-zero";
            break;
        }
        (0, import_obsidian12.setIcon)(icon, iconString);
        return { text: `${value}`, html: icon };
      }
    ));
  }
  /**
   * Creates a link to the file at `path` with the `corospondingSymbol` as icon.
   * @param container The container to append the link to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param type The type of the file.
   * @param corospondingSymbol The corosponding symbol for the file type.
   */
  static createMetadataLink(container, component, path, type2, corospondingSymbol) {
    new EditableDataView(container, component).addLink((link) => link.setValue(path).setTitle(Lng.gt(type2 != null ? type2 : "File")).setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        const iconString = corospondingSymbol;
        (0, import_obsidian12.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
  /**
   * Creates a span with the to `urgency` corresponding urgency symbol.
   * @param container The container to append the span to.
   * @param urgency The urgency to get the symbol for. (3 to -2)
   * @see {@link PrjTaskManagementModel.calculateUrgency}
   * @see {@link UrgencySymbols}
   */
  static createTraficLight(container, urgency) {
    const traficLightSpan = document.createElement("span");
    container.appendChild(traficLightSpan);
    let iconString;
    switch (urgency) {
      case 3:
        iconString = "\u{1F534}";
        break;
      case 2:
        iconString = "\u{1F7E0}";
        break;
      case 1:
        iconString = "\u{1F7E1}";
        break;
      case 0:
        iconString = "\u{1F7E2}";
        break;
      case -1:
        iconString = "\u{1F7E2}";
        break;
      case -2:
        iconString = "\u{1F535}";
        break;
      default:
        iconString = "\u{1F534}";
        break;
    }
    traficLightSpan.textContent = iconString;
  }
};

// src/libs/BlockRenderComponents/ProjectBlockRenderComponent.ts
var ProjectBlockRenderComponent = class extends TableBlockRenderComponent {
  constructor(settings) {
    super(settings);
    this.settings = {
      tags: [],
      topicSymbol: this.global.settings.prjSettings.topicSymbol,
      projectSymbol: this.global.settings.prjSettings.projectSymbol,
      taskSymbol: this.global.settings.prjSettings.taskSymbol,
      otherSymbol: "diamond",
      filter: ["Topic", "Project", "Task"],
      maxDocuments: this.global.settings.defaultMaxShow,
      search: void 0,
      batchSize: 8,
      sleepBetweenBatches: 10
    };
    /**
     * The table headers.
     * @remarks The table headers are used to create the table.
     * 
     */
    this.tableHeaders = [
      { text: Lng.gt("DocumentType"), headerClass: [], columnClass: ["dont-decorate-link", "font-medium"] },
      { text: Lng.gt("TraficLight"), headerClass: [], columnClass: [] },
      { text: Lng.gt("Description"), headerClass: [], columnClass: ["dont-decorate-link", "link-weight-bold"] },
      { text: Lng.gt("Priority"), headerClass: [], columnClass: [] },
      { text: Lng.gt("DueDate"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Status"), headerClass: [], columnClass: [] },
      { text: Lng.gt("Tags"), headerClass: [], columnClass: ["tags"] }
    ];
    this.parseSettings();
  }
  build() {
    return super.build();
  }
  async draw() {
    const startTime = Date.now();
    const getModelsPromise = this.getModels();
    await super.draw();
    await this.buildTable();
    await this.buildHeader();
    this.grayOutHeader();
    this.models = await getModelsPromise;
    PrjTaskManagementModel.sortModelsByUrgency(this.models);
    await this.addDocumentsToTable();
    this.normalizeHeader();
    const endTime = Date.now();
    this.logger.debug(`Redraw (for ${this.models.length} Models) runs for ${endTime - startTime}ms`);
  }
  async buildTable() {
    this.table = new Table(this.tableHeaders, "project-table", void 0);
    this.tableContainer.appendChild(this.table.data.table);
  }
  async buildHeader() {
    const headerFilterButtons = document.createElement("div");
    this.headerContainer.appendChild(headerFilterButtons);
    headerFilterButtons.classList.add("header-item");
    headerFilterButtons.classList.add("filter-symbols");
    const filterLabelContainer = document.createElement("div");
    headerFilterButtons.appendChild(filterLabelContainer);
    const filterLabel = document.createElement("span");
    filterLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-symbol");
    filterLabel.textContent = Lng.gt("Filter");
    const topicFilterButton = FilterButton.create(
      this.component,
      "Topic",
      this.settings.topicSymbol,
      this.settings.filter.includes("Topic"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(topicFilterButton);
    const projectFilterButton = FilterButton.create(
      this.component,
      "Project",
      this.settings.projectSymbol,
      this.settings.filter.includes("Project"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(projectFilterButton);
    const taskFilterButton = FilterButton.create(
      this.component,
      "Task",
      this.settings.taskSymbol,
      this.settings.filter.includes("Task"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(taskFilterButton);
    const doneFilterButton = FilterButton.create(
      this.component,
      "Done",
      "check-square",
      this.settings.filter.includes("Done"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(doneFilterButton);
    const maxDocuments = MaxShownModelsInput.create(
      this.component,
      this.settings.maxDocuments,
      this.global.settings.defaultMaxShow,
      this.onMaxDocumentsChange.bind(this)
    );
    headerFilterButtons.appendChild(maxDocuments);
    const searchBox = SearchInput.create(
      this.component,
      this.onSearch.bind(this)
    );
    headerFilterButtons.appendChild(searchBox);
  }
  async addDocumentsToTable(batchSize = this.settings.batchSize, sleepBetweenBatches = this.settings.sleepBetweenBatches) {
    let sleepPromise = Promise.resolve();
    const modelsLength = this.models.length;
    const rows = [];
    let rowPromise = void 0;
    if (modelsLength > 0) {
      rowPromise = this.generateTableRow(this.models[0]);
    } else {
      return;
    }
    let visibleRows = 0;
    for (let i = 0; i < modelsLength; i++) {
      const model = i + 1 < modelsLength ? this.models[i + 1] : null;
      const row = await rowPromise;
      rowPromise = model ? this.generateTableRow(model) : void 0;
      if (row && !row.hidden) {
        if (visibleRows < this.settings.maxDocuments) {
          visibleRows++;
        } else {
          row.hidden = true;
        }
      }
      if (row)
        rows.push(row);
      if (i !== 0 && i % batchSize === 0 || i === modelsLength - 1) {
        await sleepPromise;
        this.table.addRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
  }
  async generateTableRow(model) {
    var _a;
    const rowClassList = [];
    const rowData = [];
    const rowUid = this.getUID(model);
    const metadataLink = document.createDocumentFragment();
    rowData.push(metadataLink);
    GeneralComponents.createMetadataLink(
      metadataLink,
      this.component,
      model.file.path,
      model.data.type,
      model.getCorospondingSymbol()
    );
    const traficLight = document.createDocumentFragment();
    rowData.push(traficLight);
    ProjectComponents.createTraficLight(traficLight, model.getUrgency());
    const titleAndSummary = document.createDocumentFragment();
    rowData.push(titleAndSummary);
    ProjectComponents.createTitle(
      titleAndSummary,
      this.component,
      model.file.path,
      () => {
        var _a2;
        return (_a2 = model.data.title) != null ? _a2 : "";
      },
      async (value) => model.data.title = value
    );
    const lineBreak = document.createElement("br");
    titleAndSummary.appendChild(lineBreak);
    ProjectComponents.createSummary(
      titleAndSummary,
      this.component,
      (_a = model.data.description) != null ? _a : "",
      (value) => model.data.description = value
    );
    const priority = document.createDocumentFragment();
    rowData.push(priority);
    ProjectComponents.createPriority(
      priority,
      this.component,
      () => {
        var _a2, _b;
        return (_b = (_a2 = model.data.priority) == null ? void 0 : _a2.toString()) != null ? _b : "0";
      },
      async (value) => model.data.priority = value
    );
    const dueDate = document.createDocumentFragment();
    rowData.push(dueDate);
    GeneralComponents.createCellDate(
      dueDate,
      this.component,
      Lng.gt("DueDate"),
      this.global.settings.dateFormat,
      () => {
        var _a2;
        return (_a2 = model.data.due) != null ? _a2 : "na";
      },
      async (value) => model.data.due = value
    );
    const status = document.createDocumentFragment();
    rowData.push(status);
    ProjectComponents.createStatus(
      status,
      this.component,
      () => {
        var _a2;
        return (_a2 = model.data.status) != null ? _a2 : "Active";
      },
      async (value) => model.data.status = value
    );
    const tags = document.createDocumentFragment();
    rowData.push(tags);
    DocumentComponents.createCellTags(
      tags,
      this.component,
      model.getTags()
    );
    const hide = this.getHideState(model, this.settings.maxDocuments);
    const row = {
      rowUid,
      rowData,
      rowClassList,
      hidden: hide
    };
    return row;
  }
  async onFilterButton(type2, status) {
    if (this.settings.filter.includes(type2)) {
      this.settings.filter = this.settings.filter.filter((v) => v !== type2);
    } else {
      this.settings.filter.push(type2);
    }
    this.onFilter();
  }
  async onMaxDocumentsChange(maxDocuments) {
    this.settings.maxDocuments = maxDocuments;
    this.onFilter();
    return void 0;
  }
  async onSearch(search, key) {
    if (key === "Enter") {
      if (search !== "") {
        this.settings.search = Search.parseSearchText(search);
        this.onFilter();
      } else {
        this.settings.search = void 0;
        this.onFilter();
      }
    } else if (key === "Escape") {
      this.settings.search = void 0;
      this.onFilter();
      return "";
    }
    return search;
  }
  async onFilter() {
    this.grayOutHeader();
    const batchSize = this.settings.batchSize;
    const sleepBetweenBatches = this.settings.sleepBetweenBatches;
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = this.models[i];
      const rowUid = this.getUID(document2);
      let hide = this.getHideState(document2, void 0);
      if (visibleRows >= this.settings.maxDocuments) {
        hide = true;
      }
      if (hide) {
        rows.push({ rowUid, hidden: true });
      } else {
        visibleRows++;
        rows.push({ rowUid, hidden: false });
      }
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.table.changeShowHideStateRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
    this.normalizeHeader();
  }
  getHideState(model, maxVisibleRows) {
    let searchResult = false;
    let maxRows = false;
    if (!this.settings.filter.includes("Done") && model.data.status === "Done") {
      return true;
    }
    if (this.settings.search) {
      const text = model.toString();
      searchResult = Search.applySearchLogic(this.settings.search, text);
    }
    if (maxVisibleRows && maxVisibleRows > 0) {
      const rowStats = this.table.getRowStats();
      maxRows = rowStats.visibleRows >= maxVisibleRows;
    }
    const hide = this.determineHideState(model);
    if (searchResult && !hide) {
      return false;
    } else if (this.settings.search) {
      return true;
    } else if (!searchResult) {
      return maxRows || hide;
    }
    return hide;
  }
  determineHideState(model) {
    if (this.settings.filter.includes("Topic") && model.data.type === "Topic") {
      return false;
    }
    if (this.settings.filter.includes("Project") && model.data.type === "Project") {
      return false;
    }
    if (this.settings.filter.includes("Task") && model.data.type === "Task") {
      return false;
    }
    return true;
  }
  parseSettings() {
    this.processorSettings.options.forEach((option) => {
      var _a, _b;
      switch (option.label) {
        case "tags":
          if (option.value === "all") {
            this.settings.tags = [];
          } else if (option.value === "this") {
            const tags = (_b = (_a = this.processorSettings) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags;
            if (Array.isArray(tags)) {
              this.settings.tags.push(...tags);
            } else if (tags) {
              this.settings.tags.push(tags);
            }
          } else {
            this.settings.tags = option.value;
          }
          break;
        case "maxDocuments":
          this.settings.maxDocuments = option.value;
          break;
        case "filter":
          this.settings.filter = option.value;
          break;
        default:
          break;
      }
    });
  }
  async getModels() {
    const templateFolder = this.global.settings.templateFolder;
    const allModelFiles = this.metadataCache.filter((file) => {
      var _a, _b, _c, _d;
      const defaultFilter = (((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) === "Topic" || ((_b = file.metadata.frontmatter) == null ? void 0 : _b.type) === "Project" || ((_c = file.metadata.frontmatter) == null ? void 0 : _c.type) === "Task") && file.file.path !== this.processorSettings.source && !file.file.path.startsWith(templateFolder);
      if (this.settings.tags.length > 0) {
        const tagFilter = Helper.isTagIncluded(this.settings.tags, (_d = file.metadata.frontmatter) == null ? void 0 : _d.tags);
        return defaultFilter && tagFilter;
      }
      return defaultFilter;
    });
    const models = [];
    allModelFiles.forEach((file) => {
      var _a;
      switch ((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) {
        case "Topic":
          models.push(new TopicModel(file.file));
          break;
        case "Project":
          models.push(new ProjectModel(file.file));
          break;
        case "Task":
          models.push(new TaskModel(file.file));
          break;
        default:
          break;
      }
    });
    return models;
  }
};

// src/libs/MarkdownBlockProcessor.ts
var MarkdownBlockProcessor = class {
  static async parseSource(source, el, ctx) {
    var _a;
    const startTime = Date.now();
    const parent = el.closest("div.cm-preview-code-block.cm-embed-block.markdown-rendered");
    if (parent) {
      parent.classList.remove("cm-embed-block");
      parent.addClass("prj-block");
    }
    const global2 = Global.getInstance();
    await global2.metadataCache.waitForCacheReady();
    const cache = global2.metadataCache.Cache;
    const logger = global2.logger;
    const cmp = new import_obsidian13.MarkdownRenderChild(el);
    ctx.addChild(cmp);
    cmp.load();
    const blockContainer = document.createElement("div");
    el.append(blockContainer);
    blockContainer.classList.add("prj-block-container");
    const setting = load(source);
    setting.source = ctx.sourcePath;
    setting.frontmatter = (_a = cache.filter((file) => file.file.path === ctx.sourcePath).first()) == null ? void 0 : _a.metadata.frontmatter;
    setting.container = blockContainer;
    setting.ctx = ctx;
    if (setting) {
      switch (setting.type) {
        case "Documents":
          const documentBlock = new DocumentBlockRenderComponent(setting);
          await documentBlock.build();
          break;
        case "Tasks":
        case "Projects":
        case "Topics":
          const projectBlock = new ProjectBlockRenderComponent(setting);
          await projectBlock.build();
          break;
        case "Debug":
          console.log("Debug Mode");
          console.log(`Settings: ${setting}`);
          break;
        default:
          break;
      }
      const endTime = Date.now();
      logger.debug(`MarkdownBlockProcessor runs for ${endTime - startTime}ms`);
    }
  }
};

// src/classes/SettingsTab.ts
var import_obsidian14 = require("obsidian");
var SettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian14.Setting(containerEl).setName("Log Level").setDesc("The log level to use").addDropdown((dropdown) => dropdown.addOptions({
      "none": "none",
      "trace": "trace",
      "debug": "debug",
      "info": "info",
      "warn": "warn",
      "error": "error"
    }).setValue(this.plugin.settings.logLevel).onChange(async (value) => {
      this.plugin.settings.logLevel = value;
      Global.getInstance().logger.setLogLevel(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Performance Mode (only Mobile)").setDesc("The performance of the plugin is affected by this setting. If disabled, the editability of the blocks is disabled. No effect on Desktop!").addToggle((toggle) => toggle.setValue(this.plugin.settings.mobile).onChange(async (value) => {
      this.plugin.settings.mobile = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("Localisation");
    new import_obsidian14.Setting(containerEl).setName("Language").setDesc("The language to use").addText((text) => text.setPlaceholder("en | de").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Date Format").setDesc("The Date format to use").addText((text) => text.setPlaceholder("DD.MM.YYYY").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Short date format").setDesc("The short Date format to use").addText((text) => text.setPlaceholder("DD.MM.YY").setValue(this.plugin.settings.dateFormatShort).onChange(async (value) => {
      this.plugin.settings.dateFormatShort = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Base Tag").setDesc("The Base Tag for all Elements").addText((text) => text.setPlaceholder("#YourBaseTag").setValue(this.plugin.settings.baseTag).onChange(async (value) => {
      this.plugin.settings.baseTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Template Folder").setDesc("The Folder where all Templates are stored").addText((text) => text.setPlaceholder("YourTemplateFolder").setValue(this.plugin.settings.templateFolder).onChange(async (value) => {
      this.plugin.settings.templateFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("User Information");
    new import_obsidian14.Setting(containerEl).setName("User: Name").setDesc("Your name").addText((text) => text.setPlaceholder("Your name").setValue(this.plugin.settings.user.name).onChange(async (value) => {
      this.plugin.settings.user.name = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Short name").setDesc("Your name short name").addText((text) => text.setPlaceholder("Your name shortened").setValue(this.plugin.settings.user.shortName).onChange(async (value) => {
      this.plugin.settings.user.shortName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Email").setDesc("Your E-Mail adress").addText((text) => text.setPlaceholder("Your email").setValue(this.plugin.settings.user.email).onChange(async (value) => {
      this.plugin.settings.user.email = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Street").setDesc("Your street").addText((text) => text.setPlaceholder("Your street").setValue(this.plugin.settings.user.street).onChange(async (value) => {
      this.plugin.settings.user.street = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: City").setDesc("Your city").addText((text) => text.setPlaceholder("Your city").setValue(this.plugin.settings.user.city).onChange(async (value) => {
      this.plugin.settings.user.city = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Zip Code").setDesc("Your zip code").addText((text) => text.setPlaceholder("Your zip").setValue(this.plugin.settings.user.zip).onChange(async (value) => {
      this.plugin.settings.user.zip = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Country").setDesc("Your country").addText((text) => text.setPlaceholder("Your country").setValue(this.plugin.settings.user.country).onChange(async (value) => {
      this.plugin.settings.user.country = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("Document Settings");
    new import_obsidian14.Setting(containerEl).setName("Default Max Show").setDesc("The default max show for Table Entrys").addText((text) => text.setPlaceholder("200").setValue(this.plugin.settings.defaultMaxShow.toString()).onChange(async (value) => {
      this.plugin.settings.defaultMaxShow = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Document Symbol").setDesc("The Symbol for regular Documents").addText((text) => text.setPlaceholder("file-text").setValue(this.plugin.settings.documentSettings.symbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.symbol = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Hide Symbol").setDesc("The Symbol for hidden Documents").addText((text) => text.setPlaceholder("file-minus-2").setValue(this.plugin.settings.documentSettings.hideSymbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.hideSymbol = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Cluster Symbol").setDesc("The Symbol for Cluster Documents").addText((text) => text.setPlaceholder("library").setValue(this.plugin.settings.documentSettings.clusterSymbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.clusterSymbol = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types/PrjSettings.ts
var DEFAULT_SETTINGS = {
  logLevel: "none",
  mobile: false,
  language: "en",
  dateFormat: "DD.MM.YYYY",
  dateFormatShort: "DD.MM.YY",
  user: {
    "name": "",
    "shortName": "",
    "email": "",
    "street": "",
    "city": "",
    "zip": "",
    "country": ""
  },
  "defaultMaxShow": 200,
  "batchSizeShow": 25,
  documentSettings: {
    "symbol": "file-text",
    "hideSymbol": "file-minus-2",
    "clusterSymbol": "library"
  },
  prjSettings: {
    "topicSymbol": "album",
    "projectSymbol": "layout-list",
    "taskSymbol": "clipboard"
  },
  baseTag: "PRJ",
  templateFolder: "Vorlagen/"
};

// src/libs/ContextMenus/GetMetadata.ts
var import_obsidian15 = require("obsidian");
var GetMetadata = class {
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.plugin = Global.getInstance().plugin;
    this.metadataCache = Global.getInstance().metadataCache.Cache;
    this.eventsRegistered = false;
    this.bindContextMenu = this.onContextMenu.bind(this);
    this.logger.debug("Initializing GetMetadata");
    this.registerEvents();
    this.registerCommands();
  }
  static getInstance() {
    if (!GetMetadata.instance) {
      GetMetadata.instance = new GetMetadata();
    }
    return GetMetadata.instance;
  }
  /**
   * Deconstructs the 'GetMetadata' events
   */
  static deconstructor() {
    if (this.instance && this.instance.eventsRegistered) {
      this.instance.logger.trace("Deconstructing 'GetMetadata' events");
      this.instance.app.workspace.off("file-menu", this.instance.bindContextMenu);
      this.instance.eventsRegistered = false;
    } else {
      this.instance.logger.trace("No 'GetMetadata' events to deconstruct");
    }
  }
  /**
   * Registers the 'GetMetadata' events
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.logger.trace("Registering 'GetMetadata' events");
      this.app.workspace.on("file-menu", this.bindContextMenu);
      this.eventsRegistered = true;
    }
  }
  /**
   * Registers the 'GetMetadata' commands
   */
  registerCommands() {
    this.logger.trace("Registering 'GetMetadata' commands");
    this.plugin.addCommand({
      id: "get-metadata-file",
      name: Lng.gt("ShowMetadataFile"),
      callback: () => {
        GetMetadata.getInstance().invoke();
      }
    });
  }
  /**
   * Adds the 'GetMetadata' context menu item
   * @param menu The context menu
   * @param file The file to add the context menu item to
   */
  onContextMenu(menu, file) {
    if (!(file instanceof import_obsidian15.TFile) || !file.path.endsWith(".pdf")) {
      return;
    }
    const metadataFile = this.getCorrespondingMetadataFile(file);
    if (!metadataFile) {
      return;
    }
    const document2 = new DocumentModel(metadataFile.file);
    if (metadataFile) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(Lng.gt("ShowMetadataFile")).setIcon(document2.getCorospondingSymbol()).onClick(
          async () => {
            await this.openMetadataFile(document2.file);
          }
        );
      });
    }
  }
  /**
   * Returns the metadata file for the given document (e.g. pdf) file
   * @param file The document file
   * @returns The metadata file or undefined if not found
   */
  getCorrespondingMetadataFile(file) {
    return this.metadataCache.find((metadata) => {
      var _a, _b;
      const type2 = (_a = metadata.metadata.frontmatter) == null ? void 0 : _a.type;
      const fileLink = (_b = metadata.metadata.frontmatter) == null ? void 0 : _b.file;
      if (type2 && fileLink && type2 === "Metadata") {
        return fileLink.contains(file.name);
      }
    });
  }
  /**
   * Opens the metadata file for the active (e.g. pdf) file
   */
  async invoke() {
    const workspace = this.app.workspace;
    const activeFile = workspace.getActiveFile();
    if (!activeFile || !(activeFile instanceof import_obsidian15.TFile) || !activeFile.path.endsWith(".pdf")) {
      this.logger.warn("No active pdf file found.");
      return;
    }
    const metadataFile = this.getCorrespondingMetadataFile(activeFile);
    if (!metadataFile) {
      this.logger.warn("No metadata file to the active pdf file found.");
      return;
    }
    const document2 = new DocumentModel(metadataFile.file);
    await this.openMetadataFile(document2.file);
  }
  async openMetadataFile(file) {
    this.logger.trace(`Opening metadata file for ${file.name}`);
    const workspace = this.app.workspace;
    const newLeaf = workspace.getLeaf(true);
    await newLeaf.openFile(file);
    const view = newLeaf.getViewState();
    view.state.mode = "preview";
    newLeaf.setViewState(view);
  }
};

// src/main.ts
var Prj = class extends import_obsidian16.Plugin {
  async onload() {
    console.log("Loading plugin 'PRJ'");
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    if (this.app.workspace.layoutReady) {
      await this.onLayoutReady();
    } else {
      this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    }
  }
  async onLayoutReady() {
    console.log("Layout ready");
    new Global(this, this.app, this.settings);
    await Global.getInstance().awaitCacheInitialization();
    this.registerMarkdownCodeBlockProcessor("prj", MarkdownBlockProcessor.parseSource);
    this.app.workspace.updateOptions();
    GetMetadata.getInstance();
  }
  onunload() {
    console.log("Unloading plugin 'PRJ'");
    GetMetadata.deconstructor();
    Global.deconstructor();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/

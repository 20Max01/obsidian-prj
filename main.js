/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof require === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Prj
});
module.exports = __toCommonJS(main_exports);
var import_obsidian16 = require("obsidian");

// src/libs/MarkdownBlockProcessor.ts
var import_obsidian13 = require("obsidian");

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/libs/FileCache.ts
var import_obsidian = require("obsidian");
var FileCache = class {
  /**
   * Creates a new FileCache instance
   * @constructor
   */
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.fileCachePromise = null;
    this.fileCache = null;
    this.duplicateNames = null;
    this.fileCacheReady = false;
    this.eventsRegistered = false;
    if (!this.fileCache) {
      this.buildFileCache().then(() => {
        this.logger.debug("File Cache built");
      });
    }
    this.createEventHandler = this.createEventHandler.bind(this);
    this.renameEventHandler = this.renameEventHandler.bind(this);
    this.deleteEventHandler = this.deleteEventHandler.bind(this);
    this.registerEvents();
  }
  /**
   * Returns the FileCache instance if it exists, otherwise creates a new instance
   * @returns The FileCache instance
   */
  static getInstance() {
    if (!FileCache.instance) {
      FileCache.instance = new FileCache();
    }
    return FileCache.instance;
  }
  /**
   * Deconstructs the FileCache instance
   * unregisters all events
   */
  static deconstructor() {
    if (!FileCache.instance) {
      Global.getInstance().logger.error("FileCache instance not loaded");
      return;
    }
    const instance = FileCache.instance;
    if (instance.eventsRegistered) {
      instance.app.vault.off("rename", instance.renameEventHandler);
      instance.app.vault.off("delete", instance.deleteEventHandler);
      instance.app.vault.off("create", instance.createEventHandler);
      instance.eventsRegistered = false;
      Global.getInstance().logger.debug("File cache events unregistered");
      return;
    }
    Global.getInstance().logger.debug("File cache events not registered");
  }
  /**
   * Wait for the file cache to be ready
   * @returns {Promise<void>} Promise that resolves when the file cache is ready
   * @description This method returns a promise that resolves when the file cache is ready.
   */
  async waitForCacheReady() {
    while (!this.fileCacheReady) {
      await new Promise((resolve) => setTimeout(resolve, 5));
    }
  }
  /**
   * Builds the file cache
   * @returns Promise that resolves when the file cache is built
   * @private
   */
  async buildFileCache() {
    const startTime = Date.now();
    const allFiles = this.app.vault.getFiles();
    this.fileCache = /* @__PURE__ */ new Map();
    this.duplicateNames = /* @__PURE__ */ new Map();
    for (const file of allFiles) {
      this.addEntry(file);
    }
    this.fileCacheReady = true;
    const endTime = Date.now();
    this.logger.debug(`File cache for ${allFiles.length} files built in ${endTime - startTime}ms`);
  }
  /**
   * Updates the file cache with the new file
   * @param file The file to add to the cache
   * @returns True if the file was added to the cache, false otherwise
   * @private
   */
  addEntry(file) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    let state = true;
    const existingFile = this.fileCache.get(file.name);
    if (existingFile === void 0) {
      this.fileCache.set(file.name, file);
    } else if (existingFile === null) {
      state && (state = this.addDuplicateEntry([file]));
    } else {
      state && (state = this.addDuplicateEntry([existingFile, file]));
      this.fileCache.set(file.name, null);
    }
    return state;
  }
  /**
   * Updates the duplicate cache with the new file
   * @param file The files to add to the cache
   * @returns True if the file was added to the cache, false otherwise
   * @private
   */
  addDuplicateEntry(file) {
    var _a;
    const fileName = (_a = file.first()) == null ? void 0 : _a.name;
    if (!fileName) {
      this.logger.error("File name not available");
      return false;
    }
    if (!this.duplicateNames) {
      this.logger.error("Duplicate cache not available");
      return false;
    }
    const duplicateEntry = this.duplicateNames.get(fileName);
    if (duplicateEntry) {
      file.forEach((f) => duplicateEntry.push(f));
    } else {
      this.duplicateNames.set(fileName, file);
    }
    return true;
  }
  /**
   * Removes the file from the duplicate cache
   * @param file The file to remove from the cache
   * @param oldPath The old path of the file
   * @returns True if the file was removed from the cache, false otherwise
   * @private
   */
  removeDuplicateEntry(file, oldPath = null) {
    if (!this.duplicateNames) {
      this.logger.error("Duplicate cache not available");
      return false;
    }
    const duplicateEntry = this.duplicateNames.get(file.name);
    if (!duplicateEntry) {
      this.logger.error("File ${file.name} not found in duplicate cache");
      return false;
    }
    const path = oldPath != null ? oldPath : file.path;
    const index = duplicateEntry.findIndex((f) => f.path === path);
    if (index > -1) {
      duplicateEntry.splice(index, 1);
    } else {
      this.logger.error(`File ${file.name} not found in duplicate cache`);
      return false;
    }
    return true;
  }
  /**
   * Removes the file from the file cache
   * @param file The file to remove from the cache
   * @returns True if the file was removed from the cache, false otherwise
   * @private
   */
  removeEntry(file) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    let state = true;
    const existingFile = this.fileCache.get(file.name);
    if (existingFile) {
      this.fileCache.delete(file.name);
    } else if (existingFile === void 0) {
      this.logger.warn(`File ${file.name} not found in cache`);
      return false;
    } else if (existingFile === null) {
      state && (state = this.removeDuplicateEntry(file));
    }
    return state;
  }
  /**
   * Renames the file in the file cache
   * @param file The file to rename
   * @param oldPath The old path of the file
   * @returns True if the file was renamed in the cache, false otherwise
   * @private
   */
  renameEntry(file, oldPath) {
    if (!this.fileCache) {
      this.logger.error("File cache not available");
      return false;
    }
    const oldFileName = this.getFileNameFromPath(oldPath);
    if (!oldFileName) {
      this.logger.error("Old file name not available");
      return false;
    }
    const existingFile = this.fileCache.get(oldFileName);
    let state = true;
    if (existingFile) {
      this.fileCache.delete(oldFileName);
      state && (state = this.addEntry(file));
    } else if (existingFile === void 0) {
      this.logger.warn(`File ${oldFileName} not found in cache`);
      state && (state = this.addEntry(file));
    } else if (existingFile === null) {
      state && (state = this.removeDuplicateEntry(file, oldPath));
      state && (state = this.addDuplicateEntry([file]));
    }
    return state;
  }
  /**
   * Event handler for the create event
   * @param file The file to create in the file cache
   * @private
   */
  createEventHandler(file) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      state && (state = this.addEntry(file));
    }
    if (state) {
      this.logger.debug(`File ${file.name} create in file cache event handler success`);
    } else {
      this.logger.error(`Error creating file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Event handler for the rename event
   * @param file The file to rename in the file cache
   * @param oldPath The old path of the file
   * @private
   */
  renameEventHandler(file, oldPath) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      const oldFileName = oldPath.split("/").last();
      if (!oldFileName) {
        this.logger.error("Cannot extract old file name from the path");
        return;
      }
      state && (state = this.renameEntry(file, oldFileName));
    }
    if (state) {
      this.logger.debug(`File ${file.name} renamed in file cache event handler success`);
    } else {
      this.logger.error(`Error renaming file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Event handler for the delete event
   * @param file The file to delete in the file cache
   * @private
   */
  deleteEventHandler(file) {
    let state = true;
    if (file instanceof import_obsidian.TFile) {
      state && (state = this.removeEntry(file));
    }
    if (state) {
      this.logger.debug(`File ${file.name} delete in file cache event handler success`);
    } else {
      this.logger.error(`Error deleting file ${file.name} in file cache event handler`);
    }
  }
  /**
   * Registers the events for the file cache
   * @private
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.app.vault.on("rename", this.renameEventHandler);
      this.app.vault.on("delete", this.deleteEventHandler);
      this.app.vault.on("create", this.createEventHandler);
      this.eventsRegistered = true;
      this.logger.debug("File cache events registered");
    }
  }
  /**
   * Returns the file name from the file path
   * @param filePath The file path to extract the file name from
   * @returns The file name
   * @private
   */
  getFileNameFromPath(filePath) {
    const oldFileName = filePath.split("/").last();
    if (!oldFileName) {
      this.logger.error("Cannot extract old file name from the path");
      return;
    }
    return oldFileName;
  }
  /**
   * Returns the file from the file cache
   * @param fileName The name of the file to find
   * @returns The file/s if found, undefined otherwise
   */
  findFileByName(fileName) {
    var _a, _b;
    const foundFile = (_a = this.fileCache) == null ? void 0 : _a.get(fileName);
    if (foundFile) {
      return foundFile;
    } else if (foundFile === null) {
      const duplicateEntry = (_b = this.duplicateNames) == null ? void 0 : _b.get(fileName);
      if (!duplicateEntry) {
        this.logger.error(`File ${fileName} not found in duplicate cache`);
        return void 0;
      }
      return duplicateEntry;
    } else {
      return void 0;
    }
  }
  /**
   * Returns the file from the file cache
   * @param filePath The path of the file to find
   * @returns The file/s if found, undefined otherwise
   */
  findFileByPath(filePath) {
    const fileName = this.getFileNameFromPath(filePath);
    if (!fileName) {
      this.logger.error("File name not available");
      return void 0;
    }
    return this.findFileByName(fileName);
  }
};

// src/libs/MetadataCache.ts
var MetadataCache = class {
  /**
   * Constructor for the MetadataCache class
   * @description This constructor is private because the MetadataCache class is a singleton. Use the getInstance() method to get the singleton instance.
   */
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.metadataCachePromise = null;
    this.metadataCache = null;
    this.metadataCacheReady = false;
    this.eventsRegistered = false;
    this.changedEventHandler = this.changedEventHandler.bind(this);
    this.renameEventHandler = this.renameEventHandler.bind(this);
    this.deleteEventHandler = this.deleteEventHandler.bind(this);
    if (!this.metadataCache) {
      this.buildMetadataCache().then(() => {
        this.logger.debug("Metadata cache built");
        this.registerEvents();
      });
    }
  }
  /**
   * Get the metadata cache
   * @returns {FileMetadata[]} Array of FileMetadata objects
   * @description This method returns the metadata cache as an array of FileMetadata objects. The FileMetadata object contains the file and the cached metadata.
   */
  get Cache() {
    if (this.metadataCacheReady && this.metadataCache) {
      return Array.from(this.metadataCache.values());
    } else {
      this.logger.error("Metadata cache not initialized");
      return [];
    }
  }
  /**
   * Get the singleton instance of the MetadataCache class
   * @returns {MetadataCache} The MetadataCache instance
   */
  static getInstance() {
    if (!MetadataCache.instance) {
      MetadataCache.instance = new MetadataCache();
    }
    return MetadataCache.instance;
  }
  /**
   * Deconstructor for the MetadataCache class
   * @description This method is used to unregister the event handlers for the metadata cache.
   */
  static deconstructor() {
    if (!MetadataCache.instance) {
      Global.getInstance().logger.error("Metadata cache instance not loaded");
      return;
    }
    const instance = MetadataCache.instance;
    if (instance.eventsRegistered) {
      instance.app.vault.off("rename", instance.renameEventHandler);
      instance.app.metadataCache.off("changed", instance.changedEventHandler);
      instance.app.metadataCache.off("deleted", instance.deleteEventHandler);
      instance.eventsRegistered = false;
      Global.getInstance().logger.debug("Metadata cache events unregistered");
      return;
    }
    Global.getInstance().logger.debug("Metadata cache events not registered");
  }
  /**
   * Check if the metadata cache is ready
   * @returns {boolean} True if the metadata cache is ready, false otherwise
   */
  isCacheReady() {
    return this.metadataCacheReady;
  }
  /**
   * Wait for the metadata cache to be ready
   * @returns {Promise<void>} Promise that resolves when the metadata cache is ready
   * @description This method returns a promise that resolves when the metadata cache is ready.
   */
  async waitForCacheReady() {
    while (!this.metadataCacheReady) {
      await new Promise((resolve) => setTimeout(resolve, 5));
    }
  }
  /**
   * Build the metadata cache
   * @returns {Promise<void>} Promise that resolves when the metadata cache is built
   */
  async buildMetadataCache() {
    const startTime = Date.now();
    this.metadataCache = /* @__PURE__ */ new Map();
    const allFiles = this.app.vault.getFiles();
    const addEntryPromises = allFiles.map((file) => this.addEntry(file));
    await Promise.all(addEntryPromises);
    this.metadataCacheReady = true;
    const endTime = Date.now();
    this.logger.debug(`Metadata cache for ${allFiles.length} files built in ${endTime - startTime}ms`);
  }
  /**
   * Add a file to the metadata cache
   * @param file The file to add to the metadata cache
   */
  async addEntry(file) {
    if (this.metadataCache) {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata) {
        this.metadataCache.set(file.path, { file, metadata });
      } else {
        this.logger.warn(`No metadata found for file ${file.path}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
  }
  /**
   * Delete a file from the metadata cache
   * @param file The file to delete from the metadata cache
   */
  deleteEntry(file) {
    if (this.metadataCache) {
      this.metadataCache.delete(file.path);
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${file.path} deleted`);
  }
  /**
   * Update a file in the metadata cache
   * @param file The file to update in the metadata cache
   */
  async updateEntry(file) {
    if (this.metadataCache) {
      const entry = this.metadataCache.get(file.path);
      const metadata = this.app.metadataCache.getFileCache(file);
      if (entry && metadata) {
        entry.metadata = metadata;
      } else if (!entry) {
        this.logger.warn(`No metadata cache entry found for file ${file.path}`);
      } else {
        this.logger.warn(`No metadata found for file ${file.path}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${file.path} updated`);
  }
  /**
   * Rename a file in the metadata cache
   * @param newFile The new file object
   * @param oldPath The old path of the file
   */
  async renameEntry(newFile, oldPath) {
    if (this.metadataCache) {
      const entry = this.metadataCache.get(oldPath);
      if (entry) {
        entry.file = newFile;
      } else {
        this.logger.warn(`No metadata cache entry found for file ${oldPath}`);
      }
    } else {
      this.logger.error("Metadata cache not initialized");
    }
    this.logger.debug(`Metadata cache entry for file ${oldPath} renamed to ${newFile.path}`);
  }
  /**
   * Event handler for the rename event
   * @param file New file object
   * @param oldPath Old path of the file
   */
  renameEventHandler(file, oldPath) {
    this.logger.debug(`File ${file.path} renamed to ${oldPath}`);
    this.renameEntry(file, oldPath);
  }
  /**
   * Event handler for the delete event
   * @param file Deleted file object
   */
  deleteEventHandler(file) {
    this.logger.debug(`File ${file.path} deleted`);
    this.deleteEntry(file);
  }
  /**
   * Event handler for the changed event
   * @param file Changed file object
   */
  changedEventHandler(file) {
    if (this.metadataCache) {
      const existingEntry = this.metadataCache.get(file.path);
      if (existingEntry) {
        this.updateEntry(file);
      } else {
        this.addEntry(file);
      }
    }
  }
  redrawMarkdownView() {
    this.logger.debug(`Redrawing markdown view`);
    this.app.workspace.updateOptions();
  }
  /**
   * Register event handlers for the metadata cache
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.app.vault.on("rename", this.renameEventHandler);
      this.app.metadataCache.on("changed", this.changedEventHandler);
      this.app.metadataCache.on("deleted", this.deleteEventHandler);
      this.eventsRegistered = true;
      this.logger.debug("Metadata cache events registered");
    }
  }
};

// src/classes/Logging.ts
var Logging = class {
  /**
   * Creates a new Logging instance
   * @param logLevel The log level to use. Defaults to "info"
   */
  constructor(logLevel = "info", logPrefix = "") {
    this.logLevel = logLevel;
    this.logPrefix = `${logPrefix}: `;
    if (this.logLevel === "none") {
      console.info("Logging disabled");
    }
    Logging.instance = this;
  }
  setLogLevel(logLevel) {
    this.logLevel = logLevel;
    console.info(`Log level set to ${logLevel}`);
  }
  /**
   * Returns the Logging instance
   */
  static getInstance() {
    if (!Logging.instance) {
      Logging.instance = new Logging();
    }
    return Logging.instance;
  }
  /**
   * Logs a message to the console if the log level is "trace"
   * @param message 
   * @param optionalParams 
   */
  trace(message, ...optionalParams) {
    if (this.logLevelActive("trace")) {
      const logMessage = this.constructLogMessage(message);
      console.debug(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "debug"
   * @param message 
   * @param optionalParams 
   */
  debug(message, ...optionalParams) {
    if (this.logLevelActive("debug")) {
      const logMessage = this.constructLogMessage(message);
      console.debug(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info" or "debug"
   * @param message 
   * @param optionalParams 
   */
  info(message, ...optionalParams) {
    if (this.logLevelActive("info")) {
      const logMessage = this.constructLogMessage(message);
      console.info(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info", "debug" or "warn"
   * @param message 
   * @param optionalParams 
   */
  warn(message, ...optionalParams) {
    if (this.logLevelActive("warn")) {
      const logMessage = this.constructLogMessage(message);
      console.warn(logMessage, ...optionalParams);
    }
  }
  /**
   * Logs a message to the console if the log level is "info", "debug", "warn" or "error"
   * @param message 
   * @param optionalParams 
   */
  error(message, ...optionalParams) {
    if (this.logLevelActive("error")) {
      const logMessage = this.constructLogMessage(message);
      console.error(logMessage, ...optionalParams);
    }
  }
  constructLogMessage(message) {
    return `${this.logPrefix}${message}`;
  }
  logLevelActive(logLevel) {
    if (this.logLevel === "none") {
      return false;
    }
    if (this.logLevel === "trace") {
      return true;
    }
    if (this.logLevel === "debug") {
      return logLevel !== "trace";
    }
    if (this.logLevel === "info") {
      return logLevel !== "trace" && logLevel !== "debug";
    }
    if (this.logLevel === "warn") {
      return logLevel !== "trace" && logLevel !== "debug" && logLevel !== "info";
    }
    if (this.logLevel === "error") {
      return logLevel !== "trace" && logLevel !== "debug" && logLevel !== "info" && logLevel !== "warn";
    }
    return true;
  }
};

// src/classes/Global.ts
var Global = class {
  constructor(prj, app, settings) {
    if (Global.instance) {
      return Global.instance;
    }
    this.plugin = prj;
    this.app = app;
    this.settings = settings;
    this.logger = new Logging(this.settings.logLevel, "Prj");
    Global.instance = this;
    this.fileCache = FileCache.getInstance();
    this.metadataCache = MetadataCache.getInstance();
  }
  async awaitCacheInitialization() {
    this.logger.debug("Waiting for cache initialization");
    await this.fileCache.waitForCacheReady();
    await this.metadataCache.waitForCacheReady();
    this.logger.debug("Cache initialized");
  }
  static deconstructor() {
    FileCache.deconstructor();
    MetadataCache.deconstructor();
  }
  static getInstance(prj = null, app = null, settings = null) {
    if (!Global.instance) {
      if (!prj || !app || !settings) {
        throw new Error("Global instance not initialized and no app provided");
      }
      Global.instance = new Global(prj, app, settings);
    }
    return Global.instance;
  }
};

// src/models/DocumentModel.ts
var import_obsidian3 = require("obsidian");

// src/models/TransactionModel.ts
var TransactionModel = class {
  /**
   * Creates a new instance of the TransactionModel class.
   * @param writeChanges A function that writes the changes to the file.
   */
  constructor(writeChanges) {
    this.logger = Global.getInstance().logger;
    this.transactionActive = false;
    this.changes = {};
    this.transactionActive = false;
    this.writeChanges = writeChanges;
  }
  /**
   * Starts a transaction
   * @remarks - If a transaction is already active, this method does nothing and logs a warning.
   */
  startTransaction() {
    if (this.isTransactionActive) {
      this.logger.warn("Transaction already active");
      return;
    }
    this.transactionActive = true;
  }
  /**
   * Finishes a transaction
   * @remarks - If no transaction is active, this method does nothing and logs a warning.
   * - This method writes the changes to the file.
   * @remarks - If the `writeChanges` method throws an error, the error is logged and the transaction is aborted.
   */
  finishTransaction() {
    if (!this.isTransactionActive) {
      this.logger.warn("No transaction active");
      return;
    }
    try {
      this.writeChanges(this.changes);
    } catch (error) {
      this.logger.error("`writeChanges` failed with error:", error);
    } finally {
      this.changes = {};
      this.transactionActive = false;
    }
  }
  /**
   * Aborts a transaction
   * @remarks - If no transaction is active, this method does nothing and logs a warning.
   * - This method discards all changes.
   */
  abortTransaction() {
    if (!this.isTransactionActive) {
      this.logger.warn("No transaction active");
      return;
    }
    this.changes = {};
    this.transactionActive = false;
  }
  /**
   * Updates the value of the given key.
   * @param key The key to update as path. Example: `data.title`
   * @param value The value to set.
   */
  updateKeyValue(key, value) {
    const keys = key.split(".");
    let current = this.changes;
    keys.forEach((k, index) => {
      if (index === keys.length - 1) {
        current[k] = value;
      } else {
        current[k] = current[k] || {};
        current = current[k];
      }
    });
    if (!this.isTransactionActive) {
      this.writeChanges(this.changes);
      this.changes = {};
    }
  }
  /**
   * Returns whether a transaction is active.
   * @returns `true` if a transaction is active, otherwise `false`.
   */
  get isTransactionActive() {
    return this.transactionActive;
  }
};

// src/models/BaseModel.ts
var BaseModel = class extends TransactionModel {
  /**
   * Creates a new BaseModel instance.
   * @param file The file to create the model for.
   * @param ctor The constructor of the data object.
   * @param yamlKeyMap The yaml key map to use.
   */
  constructor(file, ctor, yamlKeyMap) {
    super((update) => {
      this.frontmatter = update;
    });
    this.global = Global.getInstance();
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this._file = file;
    this.ctor = ctor;
    this.initYamlKeyMap(yamlKeyMap);
  }
  get file() {
    return this._file;
  }
  /**
   * Returns the data object as a proxy.
   * @returns The data object as a proxy.
   */
  get _data() {
    if (this.dataProxy) {
      return this.dataProxy;
    }
    const frontmatter = this.getMetadata();
    if (!frontmatter) {
      this.logger.error("Frontmatter not found");
      const emptyObject = new this.ctor();
      return emptyObject;
    }
    if (this.yamlKeyMap) {
      for (const key in this.yamlKeyMap) {
        if (frontmatter[this.yamlKeyMap[key]]) {
          frontmatter[key] = frontmatter[this.yamlKeyMap[key]];
          delete frontmatter[this.yamlKeyMap[key]];
        }
      }
    }
    const dataObject = new this.ctor(frontmatter);
    this.dataProxy = this.createProxy(dataObject);
    return this.dataProxy;
  }
  set _data(values) {
    const dataObject = new this.ctor(values);
    for (const key in dataObject) {
      this._data[key] = values[key];
    }
  }
  get frontmatter() {
    var _a;
    return (_a = this.getMetadata()) != null ? _a : {};
  }
  set frontmatter(value) {
    (async () => {
      try {
        await this.app.fileManager.processFrontMatter(this._file, (frontmatter) => {
          this.updateNestedFrontmatterObjects(frontmatter, value);
          return frontmatter;
        });
        this.logger.debug(`Frontmatter for file ${this._file.path} successfully updated.`);
      } catch (error) {
        this.logger.error(`Error updating the frontmatter for file ${this._file.path}:`, error);
      }
    })();
  }
  /**
   * Creates a proxy for the given object.
   * @param obj The object to create a proxy for.
   * @param path The path of the object. e.g. `data.title`
   * @returns The proxy object.
   */
  createProxy(obj, path = "") {
    return new Proxy(obj, {
      get: (target, property, receiver) => {
        const propertyKey = this.getPropertyKey(property);
        const value = Reflect.get(target, property, receiver);
        const newPath = path ? `${path}.${propertyKey}` : `${propertyKey}`;
        if (value && typeof value === "object") {
          return this.createProxy(value, newPath);
        }
        return value;
      },
      set: (target, property, value, receiver) => {
        const propertyKey = this.getPropertyKey(property);
        const newPath = path ? `${path}.${propertyKey}` : `${propertyKey}`;
        Reflect.set(target, property, value, receiver);
        this.updateKeyValue(newPath, value);
        return true;
      }
    });
  }
  /**
   * Updates the `yamlKeyMap` with the given value.
   * @param yamlKeyMap The new `yamlKeyMap` to set.
   */
  initYamlKeyMap(yamlKeyMap) {
    if (yamlKeyMap) {
      this.yamlKeyMap = yamlKeyMap;
    }
  }
  getPropertyKey(property) {
    return typeof property === "symbol" ? property.toString() : property;
  }
  getMetadata() {
    var _a, _b;
    const cachedMetadata = (_b = (_a = this.app) == null ? void 0 : _a.metadataCache) == null ? void 0 : _b.getCache(this._file.path);
    if (cachedMetadata && cachedMetadata.frontmatter) {
      return cachedMetadata.frontmatter;
    } else {
      this.logger.warn(`No Metadata found for ${this._file.path}`);
      return null;
    }
  }
  updateNestedFrontmatterObjects(frontmatter, updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (this.yamlKeyMap && this.yamlKeyMap[key]) {
        key = this.yamlKeyMap[key];
      }
      if (typeof value === "object" && value !== void 0 && value !== null && frontmatter[key]) {
        this.updateNestedFrontmatterObjects(frontmatter[key], value);
      } else if (value !== void 0) {
        frontmatter[key] = value;
      }
    });
  }
};

// src/types/DocumentData.ts
var DocumentData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.date = data.date !== void 0 ? data.date : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.sender = data.sender !== void 0 ? data.sender : void 0;
    this.recipient = data.recipient !== void 0 ? data.recipient : void 0;
    this.dateOfDelivery = data.dateOfDelivery !== void 0 ? data.dateOfDelivery : void 0;
    this.hide = data.hide !== void 0 ? data.hide : void 0;
    this.file = data.file !== void 0 ? data.file : void 0;
    this.relatedFiles = data.relatedFiles !== void 0 ? data.relatedFiles : void 0;
    this.citationTitle = data.citationTitle !== void 0 ? data.citationTitle : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.annotationTarget = data.annotationTarget !== void 0 ? data.annotationTarget : void 0;
  }
};
DocumentData.yamlKeyMap = {
  "annotationTarget": "annotation-target"
};

// src/libs/Helper.ts
var import_obsidian2 = require("obsidian");
var Helper = class {
  /**
   * Extracts the date, filename, file extension and display text from a wikilink
   * @param wikilink Wikilink to extract the data from, eg. [[2021.01.01 - file.txt|Display text]]
   * @returns {WikilinkData} Object containing the date, filename, file extension and display text
   * 
   */
  static extractDataFromWikilink(wikilink) {
    if (wikilink && typeof wikilink === "string") {
      const dismantledLinkMatch = wikilink.match(/\[\[(.+?)(?:\.(\w+))?(?:\|(.*))?\]\]/);
      let date = void 0;
      if (!dismantledLinkMatch) {
        return {
          date: void 0,
          basename: void 0,
          extension: void 0,
          filename: void 0,
          displayText: void 0
        };
      } else {
        const dateMatch = dismantledLinkMatch[1].match(/(\d{4})\.(\d{2})\.(\d{2})/);
        if (dateMatch) {
          date = new Date(`${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`);
        }
        return {
          date,
          basename: dismantledLinkMatch[1],
          extension: dismantledLinkMatch[2],
          filename: `${dismantledLinkMatch[1]}.${dismantledLinkMatch[2]}`,
          displayText: dismantledLinkMatch[3]
        };
      }
    } else {
      return {
        date: void 0,
        basename: void 0,
        extension: void 0,
        filename: void 0,
        displayText: void 0
      };
    }
  }
  /**
   * Generates a UID from the given input
   * @param input The input to generate the UID from
   * @param length The length of the UID
   * @returns The generated UID with the given length
   * @remarks - This method uses the MD5 hash algorithm to generate the UID
   * - The UID is prefixed with a "U" to prevent the UID from starting with a number. The "U" counts to the length of the UID
   */
  static generateUID(input, length = 8) {
    const hash = "U" + this.md5(input).toString();
    return hash.substring(0, length);
  }
  static formatDate(date, format) {
    const regexDate = /^\d{4}-\d{2}-\d{2}$/;
    if (!regexDate.test(date)) {
      return date;
    }
    const formatedDate = (0, import_obsidian2.moment)(date).format(format);
    if (formatedDate === "Invalid date") {
      return date;
    }
    return formatedDate;
  }
  /**
   * Sleeps for the given amount of milliseconds
   * @param ms The amount of milliseconds to sleep
   * @returns A promise that resolves after the given amount of milliseconds
   */
  static async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Checks if the given text is possibly markdown
   * @param text The text to check
   * @returns Whether the text is possibly markdown (true or false)
   * @remarks - This method checks if the text contains any of the following symbols:
   * - `*`, `_`, `[`, `]`, `=` and `-` if there is a line break
   */
  static isPossiblyMarkdown(text) {
    let regexMarkdownSymbols;
    const regexLineBreak = /\r?\n/;
    const lineBreak = regexLineBreak.test(text);
    if (lineBreak) {
      regexMarkdownSymbols = /[*_\-[\]=]/;
    } else {
      regexMarkdownSymbols = /[*_[\]=]/;
    }
    return regexMarkdownSymbols.test(text);
  }
  /**
   * Checks if any of the tags in `tagsToCheck` is a substring of any tag in `tagsToBeChecked`
   * @param tagsToCheck The tags to check as substrings
   * @param tagsToBeChecked The tags to be checked against
   * @returns Whether any tag from `tagsToCheck` is a substring of any tag in `tagsToBeChecked`
   */
  static isTagIncluded(tagsToCheck, tagsToBeChecked) {
    const _tagsToCheck = Array.isArray(tagsToCheck) ? tagsToCheck : tagsToCheck ? [tagsToCheck] : [];
    const _tagsToBeChecked = Array.isArray(tagsToBeChecked) ? tagsToBeChecked : tagsToBeChecked ? [tagsToBeChecked] : [];
    return _tagsToCheck.some(
      (tagToCheck) => _tagsToBeChecked.some(
        (tagToBeChecked) => tagToBeChecked == null ? void 0 : tagToBeChecked.includes(tagToCheck)
      )
    );
  }
};
Helper.md5 = require_md5();

// src/models/DocumentModel.ts
var DocumentModel = class extends BaseModel {
  constructor(file) {
    super(file, DocumentData, DocumentData.yamlKeyMap);
    this.fileCache = Global.getInstance().fileCache;
    this._relatedFiles = void 0;
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
  }
  get relatedFiles() {
    if (this._relatedFiles === void 0) {
      this._relatedFiles = [];
      const relatedFiles = this.data.relatedFiles;
      if (relatedFiles) {
        relatedFiles.map((relatedFile) => {
          var _a;
          const wikilinkData = Helper.extractDataFromWikilink(relatedFile);
          const mdFilename = wikilinkData.basename ? `${wikilinkData.basename}.md` : "";
          const file = this.fileCache.findFileByName(mdFilename);
          if (file instanceof import_obsidian3.TFile && file.path !== this.file.path) {
            (_a = this._relatedFiles) == null ? void 0 : _a.push(new DocumentModel(file));
          }
          return null;
        });
      } else {
        this._relatedFiles = null;
      }
    }
    return this._relatedFiles;
  }
  toString() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    let allText = (_a = this.data.title) != null ? _a : "";
    allText += (_b = this.data.description) != null ? _b : "";
    allText += (_c = this.data.date) != null ? _c : "";
    allText += (_d = this.data.dateOfDelivery) != null ? _d : "";
    allText += (_e = this.data.file) != null ? _e : "";
    allText += (_f = this.data.tags) != null ? _f : "";
    allText += (_g = this.data.sender) != null ? _g : "";
    allText += (_h = this.data.recipient) != null ? _h : "";
    allText += (_i = this.data.relatedFiles) != null ? _i : "";
    return allText;
  }
  getWikilink(text) {
    if (text) {
      return `[[${this.file.name}|${text}]]`;
    } else {
      return `[[${this.file.name}]]`;
    }
  }
  /**
   * Returns the file contents of the document
   * @returns String containing the file contents
   */
  async getFileContents() {
    return this.app.vault.read(this.file);
  }
  getCorospondingSymbol() {
    if (this.data.type === "Metadata") {
      if (this.data.subType === "Cluster") {
        return this.global.settings.documentSettings.clusterSymbol;
      } else if (this.data.hide) {
        return this.global.settings.documentSettings.hideSymbol;
      } else {
        return this.global.settings.documentSettings.symbol;
      }
    }
    return "x-circle";
  }
  /**
   * Returns the description of the document
   * @returns String containing the description
   */
  getDescription() {
    var _a;
    return (_a = this.data.description) != null ? _a : "";
  }
  /**
   * Returns `Input` if the document is addressed to the user or `Output` if it comes from the user. Otherwise `null`.
   * @returns State of the document.
   * E.g. `Input` if the document is addressed to the user or `Output` if it comes from the user. Otherwise `null`.
   */
  getInputOutputState() {
    const username = this.global.settings.user.name;
    const shortUsername = this.global.settings.user.shortName;
    if (this.data && (this.data.sender || this.data.recipient)) {
      if (this.data.sender === username || this.data.sender === shortUsername) {
        return "Output";
      } else if (this.data.recipient === username || this.data.recipient === shortUsername) {
        return "Input";
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  /**
   * Returns the linked file of the document
   * @returns TFile of the linked file
   */
  getFile() {
    var _a, _b;
    const fileLinkData = Helper.extractDataFromWikilink(this.data.file);
    const file = this.fileCache.findFileByName((_a = fileLinkData.filename) != null ? _a : "");
    if (file instanceof import_obsidian3.TFile) {
      return file;
    } else if (Array.isArray(file)) {
      this.logger.warn(`Multiple files found for ${fileLinkData.filename}`);
      return (_b = file.first()) != null ? _b : this.file;
    }
    this.logger.warn(`No files found for ${fileLinkData.filename}`);
    return this.file;
  }
  /**
   * Returns the tags of the document as an array of strings
   * @returns Array of strings containing the tags
   */
  getTags() {
    const tags = this.data.tags;
    let formattedTags = [];
    if (tags && typeof tags === "string") {
      formattedTags = [tags];
    } else if (Array.isArray(tags)) {
      formattedTags = [...tags];
    }
    return formattedTags;
  }
  /**
   * Sorts the documents by date descending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   */
  static sortDocumentsByDateDesc(documents) {
    documents.sort((a, b) => {
      if (a.data.date && b.data.date) {
        const dateA = new Date(a.data.date);
        const dateB = new Date(b.data.date);
        return dateB.getTime() - dateA.getTime();
      } else if (a.data.date) {
        return -1;
      } else if (b.data.date) {
        return 1;
      } else {
        return 0;
      }
    });
  }
  /**
   * Sorts the documents by date ascending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   */
  static sortDocumentsByDateAsc(documents) {
    documents.sort((a, b) => {
      if (a.data.date && b.data.date) {
        const dateA = new Date(a.data.date);
        const dateB = new Date(b.data.date);
        return dateA.getTime() - dateB.getTime();
      } else if (a.data.date) {
        return 1;
      } else if (b.data.date) {
        return -1;
      } else {
        return 0;
      }
    });
  }
};

// src/libs/BlockRenderComponents/TableBlockRenderComponent.ts
var import_obsidian4 = require("obsidian");

// src/translations.json
var translations_default = [
  {
    lang: "en",
    translations: {
      DocumentType: "Type",
      Date: "Date",
      Subject: "Subject",
      Sender: "Sender",
      Recipient: "Recipient",
      SendRecip: "Snd./Rcp.",
      Content: "Content",
      DeliveryDate: "Delivery date",
      Tags: "Tags",
      From: "from:",
      To: "to:",
      Refresh: "Refresh",
      Documents: "Documents",
      HideDocuments: "Hide documents",
      Cluster: "Document Cluster",
      Filter: "Filter:",
      MaxShownEntrys: "Max. shown entries",
      Search: "Search",
      DocumentDate: "Document date",
      MetadataFile: "Metadata file",
      PDFFile: "PDF file",
      TraficLight: "\u{1F6A6}",
      Description: "Description",
      Priority: "Prio.",
      Status: "Status",
      DueDate: "Due date",
      PriorityText: "Priority",
      HighPriority: "High priority",
      MediumPriority: "Medium priority",
      LowPriority: "Low priority",
      NoPriority: "No priority",
      Title: "Title",
      StatusActive: "Active",
      StatusWaiting: "Waiting",
      StatusLater: "Later",
      StatusSomeday: "Someday",
      StatusDone: "Done",
      Done: "Done",
      Topic: "Topic",
      Project: "Project",
      Task: "Task",
      ShowMetadataFile: "Show metadata file"
    }
  },
  {
    lang: "de",
    translations: {
      DocumentType: "Typ",
      Date: "Datum",
      Subject: "Betreff",
      Sender: "Absender",
      Recipient: "Empf\xE4nger",
      SendRecip: "Abs./Empf.",
      Content: "Inhalt",
      DeliveryDate: "Zustelldatum",
      Tags: "Tags",
      From: "von:",
      To: "an:",
      Refresh: "Aktualisieren",
      Documents: "Dokumente",
      HideDocuments: "Ausgeblendete Dokumente",
      Cluster: "Dokumenten Cluster",
      Filter: "Filter:",
      MaxShownEntrys: "Max. angezeigte Eintr\xE4ge",
      Search: "Suche",
      DocumentDate: "Dokumenten Datum",
      MetadataFile: "Metadaten Datei",
      PDFFile: "PDF Datei",
      TraficLight: "\u{1F6A6}",
      Description: "Beschreibung",
      Priority: "Prio.",
      Status: "Status",
      DueDate: "F\xE4lligk.-Datum",
      PriorityText: "Priorit\xE4t",
      HighPriority: "Hohe Priorit\xE4t",
      MediumPriority: "Mittlere Priorit\xE4t",
      LowPriority: "Niedrige Priorit\xE4t",
      NoPriority: "Keine Priorit\xE4t",
      Title: "Titel",
      StatusActive: "Aktiv",
      StatusWaiting: "Warten",
      StatusLater: "Sp\xE4ter",
      StatusSomeday: "Irgendwann",
      StatusDone: "Erledigt",
      Done: "Erledigt",
      Topic: "Thema",
      Project: "Projekt",
      Task: "Aufgabe",
      ShowMetadataFile: "Metadaten Datei anzeigen"
    }
  }
];

// src/classes/Lng.ts
var Lng = class {
  /**
   * Returns a translation for the given key.
   * @param key The key to translate.
   * @returns The translation.
   * @remarks - If the translation is not found, the key is returned.
   * - Look at the `translations.json` file to see all available translations.
   */
  static gt(key) {
    const logger = Global.getInstance().logger;
    const lang = Global.getInstance().settings.language;
    const translation = translations_default;
    const language = translation.find((v) => v.lang === lang);
    if (language) {
      if (language.translations.hasOwnProperty(key)) {
        return language.translations[key];
      }
    }
    logger.warn(`Translation for key ${key} not found`);
    return key;
  }
};

// src/libs/BlockRenderComponents/TableBlockRenderComponent.ts
var TableBlockRenderComponent = class {
  //#endregion
  constructor(settings) {
    //#region General properties
    this.global = Global.getInstance();
    this.logger = this.global.logger;
    this.metadataCache = this.global.metadataCache.Cache;
    this.fileCache = this.global.fileCache;
    this.processorSettings = settings;
    this.component = new import_obsidian4.MarkdownRenderChild(this.processorSettings.container);
  }
  /**
   * Builds the component first time.
   * @remarks Calls the `draw` method.
   */
  async build() {
    return this.draw();
  }
  /**
   * Builds the `tableContainer` and `headerContainer` elements.
   * @remarks - Call this method to build the base structure first.
   * - Override this method to build the other elements.
   * @remarks - Build the `tableContainer` and `headerContainer` elements.
   * - Build the `controle block` => add a refresh button which calls the `redraw` method.
   */
  async draw() {
    this.headerContainer = document.createElement("div");
    this.processorSettings.container.appendChild(this.headerContainer);
    this.headerContainer.classList.add("header-container");
    const blockControle = document.createElement("div");
    this.headerContainer.appendChild(blockControle);
    blockControle.classList.add("block-controle");
    const refreshButton = document.createElement("a");
    blockControle.appendChild(refreshButton);
    refreshButton.classList.add("refresh-button");
    refreshButton.title = Lng.gt("Refresh");
    refreshButton.href = "#";
    (0, import_obsidian4.setIcon)(refreshButton, "refresh-cw");
    this.component.registerDomEvent(refreshButton, "click", async (event) => {
      event.preventDefault();
      this.redraw();
    });
    this.tableContainer = document.createElement("div");
    this.processorSettings.container.appendChild(this.tableContainer);
    this.tableContainer.classList.add("table-container");
  }
  /**
   * Redraws the component on request. Clears the container and calls the `draw` method.
   * @remarks This methode clears the container and calls the `draw` methode.
   */
  async redraw() {
    this.processorSettings.container.innerHTML = "";
    return this.draw();
  }
  /**
   * Normalizes the header.
   * @remarks - Removes the `disable` class from the header.
   * - The header is not grayed out anymore.
   */
  normalizeHeader() {
    this.headerContainer.removeClass("disable");
  }
  /**
   * Grays out the header.
   * @remarks - Adds the `disable` class to the header.
   * - The header is grayed out.
   */
  grayOutHeader() {
    this.headerContainer.addClass("disable");
  }
  getUID(model) {
    return Helper.generateUID(model.file.path);
  }
};

// src/libs/Search.ts
var Search = class {
  /**
   * Parses the search text into an array of objects that represent the search terms
   * @param searchText The search text to parse
   * @returns An array of objects with the following properties:
   * - term: The search term
   * - negate: Whether the term should be negated
   * - isOperator: Whether the term is an operator
   */
  static parseSearchText(searchText) {
    searchText = searchText.toLowerCase();
    if (!searchText.includes('"')) {
      return [{ term: searchText.trim(), negate: false, isOperator: false }];
    }
    const terms = [];
    let term = "";
    let inQuotes = false;
    let negate = false;
    for (const char of searchText) {
      if (char === '"') {
        if (inQuotes) {
          terms.push({ term: term.toLowerCase(), negate, isOperator: false });
          term = "";
          negate = false;
        }
        inQuotes = !inQuotes;
      } else if (inQuotes) {
        term += char;
      } else if (char === " ") {
        continue;
      } else if (["&", "|", "!"].includes(char)) {
        if (term.length > 0) {
          terms.push({ term, negate, isOperator: false });
          term = "";
          negate = false;
        }
        if (char === "!") {
          negate = true;
        } else {
          terms.push({ term: char, negate: false, isOperator: true });
        }
      } else {
        term += char;
      }
    }
    if (term.length > 0) {
      terms.push({ term, negate, isOperator: false });
    }
    if (terms.length > 1) {
      let i = 0;
      while (i < terms.length - 1) {
        if (!terms[i].isOperator && !terms[i + 1].isOperator) {
          terms.splice(i + 1, 0, { term: "&", negate: false, isOperator: true });
        }
        i += 2;
      }
    }
    return terms;
  }
  /**
   * Applies the search logic to the given text content
   * @param terms The search terms
   * @param textContent The text content to apply the search logic to
   * @returns Whether the text content matches the search terms (true or false)
   */
  static applySearchLogic(terms, textContent) {
    textContent = textContent.toLowerCase();
    let result = terms[0].negate ? !textContent.includes(terms[0].term) : textContent.includes(terms[0].term);
    for (let i = 1; i < terms.length; i += 2) {
      const operatorObj = terms[i];
      const nextTermObj = terms[i + 1];
      const nextTermMatch = nextTermObj.negate ? !textContent.includes(nextTermObj.term) : textContent.includes(nextTermObj.term);
      if (operatorObj.term === "&") {
        result = result && nextTermMatch;
      } else if (operatorObj.term === "|") {
        result = result || nextTermMatch;
      }
    }
    return result;
  }
};

// src/libs/Table.ts
var Table = class {
  // // //// // //// // //
  /**
   * Creates a new table
   * @param tableHeaders A list of table headers
   * @param id The ID of the table
   * @param classList The class list of the table
   */
  constructor(tableHeaders, id, classList) {
    this.logger = Global.getInstance().logger;
    /**
     * A list of row placeholders
     * @remarks - The row placeholders are used to keep the order of the rows when hiding and showing rows.
     * - The placeholders rows are empty and have the id `defaultIds.placeholder` (default: `placeholder-row`).
     */
    this._rowPlaceholders = [];
    this._visibleRows = 0;
    this._hiddenRows = 0;
    //   Default classes  //
    this.defaultClasses = {
      table: ["prj-table"],
      header: ["prj-table-header"],
      headerRow: ["prj-table-header-row"],
      headerCell: ["prj-table-header-cell"],
      body: ["prj-table-body"],
      row: ["prj-table-row", "prj-table-row-hover"],
      cell: ["prj-table-cell"],
      hiddenRow: "hidden-row",
      evenRow: "even-row",
      oddRow: "odd-row"
    };
    // Default IDs 
    this.defaultIds = {
      placeholder: "placeholder-row"
    };
    this._headers = tableHeaders;
    this._tableId = id;
    this._tableClassList = classList;
    this._table = this.createTable();
  }
  get data() {
    return this._table;
  }
  /**
   * Delte the complete table
   */
  deconstructor() {
    this._table.table.remove();
  }
  createTable() {
    const table = document.createElement("table");
    table.id = this._tableId;
    table.classList.add(...this.defaultClasses.table);
    if (this._tableClassList) {
      this._tableClassList.forEach((classItem) => {
        table.classList.add(classItem);
      });
    }
    const tableHeader = table.createTHead();
    tableHeader.classList.add(...this.defaultClasses.header);
    const tableHeaderRow = tableHeader.insertRow();
    tableHeaderRow.classList.add(...this.defaultClasses.headerRow);
    const tableHeaderCells = [];
    this._headers.forEach((header) => {
      const tableHeaderCell = document.createElement("th");
      tableHeaderCell.classList.add(...this.defaultClasses.headerCell);
      tableHeaderCell.id = this.makeSafeForId(header.text);
      tableHeaderCell.textContent = header.text;
      if (header.headerClass) {
        header.headerClass.forEach((classItem) => {
          tableHeaderCell.classList.add(classItem);
        });
      }
      tableHeaderCells.push(tableHeaderCell);
      tableHeaderRow.appendChild(tableHeaderCell);
    });
    const tableBody = table.createTBody();
    tableBody.classList.add(...this.defaultClasses.body);
    const structedTable = {
      table,
      header: tableHeader,
      headerRow: tableHeaderRow,
      headerCells: tableHeaderCells,
      body: tableBody,
      rows: []
    };
    return structedTable;
  }
  /**
   * Adds a row to the table
   * @param rowUid The UID of the new row
   * @param rowData The data of the new row
   * @param rowClassList The class list of the new row
   * @param hidden Whether the new row should be hidden
   */
  addRow(row) {
    this._addRow(row.rowUid, row.rowData, row.rowClassList, row.hidden);
  }
  /**
   * Adds multiple rows to the table
   * @param rows The rows to add
   * @param rows.rowUid The UID of the new row
   * @param rows.rowData The data of the new row
   * @param rows.rowClassList The class list of the new row
   * @param rows.hidden Whether the new row should be hidden
   * @remarks - The rows are added in the order of the array.
   * - The rows are added to the internal array.
   * - If the row is hidden, the row content is replaced with a placeholder.
   */
  addRows(rows) {
    const collectedRows = document.createDocumentFragment();
    rows.forEach((row) => {
      const rowFragment = this.createRow(row.rowUid, row.rowData, row.rowClassList, row.hidden);
      if (rowFragment) {
        this._table.rows.push(rowFragment);
        if (row.hidden) {
          collectedRows.append(this._getPlaceholder(row.rowUid));
        } else {
          collectedRows.append(rowFragment);
        }
      }
    });
    this._table.body.append(collectedRows);
  }
  /**
   * Adds a row to the table
   * @param rowUid The UID of the new row
   * @param rowData The data of the new row as an array of DocumentFragments. Each DocumentFragment represents a cell.
   * @param rowClassList The class list of the new row
   * @param hidden Whether the new row should be hidden
   * @remarks - The row is added to the internal array.
   * - If the row is hidden, the row content is replaced with a placeholder.
   */
  _addRow(rowUid, rowData, rowClassList, hidden) {
    const tableRow = this.createRow(rowUid, rowData, rowClassList, hidden);
    this._table.rows.push(tableRow);
    if (hidden) {
      this._table.body.append(this._getPlaceholder(rowUid));
    } else {
      this._table.body.append(tableRow);
    }
  }
  /**
   * Creates a row
   * @param rowUid The UID of the row 
   * @param rowData The data of the row as an array of DocumentFragments. Each DocumentFragment represents a cell.
   * @param rowClassList The class list of the row
   * @param hidden Whether the row should be hidden.
   * @remarks **If true, the row is hidden and the row content is later replaced with a placeholder.**
   * @returns The created row as an HTMLTableRowElement
   */
  createRow(rowUid, rowData, rowClassList, hidden) {
    const tableRow = document.createElement("tr");
    tableRow.classList.add(...this.defaultClasses.row);
    tableRow.setAttribute("row-uid", rowUid);
    if (rowClassList) {
      rowClassList.forEach((classItem) => {
        tableRow.classList.add(classItem);
      });
    }
    if (hidden) {
      tableRow.classList.add(this.defaultClasses.hiddenRow);
      this._hiddenRows++;
    } else {
      this.setRowOddOrEven(tableRow);
      this._visibleRows++;
    }
    rowData.forEach((data, index) => {
      var _a;
      const tableCell = tableRow.insertCell();
      tableCell.classList.add(...this.defaultClasses.cell);
      if (this._headers[index] !== void 0 && this._headers[index].columnClass) {
        (_a = this._headers[index].columnClass) == null ? void 0 : _a.forEach((classItem) => {
          tableCell.classList.add(classItem);
        });
      }
      tableCell.setAttribute("data-label", this._headers[index].text);
      tableCell.appendChild(data);
    });
    return tableRow;
  }
  /**
   * Sets the row to odd or even
   * @param tableRow The row to set
   * @remarks - The row is set to odd or even based on the last visible row.
   * - If no visible row exists, the row is set to even.
   * @remarks It does not search for the last visible line in the HTML table itself, but in an internal array.
   */
  setRowOddOrEven(tableRow) {
    let lastVisibleRow;
    for (let i = this._table.rows.length - 1; i >= 0; i--) {
      if (!this._table.rows[i].classList.contains(this.defaultClasses.hiddenRow)) {
        lastVisibleRow = this._table.rows[i];
        break;
      }
    }
    if (lastVisibleRow) {
      tableRow.classList.add(lastVisibleRow.classList.contains(this.defaultClasses.evenRow) ? this.defaultClasses.oddRow : this.defaultClasses.evenRow);
    } else {
      tableRow.classList.add(this.defaultClasses.evenRow);
    }
  }
  /**
   * Returns the number of visible and hidden rows
   * @returns The number of visible and hidden rows
   * @returns visibleRows The number of visible rows
   * @returns hiddenRows The number of hidden rows
   */
  getRowStats() {
    return { visibleRows: this._visibleRows, hiddenRows: this._hiddenRows };
  }
  /**
   * Deletes the row with the given UID
   * @param rowUid The UID of the row
   * @remarks - The row is deleted from the table body and the internal array.
   * - If a placeholder exists, it is also deleted from the table body and the internal array.
   */
  deleteRow(rowUid) {
    const rowToDelete = this.getRow(rowUid);
    const rowVisible = rowToDelete && !rowToDelete.classList.contains(this.defaultClasses.hiddenRow);
    if (rowVisible) {
      if (rowToDelete) {
        try {
          this._table.body.removeChild(rowToDelete);
        } catch (error) {
          this.logger.warn("Row not active in the table. Error:", error);
        }
        this._table.rows = this._table.rows.filter((row) => row.getAttribute("row-uid") !== rowUid);
        this._removePlaceholder(rowUid);
      }
      this._visibleRows--;
      this.refreshRowEvenOddClass();
    } else {
      const placeholder = this._removePlaceholder(rowUid);
      if (placeholder) {
        try {
          this._table.body.removeChild(placeholder);
        } catch (error) {
          this.logger.warn("Placeholder row not active in the table. Error:", error);
        }
      }
      this._hiddenRows--;
    }
  }
  /**
   * Set a row to hidden
   * @param rowUid The UID of the row
   * @remarks - The row is set to hidden and the row content is replaced with a placeholder.
   * - Only if the state has changed, the calculation of the odd and even rows is updated.
   */
  hideRow(rowUid) {
    const changes = this._hideRow(rowUid);
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Set a row to hidden, replaces the row content with a placeholder and updates the row stats
   * @param rowUid The UID of the row
   * @returns Whether the state has changed. Returns `false` if the row is already hidden.
   */
  _hideRow(rowUid) {
    this.logger.trace(`Row ${rowUid} should be hidden.`);
    const changes = this.togleRowClass(rowUid, [this.defaultClasses.hiddenRow], true);
    this.logger.trace(`Row ${rowUid} changes: ${changes}`);
    if (changes) {
      this._removeRowContent(rowUid);
      this._visibleRows--;
      this._hiddenRows++;
    }
    return changes;
  }
  /**
   * Set a row to visible
   * @param rowUid The UID of the row
   * @remarks - The row is set to visible and the row content is replaced with the original content.
   * - Only if the state has changed, the calculation of the odd and even rows is updated.
   */
  showRow(rowUid) {
    const changes = this._showRow(rowUid);
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Set a row to visible, replaces the placeholder with the original row content and updates the row stats
   * @param rowUid The UID of the row
   * @returns Whether the state has changed. Returns `false` if the row is already visible.
   */
  _showRow(rowUid) {
    this.logger.trace(`Row ${rowUid} should be shown.`);
    const changes = this.togleRowClass(rowUid, [this.defaultClasses.hiddenRow], false);
    this.logger.trace(`Row ${rowUid} changes: ${changes}`);
    if (changes) {
      this._addRowContent(rowUid);
      this._visibleRows++;
      this._hiddenRows--;
    }
    return changes;
  }
  /**
   * Set the state of multiple rows to hidden or visible
   * @param rows The rows to change
   * @param rows.rowUid The UID of the row
   * @param rows.hidden Whether to hide or show the row
   */
  async changeShowHideStateRows(rows) {
    this.logger.trace(`Change Show/Hide state of ${rows.length} rows.`);
    let changes = false;
    rows.forEach((row) => {
      this.logger.trace(`Change Show/Hide state of Row: ${row.rowUid} to ${row.hidden}.`);
      if (row.hidden) {
        this.logger.trace(`Hide Row: ${row.rowUid}`);
        const result = this._hideRow(row.rowUid);
        changes || (changes = result);
      } else {
        this.logger.trace(`Show Row: ${row.rowUid}`);
        const result = this._showRow(row.rowUid);
        changes || (changes = result);
      }
    });
    if (changes)
      this.refreshRowEvenOddClass();
  }
  /**
   * Replaces the row in table body with a placeholder
   * @param rowUid The UID of the row
   * @remarks - Search the row in the internal array,
   * - If found, get the placeholder from the internal array and replace the row in the table body with the placeholder.
   */
  _removeRowContent(rowUid) {
    const row = this.getRow(rowUid);
    if (row) {
      const placeholder = this._getPlaceholder(rowUid);
      this._table.body.replaceChild(placeholder, row);
    }
  }
  /**
   * Replaces the placeholder in table body with the row
   * @param rowUid The UID of the row
   * @remarks - Search the row in the internal array,
   * - If found, get the placeholder from the internal array and replace the placeholder in the table body with the row.
   */
  _addRowContent(rowUid) {
    const row = this.getRow(rowUid);
    if (row) {
      const placeholder = this._getPlaceholder(rowUid);
      if (placeholder) {
        try {
          this._table.body.replaceChild(row, placeholder);
        } catch (error) {
          this.logger.warn("Placeholder row not active in the table. Error:", error);
        }
      }
    }
  }
  /**
   * Generates a placeholder row
   * @param rowUid The UID of the row
   * @returns The generated placeholder row
   * @remarks - The placeholder row is empty and has the id `defaultIds.placeholder` (default: `placeholder-row`).
   * - The placeholder row is added to the internal array.
   */
  _generatePlaceholder(rowUid) {
    const placeholder = document.createElement("tr");
    placeholder.id = this.defaultIds.placeholder;
    placeholder.setAttribute("row-uid", rowUid);
    this._rowPlaceholders.push({ rowUid, row: placeholder });
    return placeholder;
  }
  /**
   * Removes the placeholder row with the given UID from the internal array
   * @param rowUid The UID of the row
   */
  _removePlaceholder(rowUid) {
    var _a;
    const placeholder = (_a = this._rowPlaceholders.find((rowPlaceholder) => rowPlaceholder.rowUid === rowUid)) == null ? void 0 : _a.row;
    if (placeholder) {
      this._rowPlaceholders = this._rowPlaceholders.filter((rowPlaceholder) => rowPlaceholder.rowUid !== rowUid);
    }
    return placeholder;
  }
  /**
   * Returns the placeholder row with the given UID
   * @param rowUid The UID of the row
   * @returns - The placeholder row with the given UID
   * - or a new placeholder row if no placeholder row with the given UID exists
   * @remarks - If a new placeholder row is generated, it is added to the internal array.
   */
  _getPlaceholder(rowUid) {
    var _a;
    const placeholder = (_a = this._rowPlaceholders.find((rowPlaceholder) => rowPlaceholder.rowUid === rowUid)) == null ? void 0 : _a.row;
    if (placeholder)
      return placeholder;
    else {
      return this._generatePlaceholder(rowUid);
    }
  }
  /**
   * Returns the row with the given UID
   * @param rowUid The UID of the row
   * @returns The row with the given UID or undefined if no row with the given UID exists
   */
  getRow(rowUid) {
    return this._table.rows.find((row) => row.getAttribute("row-uid") === rowUid);
  }
  /**
   * Toggles the class of a row
   * @param rowUid The UID of the row
   * @param classList The class list to toggle
   * @param add Whether to add or remove the class
   */
  togleRowClass(rowUid, classList, add) {
    let changes = false;
    const row = this.getRow(rowUid);
    if (row) {
      changes = this.toggleClass(row, classList, add);
    }
    return changes;
  }
  /**
   * Refreshes the odd and even rows with the corosponding classes
   * @remarks - The odd and even rows are calculated based on the visible rows from the internal array.
   * - Change the classes only if necessary.
   */
  refreshRowEvenOddClass() {
    const visibleRows = this._table.rows.filter((row) => !row.classList.contains(this.defaultClasses.hiddenRow));
    visibleRows.forEach((row, index) => {
      if (index % 2 === 0) {
        this.toggleClass(row, [this.defaultClasses.evenRow], true);
        this.toggleClass(row, [this.defaultClasses.oddRow], false);
      } else {
        this.toggleClass(row, [this.defaultClasses.evenRow], false);
        this.toggleClass(row, [this.defaultClasses.oddRow], true);
      }
    });
  }
  toggleClass(element, classList, add) {
    let changes = false;
    const presentClasses = element.classList;
    if (add) {
      classList.forEach((classItem) => {
        if (!presentClasses.contains(classItem)) {
          element.classList.add(classItem);
          changes = true;
        }
      });
    } else {
      classList.forEach((classItem) => {
        if (presentClasses.contains(classItem)) {
          element.classList.remove(classItem);
          changes = true;
        }
      });
    }
    return changes;
  }
  /**
   * Changes the header of the table
   * @param header The header to change; the header text must match the original header text
   */
  changeHeader(header) {
    this.changeHeaderClass(header);
    this.changeColumnClass(header);
    this._headers[this._headers.findIndex((headerItem) => headerItem.text === header.text)] = header;
  }
  changeHeaderClass(header) {
    const headerIndex = this._headers.findIndex((headerItem) => headerItem.text === header.text);
    const oldHeaderClasses = this._headers[headerIndex].headerClass;
    const newHeaderClasses = header.headerClass;
    const headerCell = this._table.headerCells[headerIndex];
    if (oldHeaderClasses) {
      this.toggleClass(headerCell, oldHeaderClasses, false);
    }
    if (newHeaderClasses) {
      this.toggleClass(headerCell, newHeaderClasses, true);
    }
  }
  changeColumnClass(header) {
    const columnIndex = this._headers.findIndex((headerItem) => headerItem.text === header.text);
    const oldHeaderClasses = this._headers[columnIndex].headerClass;
    this._table.rows.forEach((row) => {
      const cell = row.cells[columnIndex];
      if (cell) {
        if (oldHeaderClasses) {
          this.toggleClass(cell, oldHeaderClasses, false);
        }
        if (header.columnClass) {
          this.toggleClass(cell, header.columnClass, true);
        }
      }
    });
  }
  makeSafeForId(input) {
    let result = "";
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (i === 0 && !isNaN(Number(char))) {
        result += "_";
      } else if (char.match(/[a-zA-Z]/)) {
        result += char.toLowerCase();
      } else if (char.match(/[0-9]/)) {
        result += char;
      } else {
        result += "_";
      }
    }
    return result;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/FilterButton.ts
var import_obsidian5 = require("obsidian");
var FilterButton = class {
  /**
   * Creates a new filter button.
   * @param component The component to register the events to.
   * @param type The type of the filter button.
   * @param symbol The symbol of the filter button.
   * @param status The initial status of the filter button.
   * @param onFilter The callback to call when the filter button is clicked. Passes the type of the filter button and the status of the filter button.
   * @returns The created filter button as `DocumentFragment`.
   * @remarks - The filter button consists of a filter button container and a filter button.
   * - CSS classes:
   * - `filter-symbol` - The filter button.
   * - `filter-symbol-hide` - Additional class for the filter button to hide it.
   */
  static create(component, type2, symbol, status, onFilter) {
    const headerItemContainer = document.createDocumentFragment();
    const filterButtonContainer = document.createElement("div");
    headerItemContainer.appendChild(filterButtonContainer);
    const filter = FilterButton.createFilterButton(status, type2, symbol, component, onFilter);
    filterButtonContainer.appendChild(filter);
    return headerItemContainer;
  }
  /**
   * Creates the filter button.
   * @param status The initial status of the filter button.
   * @param type The type of the filter button.
   * @param symbol The symbol of the filter button.
   * @param component The component to register the events to.
   * @param filterCallback The callback to call when the filter button is clicked. Passes the type of the filter button and the status of the filter button.
   * @returns The created filter button as `DocumentFragment`.
   * @remarks - The filter button is a `HTMLAnchorElement`.
   * - CSS classes:
   * - `filter-symbol` - The filter button.
   * - `filter-symbol-hide` - Additional class for the filter button to hide it.
   */
  static createFilterButton(status, type2, symbol, component, filterCallback) {
    const logger = Global.getInstance().logger;
    const filterButtonContainer = document.createDocumentFragment();
    const filter = document.createElement("a");
    filterButtonContainer.appendChild(filter);
    filter.classList.add("filter-symbol");
    if (!status) {
      filter.classList.add("filter-symbol-hide");
    }
    filter.title = Lng.gt(type2);
    filter.href = "#";
    (0, import_obsidian5.setIcon)(filter, symbol);
    component.registerDomEvent(filter, "click", async (event) => {
      filter.classList.toggle("filter-symbol-hide");
      try {
        await filterCallback(type2, filter.classList.contains("filter-symbol-hide"));
      } catch (error) {
        logger.error("The `onFilter` callback threw an error!", error);
      }
    });
    return filterButtonContainer;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/MaxShownModelsInput.ts
var import_obsidian6 = require("obsidian");
var MaxShownModelsInput = class {
  /**
   * Creates a new max shown models input component.
   * @param component The component to register the events to.
   * @param defaultValue The default value of the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onChange The callback to call when the max shown models number changes. Passes the max shown models number. You can return a new max shown models number.
   * @returns The created max shown models input component as `DocumentFragment`.
   * @remarks - The max shown models input component consists of a container, a minus symbol, a presentation span and a plus symbol.
   * - CSS classes:
   * - `filter-max-models` - The container of the max shown models input component.
   * - `filter-max-number` - The presentation span of the max shown models input component.
   * - `minus-batch-button` - The minus symbol of the max shown models input component.
   * - `plus-batch-button` - The plus symbol of the max shown models input component.
   */
  static create(component, defaultValue, batchSize, onChange) {
    const headerItemContainer = document.createDocumentFragment();
    const logger = Global.getInstance().logger;
    let debounceTimer;
    const maxShownModels = {
      maxShownModels: !isNaN(parseFloat(defaultValue)) && isFinite(defaultValue) ? Number(defaultValue) : 0
    };
    const filterMaxModelsContainer = document.createElement("div");
    headerItemContainer.appendChild(filterMaxModelsContainer);
    filterMaxModelsContainer.classList.add("filter-max-models");
    const number = this.createNumberPresentation(maxShownModels, component, batchSize);
    const debounceOnChange = () => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        var _a;
        try {
          maxShownModels.maxShownModels = (_a = await onChange(maxShownModels.maxShownModels)) != null ? _a : maxShownModels.maxShownModels;
        } catch (error) {
          logger.error("The `onChange` callback threw an error!", error);
        } finally {
          number.number.textContent = maxShownModels.maxShownModels.toString();
        }
      }, 500);
    };
    MaxShownModelsInput.createNumberPresentationEvent(
      component,
      number.number,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    const minus = this.createSymbol(
      "minus",
      number.number,
      component,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    const plus = this.createSymbol(
      "plus",
      number.number,
      component,
      maxShownModels,
      batchSize,
      debounceOnChange
    );
    filterMaxModelsContainer.appendChild(minus);
    filterMaxModelsContainer.appendChild(number.container);
    filterMaxModelsContainer.appendChild(plus);
    return headerItemContainer;
  }
  /**
   * Create the presentation span for the max shown models number.
   * @param maxShownModels The container for the max shown models number.
   * @returns - The created presentation span as `DocumentFragment`
   * - The created presentation span as `HTMLSpanElement`
   * - The span element has the class `filter-max-number`.
   */
  static createNumberPresentation(maxShownModels, component, batchSize) {
    const filterMaxModelsContainer = document.createDocumentFragment();
    const maxShownNumber = document.createElement("span");
    filterMaxModelsContainer.appendChild(maxShownNumber);
    maxShownNumber.classList.add("filter-max-number");
    maxShownNumber.title = Lng.gt("MaxShownEntrys");
    maxShownNumber.textContent = maxShownModels.maxShownModels.toString();
    return { container: filterMaxModelsContainer, number: maxShownNumber };
  }
  /**
   * Creates the mouse wheel events for the max shown models number presentation span.
   * @param component The component to register the events to.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   */
  static createNumberPresentationEvent(component, maxShownNumber, maxShownModels, batchSize, onMaxShownModelsChange) {
    component.registerDomEvent(maxShownNumber, "wheel", async (event) => {
      event.preventDefault();
      if (event.deltaY > 0) {
        this.changeValue("minus", maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
      } else {
        this.changeValue("plus", maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
      }
    }, { passive: false });
  }
  /**
   * Creates a symbol for the max shown models number.
   * @param type The type of the symbol. Can be `plus` or `minus`.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param component The component to register the events to.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   * @returns The created symbol as `DocumentFragment`.
   * @remarks - The symbol is a `HTMLAnchorElement`.
   * - The symbol has the class `plus-batch-button` or `minus-batch-button`.
   */
  static createSymbol(type2, maxShownNumber, component, maxShownModels, batchSize, onMaxShownModelsChange) {
    const filterMaxModelsContainer = document.createDocumentFragment();
    const maxShownDocMinus = document.createElement("a");
    filterMaxModelsContainer.appendChild(maxShownDocMinus);
    maxShownDocMinus.classList.add(`${type2}-batch-button`);
    maxShownDocMinus.title = type2;
    maxShownDocMinus.href = "#";
    (0, import_obsidian6.setIcon)(maxShownDocMinus, type2);
    component.registerDomEvent(maxShownDocMinus, "click", async (event) => {
      this.changeValue(type2, maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange);
    });
    return filterMaxModelsContainer;
  }
  /**
   * Changes the max shown models number.
   * @param type The type of the symbol. Can be `plus` or `minus`.
   * @param maxShownModels The container for the max shown models number.
   * @param batchSize The batch size to add or subtract.
   * @param maxShownNumber The presentation span of the max shown models number.
   * @param onMaxShownModelsChange The callback to call when the max shown models number changes.
   */
  static changeValue(type2, maxShownModels, batchSize, maxShownNumber, onMaxShownModelsChange) {
    if (type2 === "minus") {
      if (maxShownModels.maxShownModels >= batchSize) {
        maxShownModels.maxShownModels -= maxShownModels.maxShownModels % batchSize || batchSize;
      } else {
        maxShownModels.maxShownModels = 0;
      }
    } else {
      maxShownModels.maxShownModels += batchSize - maxShownModels.maxShownModels % batchSize;
    }
    maxShownNumber.textContent = maxShownModels.maxShownModels.toString();
    onMaxShownModelsChange();
  }
};

// src/libs/BlockRenderComponents/InnerComponents/SearchInput.ts
var SearchInput = class {
  /**
   * Creates a new search input component.
   * @param component The component to register the events to.
   * @param onSearch The callback to call when the search box value changes. Passes the search box value and the key that was pressed.
   * @returns The created search input component as `DocumentFragment`.
   * @remarks - The search input component consists of a label, an input sizer and a search box.
   * - CSS classes:
   *  - `filter-search` - The container of the search input component.
   *  - `filter-text` - The label of the search input component.
   *  - `search-box-sizer` - The sizer of the search input component.
   *  - `search-box` - The search box of the search input component.
   */
  static create(component, onSearch) {
    const logger = Global.getInstance().logger;
    const headerItemContainer = document.createDocumentFragment();
    const searchLabelContainer = document.createElement("div");
    headerItemContainer.appendChild(searchLabelContainer);
    searchLabelContainer.classList.add("filter-search");
    SearchInput.createSearchLabel(searchLabelContainer);
    const searchBoxSizer = SearchInput.createSearchBoxSizer(searchLabelContainer);
    const searchBoxInput = SearchInput.createSearchBoxInput(searchBoxSizer);
    component.registerDomEvent(searchBoxInput, "input", async (event) => {
      this.setSearchBoxSizerValue(searchBoxSizer, searchBoxInput.value);
    });
    component.registerDomEvent(searchBoxInput, "keydown", async (event) => {
      let value = searchBoxInput.value;
      try {
        value = await onSearch(searchBoxInput.value, event.key);
      } catch (error) {
        logger.error("The `onSearch` callback threw an error!", error);
      } finally {
        this.setSearchBoxSizerValue(searchBoxSizer, value);
        this.setSearchBoxInputValue(searchBoxInput, value);
      }
    });
    return headerItemContainer;
  }
  /**
   * Creates the search label.
   * @param searchLabelContainer The container to append the label to. 
   * @remarks - The label is a `HTMLSpanElement`.
   * - The label text is `Search`-value of the translation.
   * - The label element has the class `filter-text`.
   */
  static createSearchLabel(searchLabelContainer) {
    const filterLabel = document.createElement("span");
    searchLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-text");
    filterLabel.textContent = Lng.gt("Search") + ":";
  }
  /**
   * Creates the search box sizer.
   * @param searchLabelContainer The container to append the sizer to.
   * @returns The created search box sizer.
   * @remarks - The sizer is a `HTMLLabelElement`.
   * - The sizer has the class `search-box-sizer`.
   */
  static createSearchBoxSizer(searchLabelContainer) {
    const searchBoxSizer = document.createElement("label");
    searchLabelContainer.appendChild(searchBoxSizer);
    searchBoxSizer.classList.add("search-box-sizer");
    return searchBoxSizer;
  }
  /**
   * Creates the search box input.
   * @param searchBoxSizer The container to append the input to.
   * @returns The created search box input.
   * @remarks - The input is a `HTMLInputElement`.
   * - The input type is `text`.
   * - The input placeholder is `Search`-value of the translation.
   * - The input element has the class `search-box`.
   */
  static createSearchBoxInput(searchBoxSizer) {
    const searchBoxInput = document.createElement("input");
    searchBoxSizer.appendChild(searchBoxInput);
    searchBoxInput.classList.add("search-box");
    searchBoxInput.type = "text";
    searchBoxInput.placeholder = Lng.gt("Search");
    searchBoxInput.value = "";
    return searchBoxInput;
  }
  /**
   * Sets the search box sizer value.
   * @param searchBoxSizer The search box sizer to set the value to.
   * @param value The value to set.
   */
  static setSearchBoxSizerValue(searchBoxSizer, value) {
    searchBoxSizer.dataset.value = "_" + value + "_";
  }
  /**
   * Sets the search box input value.
   * @param searchBoxInput The search box input to set the value to.
   * @param value The value to set.
   */
  static setSearchBoxInputValue(searchBoxInput, value) {
    searchBoxInput.value = value;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/DocumentComponents.ts
var import_obsidian10 = require("obsidian");

// src/libs/EditableDataView/Components/BaseComponent.ts
var import_obsidian7 = require("obsidian");
var BaseComponent = class {
  //#endregion
  constructor(component) {
    this.cancelButton = void 0;
    this.saveButton = void 0;
    this.component = component;
    this.shippingContainer = document.createElement("div");
    this.shippingContainer.classList.add("editable-data-view", "container");
  }
  get container() {
    return this.shippingContainer;
  }
  /**
   * Creates the base structure of the component.
   * @param editabilityEnabled If `true`, the component will be created to allow editing.
   * @tutorial Run this methode in the `finalize`-methode of the child class before creating your elements.
   */
  createBaseStructure(editabilityEnabled = this.editabilityEnabled) {
    this.presentationContainer = document.createElement("div");
    this.presentationContainer.classList.add("editable-data-view", "presentation-container");
    this.shippingContainer.appendChild(this.presentationContainer);
    if (editabilityEnabled && (import_obsidian7.Platform.isMobile ? Global.getInstance().settings.mobile : true)) {
      this.buttonContainer = document.createElement("div");
      this.buttonContainer.classList.add("editable-data-view", "button-container");
      this.createEditButton();
      this.shippingContainer.appendChild(this.buttonContainer);
    }
  }
  /**
   * Creates the `edit` button and adds it to the `buttonContainer`.
   */
  createEditButton() {
    this.editButton = document.createElement("button");
    this.buttonContainer.appendChild(this.editButton);
    this.editButton.classList.add("editable-data-view");
    this.editButton.classList.add("button");
    (0, import_obsidian7.setIcon)(this.editButton, "pen");
    this.component.registerDomEvent(this.editButton, "click", () => this.enableEditMode());
  }
  /**
   * Creates the `save` and `cancel` buttons and the `input` container and adds them to the `buttonContainer`.
   */
  createComponentsForEdit() {
    this.dataInputContainer = document.createElement("div");
    this.dataInputContainer.classList.add("editable-data-view", "data-input-container", "hidden");
    this.shippingContainer.insertBefore(this.dataInputContainer, this.presentationContainer);
    this.cancelButton = document.createElement("button");
    this.buttonContainer.insertAfter(this.cancelButton, this.editButton);
    this.cancelButton.classList.add("editable-data-view");
    this.cancelButton.classList.add("button");
    this.cancelButton.classList.add("hidden");
    (0, import_obsidian7.setIcon)(this.cancelButton, "x");
    this.component.registerDomEvent(this.cancelButton, "click", () => this.disableEditMode());
    this.saveButton = document.createElement("button");
    this.buttonContainer.insertAfter(this.saveButton, this.cancelButton);
    this.saveButton.classList.add("editable-data-view");
    this.saveButton.classList.add("button");
    this.saveButton.classList.add("hidden");
    (0, import_obsidian7.setIcon)(this.saveButton, "check");
    this.component.registerDomEvent(this.saveButton, "click", () => this.saveChanges());
  }
  /**
   * This method is called after the final configuration of the component.
   */
  finalize() {
    var _a;
    this.createBaseStructure();
    (_a = this.onFinalize) == null ? void 0 : _a.call(this);
  }
  /**
   * This method is called when the user clicks on the `edit` button.
   * It should switch the component to edit mode and 
   * create the `save` and `cancel` buttons if not already created.
   * @remarks You can call this methode to simulate a click on the `edit` button.
   */
  enableEditMode() {
    var _a, _b;
    if (!this.cancelButton || !this.saveButton) {
      this.createComponentsForEdit();
      (_a = this.onFirstEdit) == null ? void 0 : _a.call(this);
    }
    if (this.cancelButton && this.saveButton) {
      this.presentationContainer.classList.add("hidden");
      this.dataInputContainer.classList.remove("hidden");
      this.cancelButton.classList.remove("hidden");
      this.saveButton.classList.remove("hidden");
      this.editButton.classList.add("hidden");
      (_b = this.onEnableEditCallback) == null ? void 0 : _b.call(this);
    }
  }
  /**
   * This method is called when the user clicks on the `cancel` button or 
   * after the `saveChanges`-methode is clicked.
   * @remarks You can call this methode to simulate a click on the `cancel` button.
   */
  disableEditMode() {
    var _a;
    if (this.cancelButton && this.saveButton) {
      this.presentationContainer.classList.remove("hidden");
      this.dataInputContainer.classList.add("hidden");
      this.cancelButton.classList.add("hidden");
      this.saveButton.classList.add("hidden");
      this.editButton.classList.remove("hidden");
      (_a = this.onDisableEditCallback) == null ? void 0 : _a.call(this);
    }
  }
  /**
   * This method is called when the user clicks on the `save` button.
   * @remarks You can call this methode to simulate a click on the `save` button.
   */
  async saveChanges() {
    var _a;
    if (this.cancelButton && this.saveButton) {
      await ((_a = this.onSaveCallback) == null ? void 0 : _a.call(this));
      this.disableEditMode();
    }
  }
};

// src/libs/EditableDataView/Components/DateComponent.ts
var DateComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = formator;
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("date-presentation");
    this.presentationSpan.textContent = this._onPresentation ? this._onPresentation(this._value) : this._value;
  }
  buildInput() {
    this.input = document.createElement("input");
    this.dataInputContainer.appendChild(this.input);
    this.input.type = "date";
    this.input.title = this._title;
    this.input.classList.add("editable-data-view");
    this.input.classList.add("date-input");
  }
  enableEdit() {
    this.input.value = this._value ? this._value : "";
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    this.presentationSpan.textContent = this._onPresentation ? this._onPresentation(this._value) : this._value;
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/DropdownComponent.ts
var DropdownComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  get _selectedOption() {
    const selectedOption = this._options.find((o) => o.value === this._value);
    if (selectedOption)
      return selectedOption;
    return { value: this._value, text: this._value };
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the options of the component.
   * @param options The options to set.
   * @returns The component itself.
   */
  setOptions(options) {
    this._options = options;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks - The formator is called when the component change in `not-edit` mode.
   * - `value` is the value of the selected option. (Not the text!)
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      const { text, html } = formator(value);
      if (html) {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.appendChild(html);
      } else {
        this.presentationSpan.textContent = text;
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks - The saver is called when the component save button is clicked.
   * - `value` is the value of the selected option. (Not the text!)
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  enableOptions() {
    const optionFound = this._options.find((o) => o.value === this._value);
    if (!optionFound) {
      const optionElement = document.createElement("option");
      optionElement.value = this._value;
      optionElement.textContent = `${this._value} (not in options)`;
      this.select.appendChild(optionElement);
    }
    this._options.forEach((option) => {
      const optionElement = document.createElement("option");
      optionElement.value = option.value;
      optionElement.textContent = option.text;
      this.select.appendChild(optionElement);
    });
  }
  disableOptions() {
    this.select.innerHTML = "";
  }
  //#region Base Callbacks
  build() {
    var _a;
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("text-presentation");
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._selectedOption.value);
  }
  buildInput() {
    this.select = document.createElement("select");
    this.dataInputContainer.appendChild(this.select);
    this.select.title = this._title;
    this.select.classList.add("editable-data-view");
    this.select.classList.add("select-input");
  }
  enableEdit() {
    this.enableOptions();
    this.select.value = this._value ? this._value : "";
    this.select.focus();
  }
  disableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._selectedOption.value);
    this.disableOptions();
  }
  async save() {
    var _a;
    this._value = this.select.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/LinkComponent.ts
var LinkComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.linkType = "external";
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets suggestions for the input element.
   * @param suggestions The suggestions to set.
   * @returns The component itself.
   */
  setSuggestions(suggestions) {
    this._suggestions = suggestions;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the type of the link.
   * @param type The type to set. Can be `tag`, `file` or `external`.
   * @returns The component itself.
   */
  setLinkType(type2) {
    this.linkType = type2;
    return this;
  }
  /**
   * Sets the suggester of the component.
   * @param suggester The suggester to set.
   * @returns The component itself.
   * @remarks The suggester is called when the user types in the input element.
   */
  setSuggester(suggester) {
    this._suggester = suggester;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      const linkContent = formator(value);
      this.link.href = linkContent.href;
      if (linkContent.html) {
        this.link.innerHTML = "";
        this.link.appendChild(linkContent.html);
      } else
        this.link.textContent = linkContent.text;
      switch (this.linkType) {
        case "tag":
          break;
        case "file":
          this.link.setAttribute("aria-label", linkContent.href);
          this.link.setAttribute("data-href", linkContent.href);
          break;
        case "external":
          break;
      }
      if (this.input && this.label) {
        this.input.value = linkContent.text ? linkContent.text : "";
        this.label.dataset.value = linkContent.text ? linkContent.text : this._placeholder ? this._placeholder : "";
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  setSuggestionsList(suggestions) {
    if (!this.datalist)
      return;
    this.datalist.innerHTML = "";
    suggestions.forEach((suggestion) => {
      const option = document.createElement("option");
      option.value = suggestion;
      this.datalist.appendChild(option);
    });
  }
  //#region Base Callbacks
  build() {
    var _a;
    this.link = document.createElement("a");
    this.presentationContainer.appendChild(this.link);
    this.link.title = this._title;
    this.link.classList.add("editable-data-view");
    this.link.classList.add("link-presentation");
    switch (this.linkType) {
      case "tag":
        this.link.classList.add("tag");
        this.link.target = "_blank";
        this.link.rel = "noopener";
        break;
      case "file":
        this.link.setAttribute("data-tooltip-position", "top");
        this.link.classList.add("internal-link");
        this.link.target = "_blank";
        this.link.rel = "noopener";
        break;
      case "external":
        break;
    }
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("text-input-sizer");
    this.input = document.createElement("input");
    this.label.appendChild(this.input);
    this.input.classList.add("editable-data-view");
    this.input.classList.add("text-input");
    this.input.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.input, "input", () => {
      this.label.dataset.value = this.input.value ? this.input.value : this._placeholder ? this._placeholder : "";
      if (this._suggester && this.label.dataset.value !== this._placeholder && this.label.dataset.value !== "")
        this.setSuggestionsList(this._suggester(this.input.value));
    });
    this.component.registerDomEvent(this.input, "keydown", (event) => {
      if (event.key === "Enter") {
        this.saveChanges();
      } else if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
    if (this._suggestions && this._suggestions.length > 0 || this._suggester) {
      const id = Math.random().toString(36).substring(2, 10);
      this.input.setAttribute("list", id);
      this.datalist = document.createElement("datalist");
      this.datalist.id = id;
      this.input.appendChild(this.datalist);
      this.setSuggestionsList(this._suggestions);
    }
  }
  enableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    var _a;
    (_a = this._onPresentation) == null ? void 0 : _a.call(this, this._value);
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/TextComponent.ts
var import_obsidian8 = require("obsidian");
var TextComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets suggestions for the input element.
   * @param suggestions The suggestions to set.
   * @returns The component itself.
   */
  setSuggestions(suggestions) {
    this._suggestions = suggestions;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the suggester of the component.
   * @param suggester The suggester to set.
   * @returns The component itself.
   * @remarks The suggester is called when the user types in the input element.
   */
  setSuggester(suggester) {
    this._suggester = suggester;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      this.presentationSpan.textContent = await formator(this._value);
    };
    return this;
  }
  /**
   * Sets the markdown formator of the component.
   * @param path The path of the file to resolve internal links.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   * - The custom formator is ignored if this method is called!
   */
  setRenderMarkdown(path = "") {
    this._onMarkdownPresentation = (value) => {
      if (Helper.isPossiblyMarkdown(value)) {
        const app = Global.getInstance().app;
        return import_obsidian8.MarkdownRenderer.render(app, value, this.presentationSpan, path, this.component);
      } else {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.textContent = value;
        return Promise.resolve();
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  setSuggestionsList(suggestions) {
    if (!this.datalist)
      return;
    this.datalist.innerHTML = "";
    if (!suggestions)
      return;
    suggestions.forEach((suggestion) => {
      const option = document.createElement("option");
      option.value = suggestion;
      this.datalist.appendChild(option);
    });
  }
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("text-presentation");
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("text-input-sizer");
    this.input = document.createElement("input");
    this.label.appendChild(this.input);
    this.input.classList.add("editable-data-view");
    this.input.classList.add("text-input");
    this.input.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.input, "input", () => {
      this.label.dataset.value = this.input.value ? this.input.value : this._placeholder ? this._placeholder : "";
      if (this._suggester && this.label.dataset.value !== this._placeholder && this.label.dataset.value !== "")
        this.setSuggestionsList(this._suggester(this.input.value));
    });
    this.component.registerDomEvent(this.input, "keydown", (event) => {
      if (event.key === "Enter") {
        this.saveChanges();
      } else if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
    if (this._suggestions && this._suggestions.length > 0 || this._suggester) {
      const id = Math.random().toString(36).substring(2, 10);
      this.input.setAttribute("list", id);
      this.datalist = document.createElement("datalist");
      this.datalist.id = id;
      this.input.appendChild(this.datalist);
      this.setSuggestionsList(this._suggestions);
    }
  }
  enableEdit() {
    this.input.value = this._value ? this._value : "";
    this.label.dataset.value = this._value ? this._value : this._placeholder ? this._placeholder : "";
    this.input.focus();
    this.input.select();
  }
  disableEdit() {
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  async save() {
    var _a;
    this._value = this.input.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/Components/TextareaComponent.ts
var import_obsidian9 = require("obsidian");
var TextareaComponent = class extends BaseComponent {
  //#endregion
  constructor(component) {
    super(component);
    //#region base properties
    this.editabilityEnabled = false;
    this.onFinalize = this.build;
    this.onFirstEdit = this.buildInput;
    this.onEnableEditCallback = this.enableEdit;
    this.onSaveCallback = this.save;
    this.onDisableEditCallback = this.disableEdit;
  }
  //#region Configuration methods
  /**
   * Enables the editability of the component.
   * @returns The component itself.
   */
  enableEditability() {
    this.editabilityEnabled = true;
    return this;
  }
  /**
   * Sets the value of the component.
   * @param value The value to set.
   * @returns The component itself.
   */
  setValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Sets the placeholder of the input element.
   * @param placeholder The placeholder to set.
   * @returns The component itself.
   */
  setPlaceholder(placeholder) {
    this._placeholder = placeholder;
    return this;
  }
  /**
   * Sets the title of the component.
   * @param title The title to set.
   * @returns The component itself.
   */
  setTitle(title) {
    this._title = title;
    return this;
  }
  /**
   * Sets the formator of the component.
   * @param formator The formator to set.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   */
  setFormator(formator) {
    this._onPresentation = async (value) => {
      this.presentationSpan.textContent = await formator(this._value);
    };
    return this;
  }
  /**
   * Sets the markdown formator of the component.
   * @param path The path of the file to resolve internal links.
   * @returns The component itself.
   * @remarks The formator is called when the component change in `not-edit` mode.
   * - The custom formator is ignored if this method is called!
   */
  setRenderMarkdown(path = "") {
    this._onMarkdownPresentation = (value) => {
      if (Helper.isPossiblyMarkdown(value)) {
        const app = Global.getInstance().app;
        return import_obsidian9.MarkdownRenderer.render(app, value, this.presentationSpan, path, this.component);
      } else {
        this.presentationSpan.innerHTML = "";
        this.presentationSpan.textContent = value;
        return Promise.resolve();
      }
    };
    return this;
  }
  /**
   * Sets the saver of the component.
   * @param callback The saver to set.
   * @returns The component itself.
   * @remarks The saver is called when the component save button is clicked.
   */
  onSave(callback) {
    this._onSave = callback;
    return this;
  }
  //#endregion
  //#region Base Callbacks
  build() {
    this.presentationSpan = document.createElement("span");
    this.presentationContainer.appendChild(this.presentationSpan);
    this.presentationSpan.title = this._title;
    this.presentationSpan.classList.add("editable-data-view");
    this.presentationSpan.classList.add("textarea-presentation");
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  buildInput() {
    this.label = document.createElement("label");
    this.label.title = this._title;
    this.dataInputContainer.appendChild(this.label);
    this.label.classList.add("editable-data-view");
    this.label.classList.add("textarea-input-sizer");
    this.textarea = document.createElement("textarea");
    this.label.appendChild(this.textarea);
    this.textarea.classList.add("editable-data-view");
    this.textarea.classList.add("textarea-input");
    this.textarea.placeholder = this._placeholder ? this._placeholder : "";
    this.component.registerDomEvent(this.textarea, "input", () => {
      this.label.dataset.value = this.textarea.value ? this.textarea.value : this._placeholder ? this._placeholder : "";
    });
    this.component.registerDomEvent(this.textarea, "keydown", (event) => {
      if (event.key === "Escape") {
        this.disableEditMode();
      }
    });
  }
  enableEdit() {
    this.textarea.value = this._value ? this._value : "";
    this.label.dataset.value = this._value ? this._value : this._placeholder ? this._placeholder : "";
    this.textarea.focus();
    this.textarea.select();
  }
  disableEdit() {
    if (this._onMarkdownPresentation) {
      this.presentationSpan.textContent = null;
      this._onMarkdownPresentation(this._value);
    } else if (this._onPresentation) {
      this._onPresentation(this._value);
    } else {
      this.presentationSpan.textContent = this._value;
    }
  }
  async save() {
    var _a;
    this._value = this.textarea.value;
    await ((_a = this._onSave) == null ? void 0 : _a.call(this, this._value));
  }
  //#endregion
};

// src/libs/EditableDataView/EditableDataView.ts
var EditableDataView = class {
  constructor(container, component) {
    this.attributesList = {};
    this._container = container;
    this.component = component;
  }
  addText(configure) {
    const textComponent = new TextComponent(this.component);
    configure(textComponent);
    textComponent.finalize();
    this._container.append(textComponent.container);
    return this;
  }
  addTextarea(configure) {
    const textComponent = new TextareaComponent(this.component);
    configure(textComponent);
    textComponent.finalize();
    this._container.append(textComponent.container);
    return this;
  }
  addLink(configure) {
    const linkComponent = new LinkComponent(this.component);
    configure(linkComponent);
    linkComponent.finalize();
    this._container.appendChild(linkComponent.container);
    return this;
  }
  addDate(configure) {
    const dateComponent = new DateComponent(this.component);
    configure(dateComponent);
    dateComponent.finalize();
    this._container.append(dateComponent.container);
    return this;
  }
  addDropdown(configure) {
    const dropdownComponent = new DropdownComponent(this.component);
    configure(dropdownComponent);
    dropdownComponent.finalize();
    this._container.appendChild(dropdownComponent.container);
    return this;
  }
};

// src/libs/BlockRenderComponents/InnerComponents/DocumentComponents.ts
var DocumentComponents = class {
  static createCellTags(tagContainer, component, tags) {
    tags.forEach((tag) => {
      new EditableDataView(tagContainer, component).addLink(
        (link) => link.setValue(tag).setTitle("Tag").setLinkType("tag").setFormator((value) => {
          return { href: `#${value}`, text: `#${value}` };
        })
      );
    });
  }
  static createCellSummary(documentModel, component, summaryRelatedFiles) {
    const description = documentModel.getDescription();
    new EditableDataView(summaryRelatedFiles, component).addTextarea(
      (textarea) => textarea.setValue(description).setTitle("Summary").enableEditability().setRenderMarkdown().onSave((value) => {
        documentModel.data.description = value;
        return Promise.resolve();
      })
    );
  }
  static createRelatedFilesList(relatedFilesList, component, documentModel, noneDocSymbol, dateFormatShort) {
    const relatedFiles = documentModel.relatedFiles;
    if (!relatedFiles || relatedFiles.length === 0)
      return;
    const container = document.createElement("div");
    relatedFilesList.appendChild(container);
    container.classList.add("related-files-container");
    const breakLine = document.createElement("hr");
    container.appendChild(breakLine);
    breakLine.classList.add("related-files-breakline");
    const list = document.createElement("ul");
    container.appendChild(list);
    list.classList.add("related-files-list");
    relatedFiles.forEach((relatedFile) => {
      const listEntry = document.createElement("li");
      list.append(listEntry);
      const gridContainer = document.createElement("div");
      listEntry.appendChild(gridContainer);
      gridContainer.classList.add("grid-container");
      const iconContainer = document.createElement("span");
      gridContainer.append(iconContainer);
      iconContainer.classList.add("icon-container");
      const inputOutputState = relatedFile.getInputOutputState();
      let listIconString = noneDocSymbol;
      if (inputOutputState === "Input") {
        listIconString = "corner-left-down";
      } else if (inputOutputState === "Output") {
        listIconString = "corner-right-up";
      }
      (0, import_obsidian10.setIcon)(iconContainer, listIconString);
      const metadataContainer = document.createElement("span");
      gridContainer.append(metadataContainer);
      metadataContainer.classList.add("metadata-file-container");
      const metadataFragment = document.createDocumentFragment();
      this.createCellMetadatalink(metadataFragment, component, relatedFile);
      metadataContainer.appendChild(metadataFragment);
      const dateContainer = document.createElement("span");
      gridContainer.append(dateContainer);
      dateContainer.classList.add("date-container");
      new EditableDataView(dateContainer, component).addDate((date) => {
        var _a;
        return date.setValue((_a = relatedFile.data.date) != null ? _a : "na").setTitle("Document Date").setFormator(
          (value) => Helper.formatDate(value, Helper.formatDate(value, dateFormatShort))
        );
      });
      const textContainer = document.createElement("span");
      gridContainer.append(textContainer);
      textContainer.classList.add("data-container");
      const linkFragment = document.createDocumentFragment();
      this.createCellFileLink(linkFragment, component, relatedFile, false);
      textContainer.append(linkFragment);
    });
  }
  static createCellSenderRecipient(documentModel, component, models) {
    var _a, _b;
    const senderRecipient = document.createDocumentFragment();
    const container = document.createElement("div");
    senderRecipient.appendChild(container);
    container.classList.add("senderRecipient");
    const inputOutputState = documentModel.getInputOutputState();
    const sender = (_a = documentModel.data.sender) != null ? _a : null;
    const recipient = (_b = documentModel.data.recipient) != null ? _b : null;
    if (sender && inputOutputState !== "Output") {
      const senderContainer = document.createElement("div");
      senderContainer.classList.add("container");
      const fromTo = document.createElement("span");
      fromTo.classList.add("fromTo");
      fromTo.textContent = Lng.gt("From");
      senderContainer.appendChild(fromTo);
      const name = document.createElement("span");
      name.classList.add("name");
      senderContainer.appendChild(name);
      this.createEDVSenderRecipient(name, component, sender, "Sender", (value) => {
        documentModel.data.sender = value;
        return Promise.resolve();
      }, models);
      container.appendChild(senderContainer);
    }
    if (recipient && inputOutputState !== "Input") {
      const recipientContainer = document.createElement("div");
      recipientContainer.classList.add("container");
      const fromTo = document.createElement("span");
      fromTo.classList.add("fromTo");
      fromTo.textContent = Lng.gt("To");
      recipientContainer.appendChild(fromTo);
      const name = document.createElement("span");
      name.classList.add("name");
      recipientContainer.appendChild(name);
      this.createEDVSenderRecipient(name, component, recipient, "Recipient", (value) => {
        documentModel.data.recipient = value;
        return Promise.resolve();
      }, models);
      container.appendChild(recipientContainer);
    }
    return senderRecipient;
  }
  static createEDVSenderRecipient(name, component, value, title, onSaveCallback, models = []) {
    return new EditableDataView(name, component).addText(
      (text) => text.setValue(value).setTitle(title).enableEditability().setSuggester((inputValue) => {
        const suggestions = models.flatMap((document2) => [document2.data.sender, document2.data.recipient]).filter((v) => v != null).filter((v, index, self2) => self2.indexOf(v) === index).filter((v) => v.includes(inputValue)).sort().splice(0, 10);
        return suggestions;
      }).onSave((newValue) => onSaveCallback(newValue))
    );
  }
  static createCellFileLink(fileLink, component, documentModel, editability = true) {
    const fileCache = Global.getInstance().fileCache;
    const app = Global.getInstance().app;
    new EditableDataView(fileLink, component).addLink((link) => {
      var _a;
      link.setValue((_a = documentModel.data.title) != null ? _a : "").setTitle(Lng.gt("PDFFile")).setLinkType("file").setFormator((value) => {
        var _a2, _b;
        const baseFileData = Helper.extractDataFromWikilink(documentModel.data.file);
        const baseFile = fileCache.findFileByName((_a2 = baseFileData.filename) != null ? _a2 : "");
        let baseFilePath = (_b = baseFileData.filename) != null ? _b : "";
        if (baseFile && baseFile instanceof import_obsidian10.TFile) {
          baseFilePath = baseFile.path;
        }
        let docFragment = void 0;
        if (Helper.isPossiblyMarkdown(value)) {
          docFragment = document.createDocumentFragment();
          const div = document.createElement("div");
          import_obsidian10.MarkdownRenderer.render(app, value != null ? value : "", div, "", component);
          docFragment.appendChild(div);
        }
        return { href: `${baseFilePath}`, text: `${value}`, html: docFragment };
      });
      if (editability) {
        link.enableEditability().onSave((value) => {
          documentModel.data.title = value;
          return Promise.resolve();
        });
      }
    });
  }
  static createCellMetadatalink(metadataLink, component, documentModel) {
    const settings = Global.getInstance().settings;
    new EditableDataView(metadataLink, component).addLink((link) => link.setValue(documentModel.file.path).setTitle("Open metadata file").setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        let iconString = "x-circle";
        if (documentModel.data.hide === true) {
          iconString = settings.documentSettings.hideSymbol;
        } else {
          if (documentModel.data.subType === "Cluster") {
            iconString = settings.documentSettings.clusterSymbol;
          } else {
            iconString = settings.documentSettings.symbol;
          }
        }
        (0, import_obsidian10.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
};

// src/libs/BlockRenderComponents/InnerComponents/GeneralComponents.ts
var import_obsidian11 = require("obsidian");
var GeneralComponents = class {
  /**
   * Creates a link to the file at `path` with the `corospondingSymbol` as icon.
   * @param container The container to append the link to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param type The type of the file.
   * @param corospondingSymbol The corosponding symbol for the file type.
   */
  static createMetadataLink(container, component, path, type2, corospondingSymbol) {
    new EditableDataView(container, component).addLink((link) => link.setValue(path).setTitle(Lng.gt(type2 != null ? type2 : "File")).setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        const iconString = corospondingSymbol;
        (0, import_obsidian11.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
  static createCellDate(date, component, title, format, onRead, onWrite) {
    new EditableDataView(date, component).addDate(
      (date2) => date2.setValue(onRead()).setTitle(title).enableEditability().setFormator((value) => Helper.formatDate(value, format)).onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      })
    );
  }
};

// src/libs/BlockRenderComponents/DocumentBlockRenderComponent.ts
var DocumentBlockRenderComponent = class extends TableBlockRenderComponent {
  constructor(settings) {
    super(settings);
    this.settings = {
      tags: [],
      docSymbol: this.global.settings.documentSettings.symbol,
      hideDocSymbol: this.global.settings.documentSettings.hideSymbol,
      clusterSymbol: this.global.settings.documentSettings.clusterSymbol,
      noneDocSymbol: "diamond",
      filter: ["Documents"],
      maxDocuments: this.global.settings.defaultMaxShow,
      search: void 0,
      batchSize: 8,
      sleepBetweenBatches: 10
    };
    /**
     * The table headers.
     * @remarks The table headers are used to create the table.
     * 
     */
    this.tableHeaders = [
      { text: Lng.gt("DocumentType"), headerClass: [], columnClass: ["dont-decorate-link", "font-medium"] },
      { text: Lng.gt("Date"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Subject"), headerClass: [], columnClass: [] },
      { text: Lng.gt("SendRecip"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Content"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("DeliveryDate"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Tags"), headerClass: [], columnClass: ["tags"] }
    ];
    this.parseSettings();
  }
  build() {
    return super.build();
  }
  /**
   * Draws the component and adds the documents to the table.
   * @returns A promise which is resolved when the documents are added to the table.
   * @remarks - Calls the `super.draw` method.
   * - Calls the `buildTable` method.
   * - Calls the `buildHeader` method.
   * - Calls the `addDocumentsToTable` method.
   */
  async draw() {
    const startTime = Date.now();
    const documentsPromise = this.getModels();
    await super.draw();
    await this.buildTable();
    await this.buildHeader();
    this.grayOutHeader();
    this.models = await documentsPromise;
    DocumentModel.sortDocumentsByDateDesc(this.models);
    await this.addDocumentsToTable();
    this.normalizeHeader();
    const endTime = Date.now();
    this.logger.debug(`Redraw Documents (for ${this.models.length} Docs.) runs for ${endTime - startTime}ms`);
  }
  /**
   * Builds the header.
   * @remarks - The header is saved in the `headerContainer` property.
   * - Creates the `filter container`.
   * - Creates the `filter label`.
   * - Creates the `filter buttons`: `Documents`, `HideDocuments` and `Cluster`.
   * - Creates the `max documents input`.
   * - Creates the `search box`.
   */
  async buildHeader() {
    const headerFilterButtons = document.createElement("div");
    this.headerContainer.appendChild(headerFilterButtons);
    headerFilterButtons.classList.add("header-item");
    headerFilterButtons.classList.add("filter-symbols");
    const filterLabelContainer = document.createElement("div");
    headerFilterButtons.appendChild(filterLabelContainer);
    const filterLabel = document.createElement("span");
    filterLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-symbol");
    filterLabel.textContent = Lng.gt("Filter");
    const documentFilterButton = FilterButton.create(
      this.component,
      "Documents",
      this.settings.docSymbol,
      this.settings.filter.includes("Documents"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(documentFilterButton);
    const hideDocumentFilterButton = FilterButton.create(
      this.component,
      "HideDocuments",
      this.settings.hideDocSymbol,
      this.settings.filter.includes("HideDocuments"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(hideDocumentFilterButton);
    const clusterFilterButton = FilterButton.create(
      this.component,
      "Cluster",
      this.settings.clusterSymbol,
      this.settings.filter.includes("Cluster"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(clusterFilterButton);
    const maxDocuments = MaxShownModelsInput.create(
      this.component,
      this.settings.maxDocuments,
      this.global.settings.defaultMaxShow,
      this.onMaxDocumentsChange.bind(this)
    );
    headerFilterButtons.appendChild(maxDocuments);
    const searchBox = SearchInput.create(
      this.component,
      this.onSearch.bind(this)
    );
    headerFilterButtons.appendChild(searchBox);
  }
  /**
   * This method is called when the filter button is clicked.
   * @param type The type of the filter button.
   * @param status The new status of the filter button.
   * @remarks Runs the `onFilter` method.
   */
  async onFilterButton(type2, status) {
    if (this.settings.filter.includes(type2)) {
      this.settings.filter = this.settings.filter.filter((v) => v !== type2);
    } else {
      this.settings.filter.push(type2);
    }
    this.onFilter();
  }
  /**
   * This method is called when the max documents input is changed.
   * @param maxDocuments The new max documents value.
   * @returns A promise which is resolved when the documents are filtered.
   * @remarks Runs the `onFilter` method.
   */
  async onMaxDocumentsChange(maxDocuments) {
    this.settings.maxDocuments = maxDocuments;
    this.onFilter();
    return void 0;
  }
  /**
   * This method is called when the search box is used.
   * @param search The search text.
   * @param key The key that was pressed.
   * @returns The search text.
   * @remarks - If the `Enter` key was pressed, the search is applied.
   * - If the `Escape` key was pressed, the search is reset.
   * - After the search is applied, the `onFilter` method is called.
   */
  async onSearch(search, key) {
    if (key === "Enter") {
      if (search !== "") {
        this.settings.search = Search.parseSearchText(search);
        this.onFilter();
      } else {
        this.settings.search = void 0;
        this.onFilter();
      }
    } else if (key === "Escape") {
      this.settings.search = void 0;
      this.onFilter();
      return "";
    }
    return search;
  }
  /**
   * Filters the documents and shows/hides them in the table.
   * @remarks - The documents are filtered by the `filter` setting,
   * searched by the `search` setting 
   * and the number of documents is limited by the `maxDocuments` if no search is applied.
   */
  async onFilter() {
    this.grayOutHeader();
    const batchSize = this.settings.batchSize;
    const sleepBetweenBatches = this.settings.sleepBetweenBatches;
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = this.models[i];
      const rowUid = this.getUID(document2);
      let hide = this.getHideState(document2, void 0);
      this.logger.trace(`Document ${rowUid} is hidden by state: ${hide}`);
      this.logger.trace(`Visible rows: ${visibleRows}; Max shown Docs: ${this.settings.maxDocuments}`);
      if (visibleRows >= this.settings.maxDocuments) {
        hide = true;
      }
      this.logger.trace(`Document ${rowUid} is hidden by max counts: ${hide}`);
      if (hide) {
        rows.push({ rowUid, hidden: true });
      } else {
        visibleRows++;
        rows.push({ rowUid, hidden: false });
      }
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.logger.trace(`Batchsize reached. Change rows: ${rows.length}`);
        await this.table.changeShowHideStateRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
    this.normalizeHeader();
  }
  /**
   * Adds the documents to the table.
   * @param batchSize The batch size.
   * @param sleepBetweenBatches The sleep time between the batches.
   * @returns A promise which is resolved when the documents are added to the table.
   * @remarks - The documents are added to the table in batches.
   * - The batch size is defined in the `batchSize` parameter. Default is `settings.batchSize`.
   * - The sleep time between the batches is defined in the `sleepBetweenBatches` parameter. Default is `settings.sleepBetweenBatches`.
   */
  async addDocumentsToTable(batchSize = this.settings.batchSize, sleepBetweenBatches = this.settings.sleepBetweenBatches) {
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let rowPromise = void 0;
    if (documentsLength > 0) {
      rowPromise = this.generateTableRow(this.models[0]);
    } else {
      return;
    }
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = i + 1 < documentsLength ? this.models[i + 1] : null;
      const row = await rowPromise;
      rowPromise = document2 ? this.generateTableRow(document2) : void 0;
      if (row && !row.hidden) {
        if (visibleRows < this.settings.maxDocuments) {
          visibleRows++;
        } else {
          row.hidden = true;
        }
      }
      if (row)
        rows.push(row);
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.table.addRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
  }
  /**
   * Generates a table row for the given document.
   * @param documentModel The document to generate the table row for.
   * @returns The generated table row.
   */
  async generateTableRow(documentModel) {
    const rowClassList = [];
    const rowData = [];
    const rowUid = this.getUID(documentModel);
    const metadataLink = document.createDocumentFragment();
    rowData.push(metadataLink);
    DocumentComponents.createCellMetadatalink(
      metadataLink,
      this.component,
      documentModel
    );
    const date = document.createDocumentFragment();
    rowData.push(date);
    GeneralComponents.createCellDate(
      date,
      this.component,
      Lng.gt("DocumentDate"),
      this.global.settings.dateFormat,
      () => {
        var _a;
        return (_a = documentModel.data.date) != null ? _a : "na";
      },
      async (value) => documentModel.data.date = value
    );
    const fileLink = document.createDocumentFragment();
    rowData.push(fileLink);
    DocumentComponents.createCellFileLink(
      fileLink,
      this.component,
      documentModel
    );
    const senderRecipient = DocumentComponents.createCellSenderRecipient(
      documentModel,
      this.component,
      this.models
    );
    rowData.push(senderRecipient);
    const summaryRelatedFiles = document.createDocumentFragment();
    rowData.push(summaryRelatedFiles);
    DocumentComponents.createCellSummary(
      documentModel,
      this.component,
      summaryRelatedFiles
    );
    DocumentComponents.createRelatedFilesList(
      summaryRelatedFiles,
      this.component,
      documentModel,
      this.settings.noneDocSymbol,
      this.global.settings.dateFormatShort
    );
    const deliveryDate = document.createDocumentFragment();
    rowData.push(deliveryDate);
    GeneralComponents.createCellDate(
      deliveryDate,
      this.component,
      Lng.gt("DeliveryDate"),
      this.global.settings.dateFormat,
      () => {
        var _a;
        return (_a = documentModel.data.dateOfDelivery) != null ? _a : "na";
      },
      async (value) => documentModel.data.dateOfDelivery = value
    );
    const tags = document.createDocumentFragment();
    rowData.push(tags);
    DocumentComponents.createCellTags(
      tags,
      this.component,
      documentModel.getTags()
    );
    const hide = this.getHideState(documentModel, void 0);
    const row = {
      rowUid,
      rowData,
      rowClassList,
      hidden: hide
    };
    return row;
  }
  getHideState(document2, maxVisibleRows) {
    let searchResult = false;
    let maxRows = false;
    if (this.settings.search) {
      const text = document2.toString();
      searchResult = Search.applySearchLogic(this.settings.search, text);
    }
    if (maxVisibleRows && maxVisibleRows > 0) {
      const rowStats = this.table.getRowStats();
      maxRows = rowStats.visibleRows >= maxVisibleRows;
    }
    const hide = this.determineHideState(document2);
    if (searchResult && !hide) {
      return false;
    } else if (this.settings.search) {
      return true;
    } else if (!searchResult) {
      return maxRows || hide;
    }
    return hide;
  }
  /**
   * Determines if the document should be hidden.
   * @param document The document to check.
   * @returns If the document should be hidden returns `true`, else `false`.
   * @remarks - The document is hidden if the `filter` setting not includes the document type.
   */
  determineHideState(document2) {
    if (this.settings.filter.includes("Documents") && document2.data.hide !== true && document2.data.subType !== "Cluster") {
      return false;
    }
    if (this.settings.filter.includes("Cluster") && document2.data.subType === "Cluster") {
      return false;
    }
    if (this.settings.filter.includes("HideDocuments") && document2.data.hide === true) {
      return false;
    }
    return true;
  }
  /**
   * Builds the table.
   * @remarks - The table is saved in the `table` property.
   * - The table is appended to the `tableContainer`.
   * - The table has the CSS class `document-table`.
   * - The table has the headers from the `tableHeaders` property.
   */
  async buildTable() {
    this.table = new Table(this.tableHeaders, "document-table", void 0);
    this.tableContainer.appendChild(this.table.data.table);
  }
  redraw() {
    return super.redraw();
  }
  /**
   * Parses the settings given by the user per YAML in code block.
   * @remarks The settings are parsed and saved in the `settings` property.
   * @remarks Settings:
   * - `tags`: Can be `all`, `this` or a list of tags.
   * `this` means the tags of the current document.
   * - `maxDocuments`: The maximum number of documents to show on same time.
   * - `filter`: Must be an array. You can add the following values:
   * `Documents`, `HideDocuments` or `Cluster`. The values present the document types.
   * All values that are in the array are shown.
   */
  parseSettings() {
    this.processorSettings.options.forEach((option) => {
      var _a, _b;
      switch (option.label) {
        case "tags":
          if (option.value === "all") {
            this.settings.tags = [];
          } else if (option.value === "this") {
            const tags = (_b = (_a = this.processorSettings) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags;
            if (Array.isArray(tags)) {
              this.settings.tags.push(...tags);
            } else if (tags) {
              this.settings.tags.push(tags);
            }
          } else {
            this.settings.tags = option.value;
          }
          break;
        case "maxDocuments":
          this.settings.maxDocuments = option.value;
          break;
        case "filter":
          this.settings.filter = option.value;
          break;
        default:
          break;
      }
    });
  }
  /**
   * Returns the models for the table.
   * @returns The models for the table.
   * @remarks - The models are the documents.
   * - The documents are filtered by the `tags` setting. 
   * If tags are empty, all documents are returned, 
   * else only the documents with the tags are returned.
   */
  async getModels() {
    const templateFolder = this.global.settings.templateFolder;
    const allDocumentFiles = this.metadataCache.filter((file) => {
      var _a, _b;
      const defaultFilter = ((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) === "Metadata" && file.file.path !== this.processorSettings.source && !file.file.path.startsWith(templateFolder);
      if (this.settings.tags.length > 0) {
        const tagFilter = Helper.isTagIncluded(this.settings.tags, (_b = file.metadata.frontmatter) == null ? void 0 : _b.tags);
        return defaultFilter && tagFilter;
      }
      return defaultFilter;
    });
    const documents = allDocumentFiles.map((file) => new DocumentModel(file.file));
    return documents;
  }
  /**
   * Returns if the file tags are included in the setting tags.
   * @param fileTags The tags of the file.
   * @param settingTags The tags of the settings.
   * @returns If the file tags are included in the setting tags.
   * @remarks - If the file tags are an array, one tag must be included.
   * - If the file tags are a string, the string must be included.
   */
  isTagIncluded(fileTags, settingTags) {
    if (Array.isArray(fileTags)) {
      return fileTags.some((tag) => settingTags.includes(tag));
    } else {
      return settingTags.includes(fileTags);
    }
  }
};

// src/models/PrjTaskManagementModel.ts
var PrjTaskManagementModel = class extends BaseModel {
  constructor(file, ctor) {
    super(file, ctor, void 0);
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
  }
  toString() {
    var _a, _b, _c, _d, _e;
    let allText = (_a = this.data.title) != null ? _a : "";
    allText += (_b = this.data.description) != null ? _b : "";
    allText += (_c = this.data.status) != null ? _c : "";
    allText += (_d = this.data.due) != null ? _d : "";
    allText += (_e = this.data.tags) != null ? _e : "";
    return allText;
  }
  getCorospondingSymbol() {
    switch (this.data.type) {
      case "Topic":
        return this.global.settings.prjSettings.topicSymbol;
      case "Project":
        return this.global.settings.prjSettings.projectSymbol;
      case "Task":
        return this.global.settings.prjSettings.taskSymbol;
      default:
        return "x-circle";
    }
  }
  /**
   * Sorts the models by urgency descending
   * @param documents Array of DocumentModels to sort
   * @remarks This function sorts the array in place
   * @see {@link statusToNumber}
   * @see {@link calculateUrgency}
   * @see {@link getLastHistoryDate}
   * @remarks The sorting is done as follows:
   * - If both are `done`, sort by last history entry
   * - If `a` or `b` is done, sort it lower
   * - Both are not done, sort by urgency
   * - Both have the same urgency, sort by status
   * - Both have the same status, sort by priority
   * - Fallback to sorting by last history entry
   * - Fallback to stop sorting
   */
  static sortModelsByUrgency(models) {
    models.sort((a, b) => {
      var _a, _b;
      const aDate = PrjTaskManagementModel.getLastHistoryDate(a);
      const bDate = PrjTaskManagementModel.getLastHistoryDate(b);
      if (a.data.status === "Done" && b.data.status === "Done") {
        if (aDate && bDate) {
          return bDate.getTime() - aDate.getTime();
        }
      }
      if (a.data.status === "Done") {
        return 1;
      }
      if (b.data.status === "Done") {
        return -1;
      }
      const aUrgency = PrjTaskManagementModel.calculateUrgency(a);
      const bUrgency = PrjTaskManagementModel.calculateUrgency(b);
      if (bUrgency !== aUrgency) {
        return bUrgency - aUrgency;
      }
      const aStatus = PrjTaskManagementModel.statusToNumber(a.data.status);
      const bStatus = PrjTaskManagementModel.statusToNumber(b.data.status);
      if (bStatus !== aStatus) {
        return bStatus - aStatus;
      }
      const aPrirority = (_a = a.data.priority) != null ? _a : 0;
      const bPrirority = (_b = b.data.priority) != null ? _b : 0;
      if (bPrirority !== aPrirority) {
        return bPrirority - aPrirority;
      }
      if (aDate && bDate) {
        return bDate.getTime() - aDate.getTime();
      }
      return 0;
    });
  }
  /**
   * Returns the number representation of the status.
   * @param status The status to convert.
   * @returns The number representation of the status.
   * @remarks The number representation is:
   * - `Active` = 3
   * - `Waiting` = 2
   * - `Later` = 1
   * - `Someday` = 0
   * - `undefined` = -1
   */
  static statusToNumber(status) {
    switch (status) {
      case "Active":
        return 3;
      case "Waiting":
        return 2;
      case "Later":
        return 1;
      case "Someday":
        return 0;
      default:
        return -1;
    }
  }
  getUrgency() {
    return PrjTaskManagementModel.calculateUrgency(this);
  }
  /**
   * Returns the tags of the model as an array of strings
   * @returns Array of strings containing the tags
   */
  getTags() {
    const tags = this.data.tags;
    let formattedTags = [];
    if (tags && typeof tags === "string") {
      formattedTags = [tags];
    } else if (Array.isArray(tags)) {
      formattedTags = [...tags];
    }
    return formattedTags;
  }
  /**
   * Calculates the urgency of the model.
   * @param model The model to calculate the urgency for.
   * @returns The urgency of the model.
   * @remarks The urgency is calculated as follows:
   * - No `status` or `status` is 'Done' = -2
   * - No `due` or `status` is 'Someday' = -1
   * - Due date is today or in the past = 3
   * - Due date is in the next 3 days = 2
   * - Due date is in the next 7 days = 1
   * - Due date is in more the future = 0
   */
  static calculateUrgency(model) {
    if (!model.data.status || model.data.status === "Done") {
      return -2;
    }
    if (!model.data.due || model.data.status === "Someday") {
      return -1;
    }
    const dueDate = new Date(model.data.due);
    dueDate.setHours(0, 0, 0, 0);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const differenceInDays = (dueDate.getTime() - today.getTime()) / (1e3 * 3600 * 24);
    let urgency = 0;
    if (differenceInDays <= 0) {
      urgency = 3;
    } else if (differenceInDays <= 3) {
      urgency = 2;
    } else if (differenceInDays <= 7) {
      urgency = 1;
    }
    return urgency;
  }
  /**
   * Returns the date of the last history entry.
   * @param model The model to get the last history entry date from.
   * @returns The date of the last history entry.
   */
  static getLastHistoryDate(model) {
    if (model.data.history && Array.isArray(model.data.history) && model.data.history.length > 0) {
      const history = model.data.history;
      const lastEntry = history[history.length - 1];
      return new Date(lastEntry.date);
    } else {
      return null;
    }
  }
};

// src/types/TopicData.ts
var TopicData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/TopicModel.ts
var TopicModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, TopicData);
  }
};

// src/types/ProjectData.ts
var ProjectData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/ProjectModel.ts
var ProjectModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, ProjectData);
  }
};

// src/types/TaskData.ts
var TaskData = class {
  constructor(data) {
    this.title = data.title !== void 0 ? data.title : void 0;
    this.description = data.description !== void 0 ? data.description : void 0;
    this.status = data.status !== void 0 ? data.status : void 0;
    this.priority = data.priority !== void 0 ? data.priority : void 0;
    this.energy = data.energy !== void 0 ? data.energy : void 0;
    this.due = data.due !== void 0 ? data.due : void 0;
    this.tags = data.tags !== void 0 ? data.tags : void 0;
    this.type = data.type !== void 0 ? data.type : void 0;
    this.subType = data.subType !== void 0 ? data.subType : void 0;
    this.history = data.history !== void 0 ? data.history : void 0;
  }
};

// src/models/TaskModel.ts
var TaskModel = class extends PrjTaskManagementModel {
  constructor(file) {
    super(file, TaskData);
  }
};

// src/libs/BlockRenderComponents/InnerComponents/ProjectComponents.ts
var import_obsidian12 = require("obsidian");
var ProjectComponents = class {
  /**
   * Creates a title component.
   * @param container The container to append the title to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param onRead On read callback. Returns the title.
   * @param onWrite On write callback. Passes the new title.
   */
  static createTitle(container, component, path, onRead, onWrite) {
    new EditableDataView(container, component).addLink((link) => {
      link.setValue(onRead()).setTitle(Lng.gt("Title")).setPlaceholder(Lng.gt("Title")).setLinkType("file").setFormator((value) => {
        let title = document.createDocumentFragment();
        if (value === "") {
          (0, import_obsidian12.setIcon)(title, "paperclip");
        } else if (Helper.isPossiblyMarkdown(value)) {
          const div = document.createElement("div");
          import_obsidian12.MarkdownRenderer.render(Global.getInstance().app, value != null ? value : "", div, "", component);
          title.appendChild(div);
        } else {
          title = void 0;
        }
        return { href: `${path}`, text: `${value}`, html: title };
      }).enableEditability().onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      });
    });
  }
  /**
   * Creates a summary component.
   * @param container The container to append the summary to.
   * @param component The component to register the events to.
   * @param description The description to display.
   * @param onWrite On write callback. Passes the new description.
   */
  static createSummary(container, component, description, onWrite) {
    new EditableDataView(container, component).addText(
      (text) => text.setValue(description).setTitle(Lng.gt("Description")).setPlaceholder(Lng.gt("Description")).enableEditability().setRenderMarkdown().onSave((value) => {
        onWrite(value);
        return Promise.resolve();
      })
    );
  }
  static createStatus(container, component, onRead, onWrite) {
    new EditableDataView(container, component).addDropdown((dropdown) => dropdown.setOptions([
      { value: "Active", text: Lng.gt("StatusActive") },
      { value: "Waiting", text: Lng.gt("StatusWaiting") },
      { value: "Later", text: Lng.gt("StatusLater") },
      { value: "Someday", text: Lng.gt("StatusSomeday") },
      { value: "Done", text: Lng.gt("StatusDone") }
    ]).setTitle(Lng.gt("Status")).setValue(onRead()).onSave(async (value) => {
      onWrite(value);
    }).enableEditability().setFormator(
      (value) => {
        const status = value;
        let iconString;
        switch (status) {
          case "Active":
            iconString = "\u26A1";
            break;
          case "Waiting":
            iconString = "\u23F3";
            break;
          case "Later":
            iconString = "\u{1F51C}";
            break;
          case "Someday":
            iconString = "\u{1F4C6}";
            break;
          case "Done":
            iconString = "\u2714\uFE0F";
            break;
          default:
            iconString = "\u26A1";
            break;
        }
        return { text: `${iconString}`, html: void 0 };
      }
    ));
  }
  /**
   * Creates a priority component.
   * @param container The container to append the priority to.
   * @param component The component to register the events to.
   * @param onRead On read callback. Returns the priority.
   * @param onWrite On write callback. Passes the new priority.
   */
  static createPriority(container, component, onRead, onWrite) {
    new EditableDataView(container, component).addDropdown((dropdown) => dropdown.setOptions([
      { value: "3", text: Lng.gt("HighPriority") },
      { value: "2", text: Lng.gt("MediumPriority") },
      { value: "1", text: Lng.gt("LowPriority") },
      { value: "0", text: Lng.gt("NoPriority") }
    ]).setTitle(Lng.gt("PriorityText")).setValue(onRead()).onSave(async (value) => {
      onWrite(value);
    }).enableEditability().setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        let iconString;
        switch (value) {
          case "3":
            iconString = "signal";
            break;
          case "2":
            iconString = "signal-medium";
            break;
          case "1":
            iconString = "signal-low";
            break;
          case "0":
            iconString = "signal-zero";
            break;
          default:
            iconString = "signal-zero";
            break;
        }
        (0, import_obsidian12.setIcon)(icon, iconString);
        return { text: `${value}`, html: icon };
      }
    ));
  }
  /**
   * Creates a link to the file at `path` with the `corospondingSymbol` as icon.
   * @param container The container to append the link to.
   * @param component The component to register the events to.
   * @param path The path to the file.
   * @param type The type of the file.
   * @param corospondingSymbol The corosponding symbol for the file type.
   */
  static createMetadataLink(container, component, path, type2, corospondingSymbol) {
    new EditableDataView(container, component).addLink((link) => link.setValue(path).setTitle(Lng.gt(type2 != null ? type2 : "File")).setLinkType("file").setFormator(
      (value) => {
        const icon = document.createDocumentFragment();
        const iconString = corospondingSymbol;
        (0, import_obsidian12.setIcon)(icon, iconString);
        return { href: `${value}`, text: `${value}`, html: icon };
      }
    ));
  }
  /**
   * Creates a span with the to `urgency` corresponding urgency symbol.
   * @param container The container to append the span to.
   * @param urgency The urgency to get the symbol for. (3 to -2)
   * @see {@link PrjTaskManagementModel.calculateUrgency}
   * @see {@link UrgencySymbols}
   */
  static createTraficLight(container, urgency) {
    const traficLightSpan = document.createElement("span");
    container.appendChild(traficLightSpan);
    let iconString;
    switch (urgency) {
      case 3:
        iconString = "\u{1F534}";
        break;
      case 2:
        iconString = "\u{1F7E0}";
        break;
      case 1:
        iconString = "\u{1F7E1}";
        break;
      case 0:
        iconString = "\u{1F7E2}";
        break;
      case -1:
        iconString = "\u{1F7E2}";
        break;
      case -2:
        iconString = "\u{1F535}";
        break;
      default:
        iconString = "\u{1F534}";
        break;
    }
    traficLightSpan.textContent = iconString;
  }
};

// src/libs/BlockRenderComponents/ProjectBlockRenderComponent.ts
var ProjectBlockRenderComponent = class extends TableBlockRenderComponent {
  constructor(settings) {
    super(settings);
    this.settings = {
      tags: [],
      topicSymbol: this.global.settings.prjSettings.topicSymbol,
      projectSymbol: this.global.settings.prjSettings.projectSymbol,
      taskSymbol: this.global.settings.prjSettings.taskSymbol,
      otherSymbol: "diamond",
      filter: ["Topic", "Project", "Task"],
      maxDocuments: this.global.settings.defaultMaxShow,
      search: void 0,
      batchSize: 8,
      sleepBetweenBatches: 10
    };
    /**
     * The table headers.
     * @remarks The table headers are used to create the table.
     * 
     */
    this.tableHeaders = [
      { text: Lng.gt("DocumentType"), headerClass: [], columnClass: ["dont-decorate-link", "font-medium"] },
      { text: Lng.gt("TraficLight"), headerClass: [], columnClass: [] },
      { text: Lng.gt("Description"), headerClass: [], columnClass: ["dont-decorate-link", "link-weight-bold"] },
      { text: Lng.gt("Priority"), headerClass: [], columnClass: [] },
      { text: Lng.gt("DueDate"), headerClass: [], columnClass: ["font-xsmall"] },
      { text: Lng.gt("Status"), headerClass: [], columnClass: [] },
      { text: Lng.gt("Tags"), headerClass: [], columnClass: ["tags"] }
    ];
    this.parseSettings();
  }
  build() {
    return super.build();
  }
  async draw() {
    const startTime = Date.now();
    const getModelsPromise = this.getModels();
    await super.draw();
    await this.buildTable();
    await this.buildHeader();
    this.grayOutHeader();
    this.models = await getModelsPromise;
    PrjTaskManagementModel.sortModelsByUrgency(this.models);
    await this.addDocumentsToTable();
    this.normalizeHeader();
    const endTime = Date.now();
    this.logger.debug(`Redraw (for ${this.models.length} Models) runs for ${endTime - startTime}ms`);
  }
  async buildTable() {
    this.table = new Table(this.tableHeaders, "project-table", void 0);
    this.tableContainer.appendChild(this.table.data.table);
  }
  async buildHeader() {
    const headerFilterButtons = document.createElement("div");
    this.headerContainer.appendChild(headerFilterButtons);
    headerFilterButtons.classList.add("header-item");
    headerFilterButtons.classList.add("filter-symbols");
    const filterLabelContainer = document.createElement("div");
    headerFilterButtons.appendChild(filterLabelContainer);
    const filterLabel = document.createElement("span");
    filterLabelContainer.appendChild(filterLabel);
    filterLabel.classList.add("filter-symbol");
    filterLabel.textContent = Lng.gt("Filter");
    const topicFilterButton = FilterButton.create(
      this.component,
      "Topic",
      this.settings.topicSymbol,
      this.settings.filter.includes("Topic"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(topicFilterButton);
    const projectFilterButton = FilterButton.create(
      this.component,
      "Project",
      this.settings.projectSymbol,
      this.settings.filter.includes("Project"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(projectFilterButton);
    const taskFilterButton = FilterButton.create(
      this.component,
      "Task",
      this.settings.taskSymbol,
      this.settings.filter.includes("Task"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(taskFilterButton);
    const doneFilterButton = FilterButton.create(
      this.component,
      "Done",
      "check-square",
      this.settings.filter.includes("Done"),
      this.onFilterButton.bind(this)
    );
    headerFilterButtons.appendChild(doneFilterButton);
    const maxDocuments = MaxShownModelsInput.create(
      this.component,
      this.settings.maxDocuments,
      this.global.settings.defaultMaxShow,
      this.onMaxDocumentsChange.bind(this)
    );
    headerFilterButtons.appendChild(maxDocuments);
    const searchBox = SearchInput.create(
      this.component,
      this.onSearch.bind(this)
    );
    headerFilterButtons.appendChild(searchBox);
  }
  async addDocumentsToTable(batchSize = this.settings.batchSize, sleepBetweenBatches = this.settings.sleepBetweenBatches) {
    let sleepPromise = Promise.resolve();
    const modelsLength = this.models.length;
    const rows = [];
    let rowPromise = void 0;
    if (modelsLength > 0) {
      rowPromise = this.generateTableRow(this.models[0]);
    } else {
      return;
    }
    let visibleRows = 0;
    for (let i = 0; i < modelsLength; i++) {
      const model = i + 1 < modelsLength ? this.models[i + 1] : null;
      const row = await rowPromise;
      rowPromise = model ? this.generateTableRow(model) : void 0;
      if (row && !row.hidden) {
        if (visibleRows < this.settings.maxDocuments) {
          visibleRows++;
        } else {
          row.hidden = true;
        }
      }
      if (row)
        rows.push(row);
      if (i !== 0 && i % batchSize === 0 || i === modelsLength - 1) {
        await sleepPromise;
        this.table.addRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
  }
  async generateTableRow(model) {
    var _a;
    const rowClassList = [];
    const rowData = [];
    const rowUid = this.getUID(model);
    const metadataLink = document.createDocumentFragment();
    rowData.push(metadataLink);
    GeneralComponents.createMetadataLink(
      metadataLink,
      this.component,
      model.file.path,
      model.data.type,
      model.getCorospondingSymbol()
    );
    const traficLight = document.createDocumentFragment();
    rowData.push(traficLight);
    ProjectComponents.createTraficLight(traficLight, model.getUrgency());
    const titleAndSummary = document.createDocumentFragment();
    rowData.push(titleAndSummary);
    ProjectComponents.createTitle(
      titleAndSummary,
      this.component,
      model.file.path,
      () => {
        var _a2;
        return (_a2 = model.data.title) != null ? _a2 : "";
      },
      async (value) => model.data.title = value
    );
    const lineBreak = document.createElement("br");
    titleAndSummary.appendChild(lineBreak);
    ProjectComponents.createSummary(
      titleAndSummary,
      this.component,
      (_a = model.data.description) != null ? _a : "",
      (value) => model.data.description = value
    );
    const priority = document.createDocumentFragment();
    rowData.push(priority);
    ProjectComponents.createPriority(
      priority,
      this.component,
      () => {
        var _a2, _b;
        return (_b = (_a2 = model.data.priority) == null ? void 0 : _a2.toString()) != null ? _b : "0";
      },
      async (value) => model.data.priority = value
    );
    const dueDate = document.createDocumentFragment();
    rowData.push(dueDate);
    GeneralComponents.createCellDate(
      dueDate,
      this.component,
      Lng.gt("DueDate"),
      this.global.settings.dateFormat,
      () => {
        var _a2;
        return (_a2 = model.data.due) != null ? _a2 : "na";
      },
      async (value) => model.data.due = value
    );
    const status = document.createDocumentFragment();
    rowData.push(status);
    ProjectComponents.createStatus(
      status,
      this.component,
      () => {
        var _a2;
        return (_a2 = model.data.status) != null ? _a2 : "Active";
      },
      async (value) => model.data.status = value
    );
    const tags = document.createDocumentFragment();
    rowData.push(tags);
    DocumentComponents.createCellTags(
      tags,
      this.component,
      model.getTags()
    );
    const hide = this.getHideState(model, this.settings.maxDocuments);
    const row = {
      rowUid,
      rowData,
      rowClassList,
      hidden: hide
    };
    return row;
  }
  async onFilterButton(type2, status) {
    if (this.settings.filter.includes(type2)) {
      this.settings.filter = this.settings.filter.filter((v) => v !== type2);
    } else {
      this.settings.filter.push(type2);
    }
    this.onFilter();
  }
  async onMaxDocumentsChange(maxDocuments) {
    this.settings.maxDocuments = maxDocuments;
    this.onFilter();
    return void 0;
  }
  async onSearch(search, key) {
    if (key === "Enter") {
      if (search !== "") {
        this.settings.search = Search.parseSearchText(search);
        this.onFilter();
      } else {
        this.settings.search = void 0;
        this.onFilter();
      }
    } else if (key === "Escape") {
      this.settings.search = void 0;
      this.onFilter();
      return "";
    }
    return search;
  }
  async onFilter() {
    this.grayOutHeader();
    const batchSize = this.settings.batchSize;
    const sleepBetweenBatches = this.settings.sleepBetweenBatches;
    let sleepPromise = Promise.resolve();
    const documentsLength = this.models.length;
    const rows = [];
    let visibleRows = 0;
    for (let i = 0; i < documentsLength; i++) {
      const document2 = this.models[i];
      const rowUid = this.getUID(document2);
      let hide = this.getHideState(document2, void 0);
      if (visibleRows >= this.settings.maxDocuments) {
        hide = true;
      }
      if (hide) {
        rows.push({ rowUid, hidden: true });
      } else {
        visibleRows++;
        rows.push({ rowUid, hidden: false });
      }
      if (i !== 0 && i % batchSize === 0 || i === documentsLength - 1) {
        await sleepPromise;
        this.table.changeShowHideStateRows(rows);
        rows.length = 0;
        sleepPromise = Helper.sleep(sleepBetweenBatches);
      }
    }
    this.normalizeHeader();
  }
  getHideState(model, maxVisibleRows) {
    let searchResult = false;
    let maxRows = false;
    if (!this.settings.filter.includes("Done") && model.data.status === "Done") {
      return true;
    }
    if (this.settings.search) {
      const text = model.toString();
      searchResult = Search.applySearchLogic(this.settings.search, text);
    }
    if (maxVisibleRows && maxVisibleRows > 0) {
      const rowStats = this.table.getRowStats();
      maxRows = rowStats.visibleRows >= maxVisibleRows;
    }
    const hide = this.determineHideState(model);
    if (searchResult && !hide) {
      return false;
    } else if (this.settings.search) {
      return true;
    } else if (!searchResult) {
      return maxRows || hide;
    }
    return hide;
  }
  determineHideState(model) {
    if (this.settings.filter.includes("Topic") && model.data.type === "Topic") {
      return false;
    }
    if (this.settings.filter.includes("Project") && model.data.type === "Project") {
      return false;
    }
    if (this.settings.filter.includes("Task") && model.data.type === "Task") {
      return false;
    }
    return true;
  }
  parseSettings() {
    this.processorSettings.options.forEach((option) => {
      var _a, _b;
      switch (option.label) {
        case "tags":
          if (option.value === "all") {
            this.settings.tags = [];
          } else if (option.value === "this") {
            const tags = (_b = (_a = this.processorSettings) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags;
            if (Array.isArray(tags)) {
              this.settings.tags.push(...tags);
            } else if (tags) {
              this.settings.tags.push(tags);
            }
          } else {
            this.settings.tags = option.value;
          }
          break;
        case "maxDocuments":
          this.settings.maxDocuments = option.value;
          break;
        case "filter":
          this.settings.filter = option.value;
          break;
        default:
          break;
      }
    });
  }
  async getModels() {
    const templateFolder = this.global.settings.templateFolder;
    const allModelFiles = this.metadataCache.filter((file) => {
      var _a, _b, _c, _d;
      const defaultFilter = (((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) === "Topic" || ((_b = file.metadata.frontmatter) == null ? void 0 : _b.type) === "Project" || ((_c = file.metadata.frontmatter) == null ? void 0 : _c.type) === "Task") && file.file.path !== this.processorSettings.source && !file.file.path.startsWith(templateFolder);
      if (this.settings.tags.length > 0) {
        const tagFilter = Helper.isTagIncluded(this.settings.tags, (_d = file.metadata.frontmatter) == null ? void 0 : _d.tags);
        return defaultFilter && tagFilter;
      }
      return defaultFilter;
    });
    const models = [];
    allModelFiles.forEach((file) => {
      var _a;
      switch ((_a = file.metadata.frontmatter) == null ? void 0 : _a.type) {
        case "Topic":
          models.push(new TopicModel(file.file));
          break;
        case "Project":
          models.push(new ProjectModel(file.file));
          break;
        case "Task":
          models.push(new TaskModel(file.file));
          break;
        default:
          break;
      }
    });
    return models;
  }
};

// src/libs/MarkdownBlockProcessor.ts
var MarkdownBlockProcessor = class {
  static async parseSource(source, el, ctx) {
    var _a;
    const startTime = Date.now();
    const parent = el.closest("div.cm-preview-code-block.cm-embed-block.markdown-rendered");
    if (parent) {
      parent.classList.remove("cm-embed-block");
      parent.addClass("prj-block");
    }
    const global2 = Global.getInstance();
    await global2.metadataCache.waitForCacheReady();
    const cache = global2.metadataCache.Cache;
    const logger = global2.logger;
    const cmp = new import_obsidian13.MarkdownRenderChild(el);
    ctx.addChild(cmp);
    cmp.load();
    const blockContainer = document.createElement("div");
    el.append(blockContainer);
    blockContainer.classList.add("prj-block-container");
    const setting = load(source);
    setting.source = ctx.sourcePath;
    setting.frontmatter = (_a = cache.filter((file) => file.file.path === ctx.sourcePath).first()) == null ? void 0 : _a.metadata.frontmatter;
    setting.container = blockContainer;
    setting.ctx = ctx;
    if (setting) {
      switch (setting.type) {
        case "Documents":
          const documentBlock = new DocumentBlockRenderComponent(setting);
          await documentBlock.build();
          break;
        case "Tasks":
        case "Projects":
        case "Topics":
          const projectBlock = new ProjectBlockRenderComponent(setting);
          await projectBlock.build();
          break;
        case "Debug":
          console.log("Debug Mode");
          console.log(`Settings: ${setting}`);
          break;
        default:
          break;
      }
      const endTime = Date.now();
      logger.debug(`MarkdownBlockProcessor runs for ${endTime - startTime}ms`);
    }
  }
};

// src/classes/SettingsTab.ts
var import_obsidian14 = require("obsidian");
var SettingTab = class extends import_obsidian14.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian14.Setting(containerEl).setName("Log Level").setDesc("The log level to use").addDropdown((dropdown) => dropdown.addOptions({
      "none": "none",
      "trace": "trace",
      "debug": "debug",
      "info": "info",
      "warn": "warn",
      "error": "error"
    }).setValue(this.plugin.settings.logLevel).onChange(async (value) => {
      this.plugin.settings.logLevel = value;
      Global.getInstance().logger.setLogLevel(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Performance Mode (only Mobile)").setDesc("The performance of the plugin is affected by this setting. If disabled, the editability of the blocks is disabled. No effect on Desktop!").addToggle((toggle) => toggle.setValue(this.plugin.settings.mobile).onChange(async (value) => {
      this.plugin.settings.mobile = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("Localisation");
    new import_obsidian14.Setting(containerEl).setName("Language").setDesc("The language to use").addText((text) => text.setPlaceholder("en | de").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Date Format").setDesc("The Date format to use").addText((text) => text.setPlaceholder("DD.MM.YYYY").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Short date format").setDesc("The short Date format to use").addText((text) => text.setPlaceholder("DD.MM.YY").setValue(this.plugin.settings.dateFormatShort).onChange(async (value) => {
      this.plugin.settings.dateFormatShort = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Base Tag").setDesc("The Base Tag for all Elements").addText((text) => text.setPlaceholder("#YourBaseTag").setValue(this.plugin.settings.baseTag).onChange(async (value) => {
      this.plugin.settings.baseTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Template Folder").setDesc("The Folder where all Templates are stored").addText((text) => text.setPlaceholder("YourTemplateFolder").setValue(this.plugin.settings.templateFolder).onChange(async (value) => {
      this.plugin.settings.templateFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("User Information");
    new import_obsidian14.Setting(containerEl).setName("User: Name").setDesc("Your name").addText((text) => text.setPlaceholder("Your name").setValue(this.plugin.settings.user.name).onChange(async (value) => {
      this.plugin.settings.user.name = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Short name").setDesc("Your name short name").addText((text) => text.setPlaceholder("Your name shortened").setValue(this.plugin.settings.user.shortName).onChange(async (value) => {
      this.plugin.settings.user.shortName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Email").setDesc("Your E-Mail adress").addText((text) => text.setPlaceholder("Your email").setValue(this.plugin.settings.user.email).onChange(async (value) => {
      this.plugin.settings.user.email = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Street").setDesc("Your street").addText((text) => text.setPlaceholder("Your street").setValue(this.plugin.settings.user.street).onChange(async (value) => {
      this.plugin.settings.user.street = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: City").setDesc("Your city").addText((text) => text.setPlaceholder("Your city").setValue(this.plugin.settings.user.city).onChange(async (value) => {
      this.plugin.settings.user.city = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Zip Code").setDesc("Your zip code").addText((text) => text.setPlaceholder("Your zip").setValue(this.plugin.settings.user.zip).onChange(async (value) => {
      this.plugin.settings.user.zip = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("User: Country").setDesc("Your country").addText((text) => text.setPlaceholder("Your country").setValue(this.plugin.settings.user.country).onChange(async (value) => {
      this.plugin.settings.user.country = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setHeading().setName("Document Settings");
    new import_obsidian14.Setting(containerEl).setName("Default Max Show").setDesc("The default max show for Table Entrys").addText((text) => text.setPlaceholder("200").setValue(this.plugin.settings.defaultMaxShow.toString()).onChange(async (value) => {
      this.plugin.settings.defaultMaxShow = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Document Symbol").setDesc("The Symbol for regular Documents").addText((text) => text.setPlaceholder("file-text").setValue(this.plugin.settings.documentSettings.symbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.symbol = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Hide Symbol").setDesc("The Symbol for hidden Documents").addText((text) => text.setPlaceholder("file-minus-2").setValue(this.plugin.settings.documentSettings.hideSymbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.hideSymbol = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Cluster Symbol").setDesc("The Symbol for Cluster Documents").addText((text) => text.setPlaceholder("library").setValue(this.plugin.settings.documentSettings.clusterSymbol).onChange(async (value) => {
      this.plugin.settings.documentSettings.clusterSymbol = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types/PrjSettings.ts
var DEFAULT_SETTINGS = {
  logLevel: "none",
  mobile: false,
  language: "en",
  dateFormat: "DD.MM.YYYY",
  dateFormatShort: "DD.MM.YY",
  user: {
    "name": "",
    "shortName": "",
    "email": "",
    "street": "",
    "city": "",
    "zip": "",
    "country": ""
  },
  "defaultMaxShow": 200,
  "batchSizeShow": 25,
  documentSettings: {
    "symbol": "file-text",
    "hideSymbol": "file-minus-2",
    "clusterSymbol": "library"
  },
  prjSettings: {
    "topicSymbol": "album",
    "projectSymbol": "layout-list",
    "taskSymbol": "clipboard"
  },
  baseTag: "PRJ",
  templateFolder: "Vorlagen/"
};

// src/libs/ContextMenus/GetMetadata.ts
var import_obsidian15 = require("obsidian");
var GetMetadata = class {
  constructor() {
    this.app = Global.getInstance().app;
    this.logger = Global.getInstance().logger;
    this.plugin = Global.getInstance().plugin;
    this.metadataCache = Global.getInstance().metadataCache.Cache;
    this.eventsRegistered = false;
    this.bindContextMenu = this.onContextMenu.bind(this);
    this.logger.debug("Initializing GetMetadata");
    this.registerEvents();
    this.registerCommands();
  }
  static getInstance() {
    if (!GetMetadata.instance) {
      GetMetadata.instance = new GetMetadata();
    }
    return GetMetadata.instance;
  }
  /**
   * Deconstructs the 'GetMetadata' events
   */
  static deconstructor() {
    if (this.instance && this.instance.eventsRegistered) {
      this.instance.logger.trace("Deconstructing 'GetMetadata' events");
      this.instance.app.workspace.off("file-menu", this.instance.bindContextMenu);
      this.instance.eventsRegistered = false;
    } else {
      this.instance.logger.trace("No 'GetMetadata' events to deconstruct");
    }
  }
  /**
   * Registers the 'GetMetadata' events
   */
  registerEvents() {
    if (!this.eventsRegistered) {
      this.logger.trace("Registering 'GetMetadata' events");
      this.app.workspace.on("file-menu", this.bindContextMenu);
      this.eventsRegistered = true;
    }
  }
  /**
   * Registers the 'GetMetadata' commands
   */
  registerCommands() {
    this.logger.trace("Registering 'GetMetadata' commands");
    this.plugin.addCommand({
      id: "get-metadata-file",
      name: Lng.gt("ShowMetadataFile"),
      callback: () => {
        GetMetadata.getInstance().invoke();
      }
    });
  }
  /**
   * Adds the 'GetMetadata' context menu item
   * @param menu The context menu
   * @param file The file to add the context menu item to
   */
  onContextMenu(menu, file) {
    if (!(file instanceof import_obsidian15.TFile) || !file.path.endsWith(".pdf")) {
      return;
    }
    const metadataFile = this.getCorrespondingMetadataFile(file);
    if (!metadataFile) {
      return;
    }
    const document2 = new DocumentModel(metadataFile.file);
    if (metadataFile) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(Lng.gt("ShowMetadataFile")).setIcon(document2.getCorospondingSymbol()).onClick(
          async () => {
            await this.openMetadataFile(document2.file);
          }
        );
      });
    }
  }
  /**
   * Returns the metadata file for the given document (e.g. pdf) file
   * @param file The document file
   * @returns The metadata file or undefined if not found
   */
  getCorrespondingMetadataFile(file) {
    return this.metadataCache.find((metadata) => {
      var _a, _b;
      const type2 = (_a = metadata.metadata.frontmatter) == null ? void 0 : _a.type;
      const fileLink = (_b = metadata.metadata.frontmatter) == null ? void 0 : _b.file;
      if (type2 && fileLink && type2 === "Metadata") {
        return fileLink.contains(file.name);
      }
    });
  }
  /**
   * Opens the metadata file for the active (e.g. pdf) file
   */
  async invoke() {
    const workspace = this.app.workspace;
    const activeFile = workspace.getActiveFile();
    if (!activeFile || !(activeFile instanceof import_obsidian15.TFile) || !activeFile.path.endsWith(".pdf")) {
      this.logger.warn("No active pdf file found.");
      return;
    }
    const metadataFile = this.getCorrespondingMetadataFile(activeFile);
    if (!metadataFile) {
      this.logger.warn("No metadata file to the active pdf file found.");
      return;
    }
    const document2 = new DocumentModel(metadataFile.file);
    await this.openMetadataFile(document2.file);
  }
  async openMetadataFile(file) {
    this.logger.trace(`Opening metadata file for ${file.name}`);
    const workspace = this.app.workspace;
    const newLeaf = workspace.getLeaf(true);
    await newLeaf.openFile(file);
    const view = newLeaf.getViewState();
    view.state.mode = "preview";
    newLeaf.setViewState(view);
  }
};

// src/main.ts
var Prj = class extends import_obsidian16.Plugin {
  async onload() {
    console.log("Loading plugin 'PRJ'");
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    if (this.app.workspace.layoutReady) {
      await this.onLayoutReady();
    } else {
      this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    }
  }
  async onLayoutReady() {
    console.log("Layout ready");
    new Global(this, this.app, this.settings);
    await Global.getInstance().awaitCacheInitialization();
    this.registerMarkdownCodeBlockProcessor("prj", MarkdownBlockProcessor.parseSource);
    this.app.workspace.updateOptions();
    GetMetadata.getInstance();
  }
  onunload() {
    console.log("Unloading plugin 'PRJ'");
    GetMetadata.deconstructor();
    Global.deconstructor();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzIiwgIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9saWJzL01hcmtkb3duQmxvY2tQcm9jZXNzb3IudHMiLCAibm9kZV9tb2R1bGVzL2pzLXlhbWwvZGlzdC9qcy15YW1sLm1qcyIsICJzcmMvbGlicy9GaWxlQ2FjaGUudHMiLCAic3JjL2xpYnMvTWV0YWRhdGFDYWNoZS50cyIsICJzcmMvY2xhc3Nlcy9Mb2dnaW5nLnRzIiwgInNyYy9jbGFzc2VzL0dsb2JhbC50cyIsICJzcmMvbW9kZWxzL0RvY3VtZW50TW9kZWwudHMiLCAic3JjL21vZGVscy9UcmFuc2FjdGlvbk1vZGVsLnRzIiwgInNyYy9tb2RlbHMvQmFzZU1vZGVsLnRzIiwgInNyYy90eXBlcy9Eb2N1bWVudERhdGEudHMiLCAic3JjL2xpYnMvSGVscGVyLnRzIiwgInNyYy9saWJzL0Jsb2NrUmVuZGVyQ29tcG9uZW50cy9UYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50LnRzIiwgInNyYy90cmFuc2xhdGlvbnMuanNvbiIsICJzcmMvY2xhc3Nlcy9MbmcudHMiLCAic3JjL2xpYnMvU2VhcmNoLnRzIiwgInNyYy9saWJzL1RhYmxlLnRzIiwgInNyYy9saWJzL0Jsb2NrUmVuZGVyQ29tcG9uZW50cy9Jbm5lckNvbXBvbmVudHMvRmlsdGVyQnV0dG9uLnRzIiwgInNyYy9saWJzL0Jsb2NrUmVuZGVyQ29tcG9uZW50cy9Jbm5lckNvbXBvbmVudHMvTWF4U2hvd25Nb2RlbHNJbnB1dC50cyIsICJzcmMvbGlicy9CbG9ja1JlbmRlckNvbXBvbmVudHMvSW5uZXJDb21wb25lbnRzL1NlYXJjaElucHV0LnRzIiwgInNyYy9saWJzL0Jsb2NrUmVuZGVyQ29tcG9uZW50cy9Jbm5lckNvbXBvbmVudHMvRG9jdW1lbnRDb21wb25lbnRzLnRzIiwgInNyYy9saWJzL0VkaXRhYmxlRGF0YVZpZXcvQ29tcG9uZW50cy9CYXNlQ29tcG9uZW50LnRzIiwgInNyYy9saWJzL0VkaXRhYmxlRGF0YVZpZXcvQ29tcG9uZW50cy9EYXRlQ29tcG9uZW50LnRzIiwgInNyYy9saWJzL0VkaXRhYmxlRGF0YVZpZXcvQ29tcG9uZW50cy9Ecm9wZG93bkNvbXBvbmVudC50cyIsICJzcmMvbGlicy9FZGl0YWJsZURhdGFWaWV3L0NvbXBvbmVudHMvTGlua0NvbXBvbmVudC50cyIsICJzcmMvbGlicy9FZGl0YWJsZURhdGFWaWV3L0NvbXBvbmVudHMvVGV4dENvbXBvbmVudC50cyIsICJzcmMvbGlicy9FZGl0YWJsZURhdGFWaWV3L0NvbXBvbmVudHMvVGV4dGFyZWFDb21wb25lbnQudHMiLCAic3JjL2xpYnMvRWRpdGFibGVEYXRhVmlldy9FZGl0YWJsZURhdGFWaWV3LnRzIiwgInNyYy9saWJzL0Jsb2NrUmVuZGVyQ29tcG9uZW50cy9Jbm5lckNvbXBvbmVudHMvR2VuZXJhbENvbXBvbmVudHMudHMiLCAic3JjL2xpYnMvQmxvY2tSZW5kZXJDb21wb25lbnRzL0RvY3VtZW50QmxvY2tSZW5kZXJDb21wb25lbnQudHMiLCAic3JjL21vZGVscy9QcmpUYXNrTWFuYWdlbWVudE1vZGVsLnRzIiwgInNyYy90eXBlcy9Ub3BpY0RhdGEudHMiLCAic3JjL21vZGVscy9Ub3BpY01vZGVsLnRzIiwgInNyYy90eXBlcy9Qcm9qZWN0RGF0YS50cyIsICJzcmMvbW9kZWxzL1Byb2plY3RNb2RlbC50cyIsICJzcmMvdHlwZXMvVGFza0RhdGEudHMiLCAic3JjL21vZGVscy9UYXNrTW9kZWwudHMiLCAic3JjL2xpYnMvQmxvY2tSZW5kZXJDb21wb25lbnRzL0lubmVyQ29tcG9uZW50cy9Qcm9qZWN0Q29tcG9uZW50cy50cyIsICJzcmMvbGlicy9CbG9ja1JlbmRlckNvbXBvbmVudHMvUHJvamVjdEJsb2NrUmVuZGVyQ29tcG9uZW50LnRzIiwgInNyYy9jbGFzc2VzL1NldHRpbmdzVGFiLnRzIiwgInNyYy90eXBlcy9QcmpTZXR0aW5ncy50cyIsICJzcmMvbGlicy9Db250ZXh0TWVudXMvR2V0TWV0YWRhdGEudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKmdsb2JhbHMgd2luZG93LCBnbG9iYWwsIHJlcXVpcmUqL1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXG5cdCAgICB2YXIgY3J5cHRvO1xuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGluIHdlYiB3b3JrZXIgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gc2VsZi5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3b3JrZXJcblx0ICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuXHQgICAgICpcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcnlwdG9TZWN1cmVSYW5kb21JbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xuXHQgICAgICAgICAgICAvLyBVc2UgZ2V0UmFuZG9tVmFsdWVzIG1ldGhvZCAoQnJvd3Nlcilcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2UgcmFuZG9tQnl0ZXMgbWV0aG9kIChOb2RlSlMpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLicpO1xuXHQgICAgfTtcblxuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWxsIG9mIE9iamVjdC5jcmVhdGVcblxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0U2lnQnl0ZXM7IGogKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaikgPj4+IDJdID0gdGhhdFdvcmRzW2ogPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsICI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpOyIsICJpbXBvcnQgeyBQcmpTZXR0aW5ncyB9IGZyb20gJ3NyYy90eXBlcy9QcmpTZXR0aW5ncyc7XHJcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IE1hcmtkb3duQmxvY2tQcm9jZXNzb3IgZnJvbSAnc3JjL2xpYnMvTWFya2Rvd25CbG9ja1Byb2Nlc3Nvcic7XHJcbmltcG9ydCB7IFNldHRpbmdUYWIgfSBmcm9tICdzcmMvY2xhc3Nlcy9TZXR0aW5nc1RhYic7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3R5cGVzL1ByalNldHRpbmdzJztcclxuaW1wb3J0IEdsb2JhbCBmcm9tICcuL2NsYXNzZXMvR2xvYmFsJztcclxuaW1wb3J0IEdldE1ldGFkYXRhIGZyb20gJy4vbGlicy9Db250ZXh0TWVudXMvR2V0TWV0YWRhdGEnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJqIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5nczogUHJqU2V0dGluZ3M7XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTG9hZGluZyBwbHVnaW4gJ1BSSidcIilcclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuYXBwLndvcmtzcGFjZS5sYXlvdXRSZWFkeSkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLm9uTGF5b3V0UmVhZHkoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KHRoaXMub25MYXlvdXRSZWFkeS5iaW5kKHRoaXMpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIG9uTGF5b3V0UmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zb2xlLmxvZyhcIkxheW91dCByZWFkeVwiKTtcclxuXHJcblx0XHRuZXcgR2xvYmFsKHRoaXMsIHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKTtcclxuXHRcdGF3YWl0IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmF3YWl0Q2FjaGVJbml0aWFsaXphdGlvbigpO1xyXG5cclxuXHRcdHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcigncHJqJywgTWFya2Rvd25CbG9ja1Byb2Nlc3Nvci5wYXJzZVNvdXJjZSk7XHJcblxyXG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLnVwZGF0ZU9wdGlvbnMoKTtcclxuXHJcblx0XHQvLyBHZXQgTWV0YWRhdGEgRmlsZSBDb250ZXh0IE1lbnUgJiBDb21tYW5kXHJcblx0XHRHZXRNZXRhZGF0YS5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBwbHVnaW4gJ1BSSidcIilcclxuXHRcdEdldE1ldGFkYXRhLmRlY29uc3RydWN0b3IoKTtcclxuXHRcdEdsb2JhbC5kZWNvbnN0cnVjdG9yKCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG59IiwgIi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXHJcbi8vIE5vdGU6IE1hcmtkb3duQmxvY2tQcm9jZXNzb3IgQ2xhc3NcclxuXHJcbmltcG9ydCB7IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIE1hcmtkb3duUmVuZGVyQ2hpbGQgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0ICogYXMgeWFtbCBmcm9tICdqcy15YW1sJztcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwiLi4vY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IERvY3VtZW50QmxvY2tSZW5kZXJDb21wb25lbnQgZnJvbSBcIi4vQmxvY2tSZW5kZXJDb21wb25lbnRzL0RvY3VtZW50QmxvY2tSZW5kZXJDb21wb25lbnRcIjtcclxuaW1wb3J0IHsgSVByb2Nlc3NvclNldHRpbmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByb2Nlc3NvclNldHRpbmdzXCI7XHJcbmltcG9ydCBQcm9qZWN0QmxvY2tSZW5kZXJDb21wb25lbnQgZnJvbSBcIi4vQmxvY2tSZW5kZXJDb21wb25lbnRzL1Byb2plY3RCbG9ja1JlbmRlckNvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciB0aGUgbWFya2Rvd24gYmxvY2sgcHJvY2Vzc29yLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2Rvd25CbG9ja1Byb2Nlc3NvciB7XHJcblxyXG4gICAgc3RhdGljIGFzeW5jIHBhcnNlU291cmNlKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY20tZW1iZWQtYmxvY2sgY2xhc3MgZnJvbSB0aGUgcGFyZW50IGVsZW1lbnRcclxuICAgICAgICAvLyBhbmQgYWRkIHRoZSBwcmotYmxvY2sgY2xhc3MuXHJcbiAgICAgICAgLy8gVGhpcyByZW1vdmUgdGhlIEJsb2NrLUhvdmVyLUVmZmVrdCBmcm9tIHRoZSBibG9ja1xyXG4gICAgICAgIC8vIGFuZCB3aXRoIENTUyB3ZSByZW1vdmUgdGhlIEJsb2NrLUVkaXQtQnV0dG9uXHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWwuY2xvc2VzdCgnZGl2LmNtLXByZXZpZXctY29kZS1ibG9jay5jbS1lbWJlZC1ibG9jay5tYXJrZG93bi1yZW5kZXJlZCcpO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NtLWVtYmVkLWJsb2NrJyk7XHJcbiAgICAgICAgICAgIHBhcmVudC5hZGRDbGFzcygncHJqLWJsb2NrJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBnbG9iYWwgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBhd2FpdCBnbG9iYWwubWV0YWRhdGFDYWNoZS53YWl0Rm9yQ2FjaGVSZWFkeSgpO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gZ2xvYmFsLm1ldGFkYXRhQ2FjaGUuQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gZ2xvYmFsLmxvZ2dlcjtcclxuXHJcbiAgICAgICAgY29uc3QgY21wID0gbmV3IE1hcmtkb3duUmVuZGVyQ2hpbGQoZWwpO1xyXG4gICAgICAgIGN0eC5hZGRDaGlsZChjbXApO1xyXG4gICAgICAgIGNtcC5sb2FkKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJsb2NrQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZWwuYXBwZW5kKGJsb2NrQ29udGFpbmVyKTtcclxuICAgICAgICBibG9ja0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwcmotYmxvY2stY29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmc6IElQcm9jZXNzb3JTZXR0aW5ncyA9IHlhbWwubG9hZChzb3VyY2UpIGFzIElQcm9jZXNzb3JTZXR0aW5ncztcclxuICAgICAgICBzZXR0aW5nLnNvdXJjZSA9IGN0eC5zb3VyY2VQYXRoO1xyXG4gICAgICAgIHNldHRpbmcuZnJvbnRtYXR0ZXIgPSBjYWNoZS5maWx0ZXIoZmlsZSA9PiBmaWxlLmZpbGUucGF0aCA9PT0gY3R4LnNvdXJjZVBhdGgpLmZpcnN0KCk/Lm1ldGFkYXRhLmZyb250bWF0dGVyO1xyXG4gICAgICAgIHNldHRpbmcuY29udGFpbmVyID0gYmxvY2tDb250YWluZXI7XHJcbiAgICAgICAgc2V0dGluZy5jdHggPSBjdHg7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRG9jdW1lbnRzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRCbG9jayA9IG5ldyBEb2N1bWVudEJsb2NrUmVuZGVyQ29tcG9uZW50KHNldHRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZG9jdW1lbnRCbG9jay5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlRhc2tzXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiUHJvamVjdHNcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJUb3BpY3NcIjpcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0QmxvY2sgPSBuZXcgUHJvamVjdEJsb2NrUmVuZGVyQ29tcG9uZW50KHNldHRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvamVjdEJsb2NrLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRGVidWdcIjpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlYnVnIE1vZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFNldHRpbmdzOiAke3NldHRpbmd9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBNYXJrZG93bkJsb2NrUHJvY2Vzc29yIHJ1bnMgZm9yICR7ZW5kVGltZSAtIHN0YXJ0VGltZX1tc2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbiIsICJcbi8qISBqcy15YW1sIDQuMS4wIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvanMteWFtbCBAbGljZW5zZSBNSVQgKi9cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbnZhciBpc05vdGhpbmdfMSAgICAgID0gaXNOb3RoaW5nO1xudmFyIGlzT2JqZWN0XzEgICAgICAgPSBpc09iamVjdDtcbnZhciB0b0FycmF5XzEgICAgICAgID0gdG9BcnJheTtcbnZhciByZXBlYXRfMSAgICAgICAgID0gcmVwZWF0O1xudmFyIGlzTmVnYXRpdmVaZXJvXzEgPSBpc05lZ2F0aXZlWmVybztcbnZhciBleHRlbmRfMSAgICAgICAgID0gZXh0ZW5kO1xuXG52YXIgY29tbW9uID0ge1xuXHRpc05vdGhpbmc6IGlzTm90aGluZ18xLFxuXHRpc09iamVjdDogaXNPYmplY3RfMSxcblx0dG9BcnJheTogdG9BcnJheV8xLFxuXHRyZXBlYXQ6IHJlcGVhdF8xLFxuXHRpc05lZ2F0aXZlWmVybzogaXNOZWdhdGl2ZVplcm9fMSxcblx0ZXh0ZW5kOiBleHRlbmRfMVxufTtcblxuLy8gWUFNTCBlcnJvciBjbGFzcy4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU4OTg0XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXhjZXB0aW9uLCBjb21wYWN0KSB7XG4gIHZhciB3aGVyZSA9ICcnLCBtZXNzYWdlID0gZXhjZXB0aW9uLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFleGNlcHRpb24ubWFyaykgcmV0dXJuIG1lc3NhZ2U7XG5cbiAgaWYgKGV4Y2VwdGlvbi5tYXJrLm5hbWUpIHtcbiAgICB3aGVyZSArPSAnaW4gXCInICsgZXhjZXB0aW9uLm1hcmsubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJygnICsgKGV4Y2VwdGlvbi5tYXJrLmxpbmUgKyAxKSArICc6JyArIChleGNlcHRpb24ubWFyay5jb2x1bW4gKyAxKSArICcpJztcblxuICBpZiAoIWNvbXBhY3QgJiYgZXhjZXB0aW9uLm1hcmsuc25pcHBldCkge1xuICAgIHdoZXJlICs9ICdcXG5cXG4nICsgZXhjZXB0aW9uLm1hcmsuc25pcHBldDtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlICsgJyAnICsgd2hlcmU7XG59XG5cblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbiQxKHJlYXNvbiwgbWFyaykge1xuICAvLyBTdXBlciBjb25zdHJ1Y3RvclxuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IGZvcm1hdEVycm9yKHRoaXMsIGZhbHNlKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uJDEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb24kMTtcblxuXG5ZQU1MRXhjZXB0aW9uJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIGZvcm1hdEVycm9yKHRoaXMsIGNvbXBhY3QpO1xufTtcblxuXG52YXIgZXhjZXB0aW9uID0gWUFNTEV4Y2VwdGlvbiQxO1xuXG4vLyBnZXQgc25pcHBldCBmb3IgYSBzaW5nbGUgbGluZSwgcmVzcGVjdGluZyBtYXhMZW5ndGhcbmZ1bmN0aW9uIGdldExpbmUoYnVmZmVyLCBsaW5lU3RhcnQsIGxpbmVFbmQsIHBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKSB7XG4gIHZhciBoZWFkID0gJyc7XG4gIHZhciB0YWlsID0gJyc7XG4gIHZhciBtYXhIYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihtYXhMaW5lTGVuZ3RoIC8gMikgLSAxO1xuXG4gIGlmIChwb3NpdGlvbiAtIGxpbmVTdGFydCA+IG1heEhhbGZMZW5ndGgpIHtcbiAgICBoZWFkID0gJyAuLi4gJztcbiAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbiAtIG1heEhhbGZMZW5ndGggKyBoZWFkLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChsaW5lRW5kIC0gcG9zaXRpb24gPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgdGFpbCA9ICcgLi4uJztcbiAgICBsaW5lRW5kID0gcG9zaXRpb24gKyBtYXhIYWxmTGVuZ3RoIC0gdGFpbC5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0cjogaGVhZCArIGJ1ZmZlci5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQpLnJlcGxhY2UoL1xcdC9nLCAnXHUyMTkyJykgKyB0YWlsLFxuICAgIHBvczogcG9zaXRpb24gLSBsaW5lU3RhcnQgKyBoZWFkLmxlbmd0aCAvLyByZWxhdGl2ZSBwb3NpdGlvblxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbWF4KSB7XG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgbWF4IC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxuZnVuY3Rpb24gbWFrZVNuaXBwZXQobWFyaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IG51bGwpO1xuXG4gIGlmICghbWFyay5idWZmZXIpIHJldHVybiBudWxsO1xuXG4gIGlmICghb3B0aW9ucy5tYXhMZW5ndGgpIG9wdGlvbnMubWF4TGVuZ3RoID0gNzk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgICAgICAhPT0gJ251bWJlcicpIG9wdGlvbnMuaW5kZW50ICAgICAgPSAxO1xuICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXNCZWZvcmUgIT09ICdudW1iZXInKSBvcHRpb25zLmxpbmVzQmVmb3JlID0gMztcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQWZ0ZXIgICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0FmdGVyICA9IDI7XG5cbiAgdmFyIHJlID0gL1xccj9cXG58XFxyfFxcMC9nO1xuICB2YXIgbGluZVN0YXJ0cyA9IFsgMCBdO1xuICB2YXIgbGluZUVuZHMgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgZm91bmRMaW5lTm8gPSAtMTtcblxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhtYXJrLmJ1ZmZlcikpKSB7XG4gICAgbGluZUVuZHMucHVzaChtYXRjaC5pbmRleCk7XG4gICAgbGluZVN0YXJ0cy5wdXNoKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgIGlmIChtYXJrLnBvc2l0aW9uIDw9IG1hdGNoLmluZGV4ICYmIGZvdW5kTGluZU5vIDwgMCkge1xuICAgICAgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kTGluZU5vIDwgMCkgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsaW5lO1xuICB2YXIgbGluZU5vTGVuZ3RoID0gTWF0aC5taW4obWFyay5saW5lICsgb3B0aW9ucy5saW5lc0FmdGVyLCBsaW5lRW5kcy5sZW5ndGgpLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgbWF4TGluZUxlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIC0gKG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyk7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQmVmb3JlOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gLSBpIDwgMCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyAtIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lIC0gaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nICsgcmVzdWx0O1xuICB9XG5cbiAgbGluZSA9IGdldExpbmUobWFyay5idWZmZXIsIGxpbmVTdGFydHNbZm91bmRMaW5lTm9dLCBsaW5lRW5kc1tmb3VuZExpbmVOb10sIG1hcmsucG9zaXRpb24sIG1heExpbmVMZW5ndGgpO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbic7XG4gIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCctJywgb3B0aW9ucy5pbmRlbnQgKyBsaW5lTm9MZW5ndGggKyAzICsgbGluZS5wb3MpICsgJ14nICsgJ1xcbic7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQWZ0ZXI7IGkrKykge1xuICAgIGlmIChmb3VuZExpbmVObyArIGkgPj0gbGluZUVuZHMubGVuZ3RoKSBicmVhaztcbiAgICBsaW5lID0gZ2V0TGluZShcbiAgICAgIG1hcmsuYnVmZmVyLFxuICAgICAgbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldLFxuICAgICAgbGluZUVuZHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIG1hcmsucG9zaXRpb24gLSAobGluZVN0YXJ0c1tmb3VuZExpbmVOb10gLSBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vICsgaV0pLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXG4kLywgJycpO1xufVxuXG5cbnZhciBzbmlwcGV0ID0gbWFrZVNuaXBwZXQ7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ211bHRpJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdyZXByZXNlbnROYW1lJyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUkMSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuICB0aGlzLm9wdGlvbnMgICAgICAgPSBvcHRpb25zOyAvLyBrZWVwIG9yaWdpbmFsIG9wdGlvbnMgaW4gY2FzZSB1c2VyIHdhbnRzIHRvIGV4dGVuZCB0aGlzIHR5cGUgbGF0ZXJcbiAgdGhpcy50YWcgICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICAgPSBvcHRpb25zWydraW5kJ10gICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMuY29uc3RydWN0ICAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgID0gb3B0aW9uc1snaW5zdGFuY2VPZiddICAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCAgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnROYW1lID0gb3B0aW9uc1sncmVwcmVzZW50TmFtZSddIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlICA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddICB8fCBudWxsO1xuICB0aGlzLm11bHRpICAgICAgICAgPSBvcHRpb25zWydtdWx0aSddICAgICAgICAgfHwgZmFsc2U7XG4gIHRoaXMuc3R5bGVBbGlhc2VzICA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxudmFyIHR5cGUgPSBUeXBlJDE7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cblxuXG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBzY2hlbWFbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFR5cGUpIHtcbiAgICB2YXIgbmV3SW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5raW5kID09PSBjdXJyZW50VHlwZS5raW5kICYmXG4gICAgICAgICAgcHJldmlvdXNUeXBlLm11bHRpID09PSBjdXJyZW50VHlwZS5tdWx0aSkge1xuXG4gICAgICAgIG5ld0luZGV4ID0gcHJldmlvdXNJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdFtuZXdJbmRleF0gPSBjdXJyZW50VHlwZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHNjYWxhcjoge30sXG4gICAgICAgIHNlcXVlbmNlOiB7fSxcbiAgICAgICAgbWFwcGluZzoge30sXG4gICAgICAgIGZhbGxiYWNrOiB7fSxcbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICBzY2FsYXI6IFtdLFxuICAgICAgICAgIHNlcXVlbmNlOiBbXSxcbiAgICAgICAgICBtYXBwaW5nOiBbXSxcbiAgICAgICAgICBmYWxsYmFjazogW11cbiAgICAgICAgfVxuICAgICAgfSwgaW5kZXgsIGxlbmd0aDtcblxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUubXVsdGkpIHtcbiAgICAgIHJlc3VsdC5tdWx0aVt0eXBlLmtpbmRdLnB1c2godHlwZSk7XG4gICAgICByZXN1bHQubXVsdGlbJ2ZhbGxiYWNrJ10ucHVzaCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3R5cGUua2luZF1bdHlwZS50YWddID0gcmVzdWx0WydmYWxsYmFjayddW3R5cGUudGFnXSA9IHR5cGU7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYSQxKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kKGRlZmluaXRpb24pO1xufVxuXG5cblNjaGVtYSQxLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVmaW5pdGlvbikge1xuICB2YXIgaW1wbGljaXQgPSBbXTtcbiAgdmFyIGV4cGxpY2l0ID0gW107XG5cbiAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh0eXBlKVxuICAgIGV4cGxpY2l0LnB1c2goZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZChbIHR5cGUxLCB0eXBlMiwgLi4uIF0pXG4gICAgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChkZWZpbml0aW9uICYmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24uaW1wbGljaXQpIHx8IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5leHBsaWNpdCkpKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh7IGV4cGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0sIGltcGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0gfSlcbiAgICBpZiAoZGVmaW5pdGlvbi5pbXBsaWNpdCkgaW1wbGljaXQgPSBpbXBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5pbXBsaWNpdCk7XG4gICAgaWYgKGRlZmluaXRpb24uZXhwbGljaXQpIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24uZXhwbGljaXQpO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU2NoZW1hLmV4dGVuZCBhcmd1bWVudCBzaG91bGQgYmUgYSBUeXBlLCBbIFR5cGUgXSwgJyArXG4gICAgICAnb3IgYSBzY2hlbWEgZGVmaW5pdGlvbiAoeyBpbXBsaWNpdDogWy4uLl0sIGV4cGxpY2l0OiBbLi4uXSB9KScpO1xuICB9XG5cbiAgaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgaWYgKCEodHlwZSQxIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSQxLmxvYWRLaW5kICYmIHR5cGUkMS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJDEubXVsdGkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1RoZXJlIGlzIGEgbXVsdGkgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gTXVsdGkgdGFncyBjYW4gb25seSBiZSBsaXN0ZWQgYXMgZXhwbGljaXQuJyk7XG4gICAgfVxuICB9KTtcblxuICBleHBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlJDEpIHtcbiAgICBpZiAoISh0eXBlJDEgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoU2NoZW1hJDEucHJvdG90eXBlKTtcblxuICByZXN1bHQuaW1wbGljaXQgPSAodGhpcy5pbXBsaWNpdCB8fCBbXSkuY29uY2F0KGltcGxpY2l0KTtcbiAgcmVzdWx0LmV4cGxpY2l0ID0gKHRoaXMuZXhwbGljaXQgfHwgW10pLmNvbmNhdChleHBsaWNpdCk7XG5cbiAgcmVzdWx0LmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdpbXBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHJlc3VsdCwgJ2V4cGxpY2l0Jyk7XG4gIHJlc3VsdC5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcChyZXN1bHQuY29tcGlsZWRJbXBsaWNpdCwgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbnZhciBzY2hlbWEgPSBTY2hlbWEkMTtcblxudmFyIHN0ciA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnOyB9XG59KTtcblxudmFyIHNlcSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuXG52YXIgbWFwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9OyB9XG59KTtcblxudmFyIGZhaWxzYWZlID0gbmV3IHNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgc3RyLFxuICAgIHNlcSxcbiAgICBtYXBcbiAgXVxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbnZhciBfbnVsbCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH0sXG4gICAgZW1wdHk6ICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgICAgIH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG52YXIgYm9vbCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAnbycpIHtcbiAgICAgIC8vIGJhc2UgOFxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc09jdENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMClcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2g7XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdvJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgOCk7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcihvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmXG4gICAgICAgICAob2JqZWN0ICUgMSA9PT0gMCAmJiAhY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG52YXIgaW50ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMG8nICArIG9iai50b1N0cmluZyg4KSA6ICctMG8nICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAvLyAyLjVlNCwgMi41IGFuZCBpbnRlZ2Vyc1xuICAnXig/OlstK10/KD86WzAtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLmluZlxuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgLy8gLm5hblxuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSB8fFxuICAgICAgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gICAgICAvLyBQcm9iYWJseSBzaG91bGQgdXBkYXRlIHJlZ2V4cCAmIGNoZWNrIHNwZWVkXG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdfJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ247XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gKHNpZ24gPT09IDEpID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cblxudmFyIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QgPSAvXlstK10/WzAtOV0rZS87XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5uYW4nO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuTkFOJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcuaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLS5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICctLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG5cbiAgcmVzID0gb2JqZWN0LnRvU3RyaW5nKDEwKTtcblxuICAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpICYmXG4gICAgICAgICAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbnZhciBmbG9hdCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxudmFyIGpzb24gPSBmYWlsc2FmZS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIF9udWxsLFxuICAgIGJvb2wsXG4gICAgaW50LFxuICAgIGZsb2F0XG4gIF1cbn0pO1xuXG52YXIgY29yZSA9IGpzb247XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XSkkJyk7ICAgICAgICAgICAgICAgICAgIC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgICAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbnZhciB0aW1lc3RhbXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbnZhciBtZXJnZSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG5cblxuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgYml0bGVuICs9IDY7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcbiAgcmV0dXJuIChiaXRsZW4gJSA4KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksIC8vIHJlbW92ZSBDUi9MRiAmIHBhZGRpbmcgdG8gc2ltcGxpZnkgc2NhblxuICAgICAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDQgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA2KSB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxMCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAyKSAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDQpICYgMHhGRik7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICAnW29iamVjdCBVaW50OEFycmF5XSc7XG59XG5cbnZhciBiaW5hcnkgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmckMiAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoX3RvU3RyaW5nJDIuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5JDMuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxudmFyIG9tYXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcblxudmFyIF90b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nJDEuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHBhaXJzID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG52YXIgc2V0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcblxudmFyIF9kZWZhdWx0ID0gY29yZS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIHRpbWVzdGFtcCxcbiAgICBtZXJnZVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIGJpbmFyeSxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNldFxuICBdXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxuXG5cblxuXG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ09OVEVYVF9GTE9XX0lOICAgPSAxO1xudmFyIENPTlRFWFRfRkxPV19PVVQgID0gMjtcbnZhciBDT05URVhUX0JMT0NLX0lOICA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xuXG5cbnZhciBDSE9NUElOR19DTElQICA9IDE7XG52YXIgQ0hPTVBJTkdfU1RSSVAgPSAyO1xudmFyIENIT01QSU5HX0tFRVAgID0gMztcblxuXG52YXIgUEFUVEVSTl9OT05fUFJJTlRBQkxFICAgICAgICAgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyAgICAgICA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSAgICAgICAgICAgID0gL14oPzohfCEhfCFbYS16XFwtXSshKSQvaTtcbnZhciBQQVRURVJOX1RBR19VUkkgICAgICAgICAgICAgICA9IC9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2k7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDBBLyogTEYgKi8pIHx8IChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHwgKGMgPT09IDB4MjAvKiBTcGFjZSAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dTX09SX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwQS8qIExGICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX0ZMT1dfSU5ESUNBVE9SKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MkMvKiAsICovIHx8XG4gICAgICAgICBjID09PSAweDVCLyogWyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1RC8qIF0gKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0IvKiB7ICovIHx8XG4gICAgICAgICBjID09PSAweDdELyogfSAqLztcbn1cblxuZnVuY3Rpb24gZnJvbUhleENvZGUoYykge1xuICB2YXIgbGM7XG5cbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBsYyA9IGMgfCAweDIwO1xuXG4gIGlmICgoMHg2MS8qIGEgKi8gPD0gbGMpICYmIChsYyA8PSAweDY2LyogZiAqLykpIHtcbiAgICByZXR1cm4gbGMgLSAweDYxICsgMTA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRIZXhMZW4oYykge1xuICBpZiAoYyA9PT0gMHg3OC8qIHggKi8pIHsgcmV0dXJuIDI7IH1cbiAgaWYgKGMgPT09IDB4NzUvKiB1ICovKSB7IHJldHVybiA0OyB9XG4gIGlmIChjID09PSAweDU1LyogVSAqLykgeyByZXR1cm4gODsgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnJvbURlY2ltYWxDb2RlKGMpIHtcbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgKChjIC0gMHgwMTAwMDApICYgMHgwM0ZGKSArIDB4REMwMFxuICApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IF9kZWZhdWx0O1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIC8vIChIaWRkZW4pIFJlbW92ZT8gbWFrZXMgdGhlIGxvYWRlciB0byBleHBlY3QgWUFNTCAxLjEgZG9jdW1lbnRzXG4gIC8vIGlmIHN1Y2ggZG9jdW1lbnRzIGhhdmUgbm8gZXhwbGljaXQgJVlBTUwgZGlyZWN0aXZlXG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG5cbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgLy8gcG9zaXRpb24gb2YgZmlyc3QgbGVhZGluZyB0YWIgaW4gdGhlIGN1cnJlbnQgbGluZSxcbiAgLy8gdXNlZCB0byBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vIHRhYnMgaW4gdGhlIGluZGVudGF0aW9uXG4gIHRoaXMuZmlyc3RUYWJJbkxpbmUgPSAtMTtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHZhciBtYXJrID0ge1xuICAgIG5hbWU6ICAgICBzdGF0ZS5maWxlbmFtZSxcbiAgICBidWZmZXI6ICAgc3RhdGUuaW5wdXQuc2xpY2UoMCwgLTEpLCAvLyBvbWl0IHRyYWlsaW5nIFxcMFxuICAgIHBvc2l0aW9uOiBzdGF0ZS5wb3NpdGlvbixcbiAgICBsaW5lOiAgICAgc3RhdGUubGluZSxcbiAgICBjb2x1bW46ICAgc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnRcbiAgfTtcblxuICBtYXJrLnNuaXBwZXQgPSBzbmlwcGV0KG1hcmspO1xuXG4gIHJldHVybiBuZXcgZXhjZXB0aW9uKG1lc3NhZ2UsIG1hcmspO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHRocm93IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1dhcm5pbmcoc3RhdGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHN0YXRlLm9uV2FybmluZykge1xuICAgIHN0YXRlLm9uV2FybmluZy5jYWxsKG51bGwsIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcblxuICBZQU1MOiBmdW5jdGlvbiBoYW5kbGVZYW1sRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgIGlmIChzdGF0ZS52ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgJVlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnWUFNTCBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIG1hdGNoID0gL14oWzAtOV0rKVxcLihbMC05XSspJC8uZXhlYyhhcmdzWzBdKTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgbWFqb3IgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgIGlmIChtYWpvciAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuXG4gICAgc3RhdGUudmVyc2lvbiA9IGFyZ3NbMF07XG4gICAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gKG1pbm9yIDwgMik7XG5cbiAgICBpZiAobWlub3IgIT09IDEgJiYgbWlub3IgIT09IDIpIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBoYW5kbGUsIHByZWZpeDtcblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBoYW5kbGUgPSBhcmdzWzBdO1xuICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBoYW5kbGUgKGZpcnN0IGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByZWZpeCA9IGRlY29kZVVSSUNvbXBvbmVudChwcmVmaXgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBwcmVmaXggaXMgbWFsZm9ybWVkOiAnICsgcHJlZml4KTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fFxuICAgICAgICAgICAgICAoMHgyMCA8PSBfY2hhcmFjdGVyICYmIF9jaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkkMS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsXG4gIHN0YXJ0TGluZSwgc3RhcnRMaW5lU3RhcnQsIHN0YXJ0UG9zKSB7XG5cbiAgdmFyIGluZGV4LCBxdWFudGl0eTtcblxuICAvLyBUaGUgb3V0cHV0IGlzIGEgcGxhaW4gb2JqZWN0IGhlcmUsIHNvIGtleXMgY2FuIG9ubHkgYmUgc3RyaW5ncy5cbiAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IGtleU5vZGUgdG8gYSBzdHJpbmcsIGJ1dCBkb2luZyBzbyBjYW4gaGFuZyB0aGUgcHJvY2Vzc1xuICAvLyAoZGVlcGx5IG5lc3RlZCBhcnJheXMgdGhhdCBleHBsb2RlIGV4cG9uZW50aWFsbHkgdXNpbmcgYWxpYXNlcykuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGUpKSB7XG4gICAga2V5Tm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleU5vZGUpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0ga2V5Tm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGVbaW5kZXhdKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlW2luZGV4XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIGtleU5vZGVbaW5kZXhdID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQXZvaWQgY29kZSBleGVjdXRpb24gaW4gbG9hZCgpIHZpYSB0b1N0cmluZyBwcm9wZXJ0eVxuICAvLyAoc3RpbGwgdXNlIGl0cyBvd24gdG9TdHJpbmcgZm9yIGFycmF5cywgdGltZXN0YW1wcyxcbiAgLy8gYW5kIHdoYXRldmVyIHVzZXIgc2NoZW1hIGV4dGVuc2lvbnMgaGFwcGVuIHRvIGhhdmUgQEB0b1N0cmluZ1RhZylcbiAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAga2V5Tm9kZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiZcbiAgICAgICAgIV9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkkMS5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5saW5lU3RhcnQgPSBzdGFydExpbmVTdGFydCB8fCBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG5cbiAgICAvLyB1c2VkIGZvciB0aGlzIHNwZWNpZmljIGtleSBvbmx5IGJlY2F1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIHNsb3dcbiAgICBpZiAoa2V5Tm9kZSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcmVzdWx0LCBrZXlOb2RlLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIH1cbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBLyogTEYgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDBELyogQ1IgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICBzdGF0ZS5maXJzdFRhYkluTGluZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOS8qIFRhYiAqLyAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiBjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIGNoICE9PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja0luZGVudCAhPT0gLTEgJiYgbGluZUJyZWFrcyAhPT0gMCAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoY2ggPT09IDB4MkQvKiAtICovIHx8IGNoID09PSAweDJFLyogLiAqLykgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDEpICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fFxuICAgICAgY2ggPT09IDB4MjMvKiAjICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNi8qICYgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDJBLyogKiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjEvKiAhICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg3Qy8qIHwgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDNFLyogPiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjcvKiAnICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMi8qIFwiICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNS8qICUgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDQwLyogQCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKHByZWNlZGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHx8XG4gICAgICAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3LyogJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMi8qIFwiICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjIvKiBcIiAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIC8vIFwiZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMgY2FuIG5ldmVyIGJlIGNvbXBsZXRlbHkgZW1wdHlcIiwgYXMgcGVyIFlBTUwgMS4yLCBzZWN0aW9uIDcuNFxuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgXCJleHBlY3RlZCB0aGUgbm9kZSBjb250ZW50LCBidXQgZm91bmQgJywnXCIpO1xuICAgIH1cblxuICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gZmFsc2U7XG5cbiAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3Bvcyk7XG4gICAgfSBlbHNlIGlmIChpc1BhaXIpIHtcbiAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBudWxsLCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3BvcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkaWRSZWFkQ29udGVudCA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gS2VlcCBhbGwgbGluZSBicmVha3MgZXhjZXB0IHRoZSBoZWFkZXIgbGluZSBicmVhay5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgfVxuXG4gICAgZGlkUmVhZENvbnRlbnQgPSB0cnVlO1xuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDB4MkQvKiAtICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF9rZXlMaW5lLFxuICAgICAgX2tleUxpbmVTdGFydCxcbiAgICAgIF9rZXlQb3MsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICAvLyB0aGVyZSBpcyBhIGxlYWRpbmcgdGFiIGJlZm9yZSB0aGlzIHRva2VuLCBzbyBpdCBjYW4ndCBiZSBhIGJsb2NrIHNlcXVlbmNlL21hcHBpbmc7XG4gIC8vIGl0IGNhbiBzdGlsbCBiZSBmbG93IHNlcXVlbmNlL21hcHBpbmcgb3IgYSBzY2FsYXJcbiAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmICghYXRFeHBsaWNpdEtleSAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhdGUuZmlyc3RUYWJJbkxpbmU7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFiIGNoYXJhY3RlcnMgbXVzdCBub3QgYmUgdXNlZCBpbiBpbmRlbnRhdGlvbicpO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDNBLyogOiAqLykgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2tleVBvcyA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoIWNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gTmVpdGhlciBpbXBsaWNpdCBub3IgZXhwbGljaXQgbm90YXRpb24uXG4gICAgICAgIC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICAgIF9rZXlMaW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0YWdOYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHRhZ05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgaXMgbWFsZm9ybWVkOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGVMaXN0LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnID09PSAnPycpIHtcbiAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgIC8vXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGtpbmQgY29uZm9ybWl0eSBpbiBjYXNlIHVzZXIgZXhwbGljaXRseSBhc3NpZ25zICc/J1xuICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgc3RhdGUua2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXSwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXVtzdGF0ZS50YWddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb29raW5nIGZvciBtdWx0aSB0eXBlXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHR5cGVMaXN0ID0gc3RhdGUudHlwZU1hcC5tdWx0aVtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddO1xuXG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHR5cGVMaXN0Lmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoc3RhdGUudGFnLnNsaWNlKDAsIHR5cGVMaXN0W3R5cGVJbmRleF0udGFnLmxlbmd0aCkgPT09IHR5cGVMaXN0W3R5cGVJbmRleF0udGFnKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGVMaXN0W3R5cGVJbmRleF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0LCBzdGF0ZS50YWcpO1xuICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignY2xvc2UnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCAgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdGF0ZS5hbmNob3JNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1LyogJSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMCkgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwkMShpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQkMShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbnZhciBsb2FkQWxsXzEgPSBsb2FkQWxsJDE7XG52YXIgbG9hZF8xICAgID0gbG9hZCQxO1xuXG52YXIgbG9hZGVyID0ge1xuXHRsb2FkQWxsOiBsb2FkQWxsXzEsXG5cdGxvYWQ6IGxvYWRfMVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxuXG5cblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfQk9NICAgICAgICAgICAgICAgICAgPSAweEZFRkY7XG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfRVFVQUxTICAgICAgICAgICAgICAgPSAweDNEOyAvKiA9ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG52YXIgREVQUkVDQVRFRF9CQVNFNjBfU1lOVEFYID0gL15bLStdP1swLTlfXSsoPzo6WzAtOV9dKykrKD86XFwuWzAtOV9dKik/JC87XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICh0YWcuc2xpY2UoMCwgMikgPT09ICchIScpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxudmFyIFFVT1RJTkdfVFlQRV9TSU5HTEUgPSAxLFxuICAgIFFVT1RJTkdfVFlQRV9ET1VCTEUgPSAyO1xuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMuc2NoZW1hICAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IF9kZWZhdWx0O1xuICB0aGlzLmluZGVudCAgICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLm5vQXJyYXlJbmRlbnQgPSBvcHRpb25zWydub0FycmF5SW5kZW50J10gfHwgZmFsc2U7XG4gIHRoaXMuc2tpcEludmFsaWQgICA9IG9wdGlvbnNbJ3NraXBJbnZhbGlkJ10gfHwgZmFsc2U7XG4gIHRoaXMuZmxvd0xldmVsICAgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgICAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzICAgICAgPSBvcHRpb25zWydzb3J0S2V5cyddIHx8IGZhbHNlO1xuICB0aGlzLmxpbmVXaWR0aCAgICAgPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgICAgICAgID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlICA9IG9wdGlvbnNbJ25vQ29tcGF0TW9kZSddIHx8IGZhbHNlO1xuICB0aGlzLmNvbmRlbnNlRmxvdyAgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcbiAgdGhpcy5xdW90aW5nVHlwZSAgID0gb3B0aW9uc1sncXVvdGluZ1R5cGUnXSA9PT0gJ1wiJyA/IFFVT1RJTkdfVFlQRV9ET1VCTEUgOiBRVU9USU5HX1RZUEVfU0lOR0xFO1xuICB0aGlzLmZvcmNlUXVvdGVzICAgPSBvcHRpb25zWydmb3JjZVF1b3RlcyddIHx8IGZhbHNlO1xuICB0aGlzLnJlcGxhY2VyICAgICAgPSB0eXBlb2Ygb3B0aW9uc1sncmVwbGFjZXInXSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNbJ3JlcGxhY2VyJ10gOiBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG5cbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIHRoaXMuZHVwbGljYXRlcyA9IFtdO1xuICB0aGlzLnVzZWREdXBsaWNhdGVzID0gbnVsbDtcbn1cblxuLy8gSW5kZW50cyBldmVyeSBsaW5lIGluIGEgc3RyaW5nLiBFbXB0eSBsaW5lcyAoXFxuIG9ubHkpIGFyZSBub3QgaW5kZW50ZWQuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24sIG5leHQgKyAxKTtcbiAgICAgIHBvc2l0aW9uID0gbmV4dCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGxpbmUubGVuZ3RoICYmIGxpbmUgIT09ICdcXG4nKSByZXN1bHQgKz0gaW5kO1xuXG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFszM10gcy13aGl0ZSA6Oj0gcy1zcGFjZSB8IHMtdGFiXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNuXHUyMDE5dCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cbmZ1bmN0aW9uIGlzUHJpbnRhYmxlKGMpIHtcbiAgcmV0dXJuICAoMHgwMDAyMCA8PSBjICYmIGMgPD0gMHgwMDAwN0UpXG4gICAgICB8fCAoKDB4MDAwQTEgPD0gYyAmJiBjIDw9IDB4MDBEN0ZGKSAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5KVxuICAgICAgfHwgKCgweDBFMDAwIDw9IGMgJiYgYyA8PSAweDAwRkZGRCkgJiYgYyAhPT0gQ0hBUl9CT00pXG4gICAgICB8fCAgKDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGKTtcbn1cblxuLy8gWzM0XSBucy1jaGFyIDo6PSBuYi1jaGFyIC0gcy13aGl0ZVxuLy8gWzI3XSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrXG4vLyBbMjZdIGItY2hhciAgOjo9IGItbGluZS1mZWVkIHwgYi1jYXJyaWFnZS1yZXR1cm5cbi8vIEluY2x1ZGluZyBzLXdoaXRlIChmb3Igc29tZSByZWFzb24sIGV4YW1wbGVzIGRvZXNuJ3QgbWF0Y2ggc3BlY3MgaW4gdGhpcyBhc3BlY3QpXG4vLyBucy1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItbGluZS1mZWVkIC0gYi1jYXJyaWFnZS1yZXR1cm4gLSBjLWJ5dGUtb3JkZXItbWFya1xuZnVuY3Rpb24gaXNOc0NoYXJPcldoaXRlc3BhY2UoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYylcbiAgICAmJiBjICE9PSBDSEFSX0JPTVxuICAgIC8vIC0gYi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk5cbiAgICAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn1cblxuLy8gWzEyN10gIG5zLXBsYWluLXNhZmUoYykgOjo9IGMgPSBmbG93LW91dCAgXHUyMUQyIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3ctaW4gICBcdTIxRDIgbnMtcGxhaW4tc2FmZS1pblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBibG9jay1rZXkgXHUyMUQyIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3cta2V5ICBcdTIxRDIgbnMtcGxhaW4tc2FmZS1pblxuLy8gWzEyOF0gbnMtcGxhaW4tc2FmZS1vdXQgOjo9IG5zLWNoYXJcbi8vIFsxMjldICBucy1wbGFpbi1zYWZlLWluIDo6PSBucy1jaGFyIC0gYy1mbG93LWluZGljYXRvclxuLy8gWzEzMF0gIG5zLXBsYWluLWNoYXIoYykgOjo9ICAoIG5zLXBsYWluLXNhZmUoYykgLSBcdTIwMUM6XHUyMDFEIC0gXHUyMDFDI1x1MjAxRCApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICggLyogQW4gbnMtY2hhciBwcmVjZWRpbmcgKi8gXHUyMDFDI1x1MjAxRCApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICggXHUyMDFDOlx1MjAxRCAvKiBGb2xsb3dlZCBieSBhbiBucy1wbGFpbi1zYWZlKGMpICovIClcbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYsIGluYmxvY2spIHtcbiAgdmFyIGNJc05zQ2hhck9yV2hpdGVzcGFjZSA9IGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpO1xuICB2YXIgY0lzTnNDaGFyID0gY0lzTnNDaGFyT3JXaGl0ZXNwYWNlICYmICFpc1doaXRlc3BhY2UoYyk7XG4gIHJldHVybiAoXG4gICAgLy8gbnMtcGxhaW4tc2FmZVxuICAgIGluYmxvY2sgPyAvLyBjID0gZmxvdy1pblxuICAgICAgY0lzTnNDaGFyT3JXaGl0ZXNwYWNlXG4gICAgICA6IGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgICAvLyAtIGMtZmxvdy1pbmRpY2F0b3JcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgKVxuICAgIC8vIG5zLXBsYWluLWNoYXJcbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQIC8vIGZhbHNlIG9uICcjJ1xuICAgICYmICEocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiAhY0lzTnNDaGFyKSAvLyBmYWxzZSBvbiAnOiAnXG4gICAgfHwgKGlzTnNDaGFyT3JXaGl0ZXNwYWNlKHByZXYpICYmICFpc1doaXRlc3BhY2UocHJldikgJiYgYyA9PT0gQ0hBUl9TSEFSUCkgLy8gY2hhbmdlIHRvIHRydWUgb24gJ1teIF0jJ1xuICAgIHx8IChwcmV2ID09PSBDSEFSX0NPTE9OICYmIGNJc05zQ2hhcik7IC8vIGNoYW5nZSB0byB0cnVlIG9uICc6W14gXSdcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgLy8gTm8gc3VwcG9ydCBvZiAoICggXHUyMDFDP1x1MjAxRCB8IFx1MjAxQzpcdTIwMUQgfCBcdTIwMUMtXHUyMDFEICkgLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSkgKi8gKSBwYXJ0XG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiBjICE9PSBDSEFSX0JPTVxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8gXHUyMDFDLVx1MjAxRCB8IFx1MjAxQz9cdTIwMUQgfCBcdTIwMUM6XHUyMDFEIHwgXHUyMDFDLFx1MjAxRCB8IFx1MjAxQ1tcdTIwMUQgfCBcdTIwMUNdXHUyMDFEIHwgXHUyMDFDe1x1MjAxRCB8IFx1MjAxQ31cdTIwMURcbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCBcdTIwMUMjXHUyMDFEIHwgXHUyMDFDJlx1MjAxRCB8IFx1MjAxQypcdTIwMUQgfCBcdTIwMUMhXHUyMDFEIHwgXHUyMDFDfFx1MjAxRCB8IFx1MjAxQz1cdTIwMUQgfCBcdTIwMUM+XHUyMDFEIHwgXHUyMDFDJ1x1MjAxRCB8IFx1MjAxQ1wiXHUyMDFEXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUFxuICAgICYmIGMgIT09IENIQVJfQU1QRVJTQU5EXG4gICAgJiYgYyAhPT0gQ0hBUl9BU1RFUklTS1xuICAgICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT05cbiAgICAmJiBjICE9PSBDSEFSX1ZFUlRJQ0FMX0xJTkVcbiAgICAmJiBjICE9PSBDSEFSX0VRVUFMU1xuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwgXHUyMDFDJVx1MjAxRCB8IFx1MjAxQ0BcdTIwMUQgfCBcdTIwMUNgXHUyMDFEKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlTGFzdChjKSB7XG4gIC8vIGp1c3Qgbm90IHdoaXRlc3BhY2Ugb3IgY29sb24sIGl0IHdpbGwgYmUgY2hlY2tlZCB0byBiZSBwbGFpbiBjaGFyYWN0ZXIgbGF0ZXJcbiAgcmV0dXJuICFpc1doaXRlc3BhY2UoYykgJiYgYyAhPT0gQ0hBUl9DT0xPTjtcbn1cblxuLy8gU2FtZSBhcyAnc3RyaW5nJy5jb2RlUG9pbnRBdChwb3MpLCBidXQgd29ya3MgaW4gb2xkZXIgYnJvd3NlcnMuXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHJpbmcsIHBvcykge1xuICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChwb3MpLCBzZWNvbmQ7XG4gIGlmIChmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIHBvcyArIDEgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICByZXR1cm4gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpIHtcbiAgdmFyIGxlYWRpbmdTcGFjZVJlID0gL15cXG4qIC87XG4gIHJldHVybiBsZWFkaW5nU3BhY2VSZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsXG4gIHRlc3RBbWJpZ3VvdXNUeXBlLCBxdW90aW5nVHlwZSwgZm9yY2VRdW90ZXMsIGluYmxvY2spIHtcblxuICB2YXIgaTtcbiAgdmFyIGNoYXIgPSAwO1xuICB2YXIgcHJldkNoYXIgPSBudWxsO1xuICB2YXIgaGFzTGluZUJyZWFrID0gZmFsc2U7XG4gIHZhciBoYXNGb2xkYWJsZUxpbmUgPSBmYWxzZTsgLy8gb25seSBjaGVja2VkIGlmIHNob3VsZFRyYWNrV2lkdGhcbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3QoY29kZVBvaW50QXQoc3RyaW5nLCAwKSlcbiAgICAgICAgICAmJiBpc1BsYWluU2FmZUxhc3QoY29kZVBvaW50QXQoc3RyaW5nLCBzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSB8fCBmb3JjZVF1b3Rlcykge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldkNoYXIsIGluYmxvY2spO1xuICAgICAgcHJldkNoYXIgPSBjaGFyO1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIHRoZSBlbmQgaXMgbWlzc2luZyBhIFxcblxuICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCAoc2hvdWxkVHJhY2tXaWR0aCAmJlxuICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKSk7XG4gIH1cbiAgLy8gQWx0aG91Z2ggZXZlcnkgc3R5bGUgY2FuIHJlcHJlc2VudCBcXG4gd2l0aG91dCBlc2NhcGluZywgcHJlZmVyIGJsb2NrIHN0eWxlc1xuICAvLyBmb3IgbXVsdGlsaW5lLCBzaW5jZSB0aGV5J3JlIG1vcmUgcmVhZGFibGUgYW5kIHRoZXkgZG9uJ3QgYWRkIGVtcHR5IGxpbmVzLlxuICAvLyBBbHNvIHByZWZlciBmb2xkaW5nIGEgc3VwZXItbG9uZyBsaW5lLlxuICBpZiAoIWhhc0xpbmVCcmVhayAmJiAhaGFzRm9sZGFibGVMaW5lKSB7XG4gICAgLy8gU3RyaW5ncyBpbnRlcnByZXRhYmxlIGFzIGFub3RoZXIgdHlwZSBoYXZlIHRvIGJlIHF1b3RlZDtcbiAgICAvLyBlLmcuIHRoZSBzdHJpbmcgJ3RydWUnIHZzLiB0aGUgYm9vbGVhbiB0cnVlLlxuICAgIGlmIChwbGFpbiAmJiAhZm9yY2VRdW90ZXMgJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBTVFlMRV9QTEFJTjtcbiAgICB9XG4gICAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoaW5kZW50UGVyTGV2ZWwgPiA5ICYmIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSkge1xuICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGJsb2NrIHN0eWxlcyBhcmUgdmFsaWQuXG4gIC8vIFByZWZlciBsaXRlcmFsIHN0eWxlIHVubGVzcyB3ZSB3YW50IHRvIGZvbGQuXG4gIGlmICghZm9yY2VRdW90ZXMpIHtcbiAgICByZXR1cm4gaGFzRm9sZGFibGVMaW5lID8gU1RZTEVfRk9MREVEIDogU1RZTEVfTElURVJBTDtcbiAgfVxuICByZXR1cm4gcXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyBTVFlMRV9ET1VCTEUgOiBTVFlMRV9TSU5HTEU7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAgXHUyMDIyIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICBcdTIwMjIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXksIGluYmxvY2spIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICdcIlwiJyA6IFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUpIHtcbiAgICAgIGlmIChERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKHN0cmluZykgIT09IC0xIHx8IERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gKCdcIicgKyBzdHJpbmcgKyAnXCInKSA6IChcIidcIiArIHN0cmluZyArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ICogTWF0aC5tYXgoMSwgbGV2ZWwpOyAvLyBubyAwLWluZGVudCBzY2FsYXJzXG4gICAgLy8gQXMgaW5kZW50YXRpb24gZ2V0cyBkZWVwZXIsIGxldCB0aGUgd2lkdGggZGVjcmVhc2UgbW9ub3RvbmljYWxseVxuICAgIC8vIHRvIHRoZSBsb3dlciBib3VuZCBtaW4oc3RhdGUubGluZVdpZHRoLCA0MCkuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaW1wbGllc1xuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggXHUyMjY0IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBpcyBmaXhlZCBhdCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCA+IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBkZWNyZWFzZXMgdW50aWwgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vIFRoaXMgYmVoYXZlcyBiZXR0ZXIgdGhhbiBhIGNvbnN0YW50IG1pbmltdW0gd2lkdGggd2hpY2ggZGlzYWxsb3dzIG5hcnJvd2VyIG9wdGlvbnMsXG4gICAgLy8gb3IgYW4gaW5kZW50IHRocmVzaG9sZCB3aGljaCBjYXVzZXMgdGhlIHdpZHRoIHRvIHN1ZGRlbmx5IGluY3JlYXNlLlxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xXG4gICAgICA/IC0xIDogTWF0aC5tYXgoTWF0aC5taW4oc3RhdGUubGluZVdpZHRoLCA0MCksIHN0YXRlLmxpbmVXaWR0aCAtIGluZGVudCk7XG5cbiAgICAvLyBXaXRob3V0IGtub3dpbmcgaWYga2V5cyBhcmUgaW1wbGljaXQvZXhwbGljaXQsIGFzc3VtZSBpbXBsaWNpdCBmb3Igc2FmZXR5LlxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5XG4gICAgICAvLyBObyBibG9jayBzdHlsZXMgaW4gZmxvdyBtb2RlLlxuICAgICAgfHwgKHN0YXRlLmZsb3dMZXZlbCA+IC0xICYmIGxldmVsID49IHN0YXRlLmZsb3dMZXZlbCk7XG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCxcbiAgICAgIHRlc3RBbWJpZ3VpdHksIHN0YXRlLnF1b3RpbmdUeXBlLCBzdGF0ZS5mb3JjZVF1b3RlcyAmJiAhaXNrZXksIGluYmxvY2spKSB7XG5cbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICBjYXNlIFNUWUxFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nLnJlcGxhY2UoLycvZywgXCInJ1wiKSArIFwiJ1wiO1xuICAgICAgY2FzZSBTVFlMRV9MSVRFUkFMOlxuICAgICAgICByZXR1cm4gJ3wnICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoc3RyaW5nLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRk9MREVEOlxuICAgICAgICByZXR1cm4gJz4nICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoZm9sZFN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCksIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9ET1VCTEU6XG4gICAgICAgIHJldHVybiAnXCInICsgZXNjYXBlU3RyaW5nKHN0cmluZykgKyAnXCInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8vIFByZS1jb25kaXRpb25zOiBzdHJpbmcgaXMgdmFsaWQgZm9yIGEgYmxvY2sgc2NhbGFyLCAxIDw9IGluZGVudFBlckxldmVsIDw9IDkuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc1x1MjAxNFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcl07XG5cbiAgICBpZiAoIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ1tpXTtcbiAgICAgIGlmIChjaGFyID49IDB4MTAwMDApIHJlc3VsdCArPSBzdHJpbmdbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdmFsdWU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFsdWUgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBTdHJpbmcoaW5kZXgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cywgcHV0IG51bGwgaW5zdGVhZCBvZiBpbnZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgbnVsbCwgZmFsc2UsIGZhbHNlKSkpIHtcblxuICAgICAgaWYgKF9yZXN1bHQgIT09ICcnKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIHZhbHVlLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkpKSB7XG5cbiAgICAgIGlmICghY29tcGFjdCB8fCBfcmVzdWx0ICE9PSAnJykge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChfcmVzdWx0ICE9PSAnJykgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgaWYgKHN0YXRlLmNvbmRlbnNlRmxvdykgcGFpckJ1ZmZlciArPSAnXCInO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgb2JqZWN0VmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJycpICsgJzonICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICcnIDogJyAnKTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIGlmIChleHBsaWNpdCkge1xuICAgICAgICBpZiAodHlwZS5tdWx0aSAmJiB0eXBlLnJlcHJlc2VudE5hbWUpIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnJlcHJlc2VudE5hbWUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSwgaXNibG9ja3NlcSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcbiAgdmFyIGluYmxvY2sgPSBibG9jaztcbiAgdmFyIHRhZ1N0cjtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLm5vQXJyYXlJbmRlbnQgJiYgIWlzYmxvY2tzZXEgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCAtIDEsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXksIGluYmxvY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgLy8gTmVlZCB0byBlbmNvZGUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IHRob3NlIGFsbG93ZWQgYnkgdGhlIHNwZWM6XG4gICAgICAvL1xuICAgICAgLy8gWzM1XSBucy1kZWMtZGlnaXQgICAgOjo9ICBbI3gzMC0jeDM5XSAvKiAwLTkgKi9cbiAgICAgIC8vIFszNl0gbnMtaGV4LWRpZ2l0ICAgIDo6PSAgbnMtZGVjLWRpZ2l0XG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IFsjeDQxLSN4NDZdIC8qIEEtRiAqLyB8IFsjeDYxLSN4NjZdIC8qIGEtZiAqL1xuICAgICAgLy8gWzM3XSBucy1hc2NpaS1sZXR0ZXIgOjo9ICBbI3g0MS0jeDVBXSAvKiBBLVogKi8gfCBbI3g2MS0jeDdBXSAvKiBhLXogKi9cbiAgICAgIC8vIFszOF0gbnMtd29yZC1jaGFyICAgIDo6PSAgbnMtZGVjLWRpZ2l0IHwgbnMtYXNjaWktbGV0dGVyIHwgXHUyMDFDLVx1MjAxRFxuICAgICAgLy8gWzM5XSBucy11cmktY2hhciAgICAgOjo9ICBcdTIwMUMlXHUyMDFEIG5zLWhleC1kaWdpdCBucy1oZXgtZGlnaXQgfCBucy13b3JkLWNoYXIgfCBcdTIwMUMjXHUyMDFEXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IFx1MjAxQztcdTIwMUQgfCBcdTIwMUMvXHUyMDFEIHwgXHUyMDFDP1x1MjAxRCB8IFx1MjAxQzpcdTIwMUQgfCBcdTIwMUNAXHUyMDFEIHwgXHUyMDFDJlx1MjAxRCB8IFx1MjAxQz1cdTIwMUQgfCBcdTIwMUMrXHUyMDFEIHwgXHUyMDFDJFx1MjAxRCB8IFx1MjAxQyxcdTIwMURcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwgXHUyMDFDX1x1MjAxRCB8IFx1MjAxQy5cdTIwMUQgfCBcdTIwMUMhXHUyMDFEIHwgXHUyMDFDflx1MjAxRCB8IFx1MjAxQypcdTIwMUQgfCBcdTIwMUMnXHUyMDFEIHwgXHUyMDFDKFx1MjAxRCB8IFx1MjAxQylcdTIwMUQgfCBcdTIwMUNbXHUyMDFEIHwgXHUyMDFDXVx1MjAxRFxuICAgICAgLy9cbiAgICAgIC8vIEFsc28gbmVlZCB0byBlbmNvZGUgJyEnIGJlY2F1c2UgaXQgaGFzIHNwZWNpYWwgbWVhbmluZyAoZW5kIG9mIHRhZyBwcmVmaXgpLlxuICAgICAgLy9cbiAgICAgIHRhZ1N0ciA9IGVuY29kZVVSSShcbiAgICAgICAgc3RhdGUudGFnWzBdID09PSAnIScgPyBzdGF0ZS50YWcuc2xpY2UoMSkgOiBzdGF0ZS50YWdcbiAgICAgICkucmVwbGFjZSgvIS9nLCAnJTIxJyk7XG5cbiAgICAgIGlmIChzdGF0ZS50YWdbMF0gPT09ICchJykge1xuICAgICAgICB0YWdTdHIgPSAnIScgKyB0YWdTdHI7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1N0ci5zbGljZSgwLCAxOCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjonKSB7XG4gICAgICAgIHRhZ1N0ciA9ICchIScgKyB0YWdTdHIuc2xpY2UoMTgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnU3RyID0gJyE8JyArIHRhZ1N0ciArICc+JztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZHVtcCA9IHRhZ1N0ciArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgZHVtcF8xID0gZHVtcCQxO1xuXG52YXIgZHVtcGVyID0ge1xuXHRkdW1wOiBkdW1wXzFcbn07XG5cbmZ1bmN0aW9uIHJlbmFtZWQoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHlhbWwuJyArIGZyb20gKyAnIGlzIHJlbW92ZWQgaW4ganMteWFtbCA0LiAnICtcbiAgICAgICdVc2UgeWFtbC4nICsgdG8gKyAnIGluc3RlYWQsIHdoaWNoIGlzIG5vdyBzYWZlIGJ5IGRlZmF1bHQuJyk7XG4gIH07XG59XG5cblxudmFyIFR5cGUgICAgICAgICAgICAgICAgPSB0eXBlO1xudmFyIFNjaGVtYSAgICAgICAgICAgICAgPSBzY2hlbWE7XG52YXIgRkFJTFNBRkVfU0NIRU1BICAgICA9IGZhaWxzYWZlO1xudmFyIEpTT05fU0NIRU1BICAgICAgICAgPSBqc29uO1xudmFyIENPUkVfU0NIRU1BICAgICAgICAgPSBjb3JlO1xudmFyIERFRkFVTFRfU0NIRU1BICAgICAgPSBfZGVmYXVsdDtcbnZhciBsb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG52YXIgbG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xudmFyIGR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gZXhjZXB0aW9uO1xuXG4vLyBSZS1leHBvcnQgYWxsIHR5cGVzIGluIGNhc2UgdXNlciB3YW50cyB0byBjcmVhdGUgY3VzdG9tIHNjaGVtYVxudmFyIHR5cGVzID0ge1xuICBiaW5hcnk6ICAgIGJpbmFyeSxcbiAgZmxvYXQ6ICAgICBmbG9hdCxcbiAgbWFwOiAgICAgICBtYXAsXG4gIG51bGw6ICAgICAgX251bGwsXG4gIHBhaXJzOiAgICAgcGFpcnMsXG4gIHNldDogICAgICAgc2V0LFxuICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgYm9vbDogICAgICBib29sLFxuICBpbnQ6ICAgICAgIGludCxcbiAgbWVyZ2U6ICAgICBtZXJnZSxcbiAgb21hcDogICAgICBvbWFwLFxuICBzZXE6ICAgICAgIHNlcSxcbiAgc3RyOiAgICAgICBzdHJcbn07XG5cbi8vIFJlbW92ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAzLjAueFxudmFyIHNhZmVMb2FkICAgICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZCcsICdsb2FkJyk7XG52YXIgc2FmZUxvYWRBbGwgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVMb2FkQWxsJywgJ2xvYWRBbGwnKTtcbnZhciBzYWZlRHVtcCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUR1bXAnLCAnZHVtcCcpO1xuXG52YXIganNZYW1sID0ge1xuXHRUeXBlOiBUeXBlLFxuXHRTY2hlbWE6IFNjaGVtYSxcblx0RkFJTFNBRkVfU0NIRU1BOiBGQUlMU0FGRV9TQ0hFTUEsXG5cdEpTT05fU0NIRU1BOiBKU09OX1NDSEVNQSxcblx0Q09SRV9TQ0hFTUE6IENPUkVfU0NIRU1BLFxuXHRERUZBVUxUX1NDSEVNQTogREVGQVVMVF9TQ0hFTUEsXG5cdGxvYWQ6IGxvYWQsXG5cdGxvYWRBbGw6IGxvYWRBbGwsXG5cdGR1bXA6IGR1bXAsXG5cdFlBTUxFeGNlcHRpb246IFlBTUxFeGNlcHRpb24sXG5cdHR5cGVzOiB0eXBlcyxcblx0c2FmZUxvYWQ6IHNhZmVMb2FkLFxuXHRzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGwsXG5cdHNhZmVEdW1wOiBzYWZlRHVtcFxufTtcblxuZXhwb3J0IGRlZmF1bHQganNZYW1sO1xuZXhwb3J0IHsgQ09SRV9TQ0hFTUEsIERFRkFVTFRfU0NIRU1BLCBGQUlMU0FGRV9TQ0hFTUEsIEpTT05fU0NIRU1BLCBTY2hlbWEsIFR5cGUsIFlBTUxFeGNlcHRpb24sIGR1bXAsIGxvYWQsIGxvYWRBbGwsIHNhZmVEdW1wLCBzYWZlTG9hZCwgc2FmZUxvYWRBbGwsIHR5cGVzIH07XG4iLCAiLy8gTm90ZTogRmlsZUNhY2hlIGNsYXNzXHJcblxyXG5pbXBvcnQgTG9nZ2luZyBmcm9tIFwic3JjL2NsYXNzZXMvTG9nZ2luZ1wiO1xyXG5pbXBvcnQgR2xvYmFsIGZyb20gXCIuLi9jbGFzc2VzL0dsb2JhbFwiO1xyXG5pbXBvcnQgeyBBcHAsIFRBYnN0cmFjdEZpbGUsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogRmlsZUNhY2hlIGNsYXNzXHJcbiAqIEBkZXNjcmlwdGlvbiBDYWNoZXMgdGhlIGZpbGVzIGluIHRoZSB2YXVsdCB3aXRoIGZpbGUgbmFtZSBhcyB0aGUga2V5XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxlQ2FjaGUge1xyXG4gICAgcHJpdmF0ZSBhcHA6IEFwcCA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmFwcDtcclxuICAgIHByaXZhdGUgbG9nZ2VyOiBMb2dnaW5nID0gR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyO1xyXG4gICAgcHJpdmF0ZSBmaWxlQ2FjaGVQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGZpbGVDYWNoZTogTWFwPHN0cmluZywgVEZpbGUgfCBudWxsPiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBkdXBsaWNhdGVOYW1lczogTWFwPHN0cmluZywgQXJyYXk8VEZpbGU+PiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBmaWxlQ2FjaGVSZWFkeSA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBldmVudHNSZWdpc3RlcmVkID0gZmFsc2U7XHJcblxyXG4gICAgc3RhdGljIGluc3RhbmNlOiBGaWxlQ2FjaGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBGaWxlQ2FjaGUgaW5zdGFuY2UgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMgVGhlIEZpbGVDYWNoZSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgaWYgKCFGaWxlQ2FjaGUuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgRmlsZUNhY2hlLmluc3RhbmNlID0gbmV3IEZpbGVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRmlsZUNhY2hlLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGaWxlQ2FjaGUgaW5zdGFuY2VcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmlsZUNhY2hlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRGaWxlQ2FjaGUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRmlsZSBDYWNoZSBidWlsdFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3JlYXRlRXZlbnRIYW5kbGVyID0gdGhpcy5jcmVhdGVFdmVudEhhbmRsZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlbmFtZUV2ZW50SGFuZGxlciA9IHRoaXMucmVuYW1lRXZlbnRIYW5kbGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kZWxldGVFdmVudEhhbmRsZXIgPSB0aGlzLmRlbGV0ZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29uc3RydWN0cyB0aGUgRmlsZUNhY2hlIGluc3RhbmNlXHJcbiAgICAgKiB1bnJlZ2lzdGVycyBhbGwgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGlmICghRmlsZUNhY2hlLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlci5lcnJvcihcIkZpbGVDYWNoZSBpbnN0YW5jZSBub3QgbG9hZGVkXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEZpbGVDYWNoZS5pbnN0YW5jZTtcclxuXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmV2ZW50c1JlZ2lzdGVyZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwLnZhdWx0Lm9mZigncmVuYW1lJywgaW5zdGFuY2UucmVuYW1lRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwLnZhdWx0Lm9mZignZGVsZXRlJywgaW5zdGFuY2UuZGVsZXRlRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwLnZhdWx0Lm9mZignY3JlYXRlJywgaW5zdGFuY2UuY3JlYXRlRXZlbnRIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgIGluc3RhbmNlLmV2ZW50c1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlci5kZWJ1ZyhcIkZpbGUgY2FjaGUgZXZlbnRzIHVucmVnaXN0ZXJlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyLmRlYnVnKFwiRmlsZSBjYWNoZSBldmVudHMgbm90IHJlZ2lzdGVyZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciB0aGUgZmlsZSBjYWNoZSB0byBiZSByZWFkeVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBmaWxlIGNhY2hlIGlzIHJlYWR5XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBmaWxlIGNhY2hlIGlzIHJlYWR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgd2FpdEZvckNhY2hlUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgd2hpbGUgKCF0aGlzLmZpbGVDYWNoZVJlYWR5KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSBmaWxlIGNhY2hlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZmlsZSBjYWNoZSBpcyBidWlsdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZEZpbGVDYWNoZSgpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKTtcclxuICAgICAgICB0aGlzLmZpbGVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBURmlsZSB8IG51bGw+KCk7XHJcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVOYW1lcyA9IG5ldyBNYXA8c3RyaW5nLCBBcnJheTxURmlsZT4+KCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBhbGxGaWxlcykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVudHJ5KGZpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5maWxlQ2FjaGVSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGaWxlIGNhY2hlIGZvciAke2FsbEZpbGVzLmxlbmd0aH0gZmlsZXMgYnVpbHQgaW4gJHtlbmRUaW1lIC0gc3RhcnRUaW1lfW1zYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBmaWxlIGNhY2hlIHdpdGggdGhlIG5ldyBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byBhZGQgdG8gdGhlIGNhY2hlXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBmaWxlIHdhcyBhZGRlZCB0byB0aGUgY2FjaGUsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRFbnRyeShmaWxlOiBURmlsZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5maWxlQ2FjaGUpIHsgdGhpcy5sb2dnZXIuZXJyb3IoXCJGaWxlIGNhY2hlIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIGxldCBzdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdGaWxlID0gdGhpcy5maWxlQ2FjaGUuZ2V0KGZpbGUubmFtZSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nRmlsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZUNhY2hlLnNldChmaWxlLm5hbWUsIGZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdGaWxlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlICYmPSB0aGlzLmFkZER1cGxpY2F0ZUVudHJ5KFtmaWxlXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGUgJiY9IHRoaXMuYWRkRHVwbGljYXRlRW50cnkoW2V4aXN0aW5nRmlsZSwgZmlsZV0pO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVDYWNoZS5zZXQoZmlsZS5uYW1lLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGR1cGxpY2F0ZSBjYWNoZSB3aXRoIHRoZSBuZXcgZmlsZVxyXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGVzIHRvIGFkZCB0byB0aGUgY2FjaGVcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGZpbGUgd2FzIGFkZGVkIHRvIHRoZSBjYWNoZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZER1cGxpY2F0ZUVudHJ5KGZpbGU6IEFycmF5PFRGaWxlPikge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5maXJzdCgpPy5uYW1lO1xyXG4gICAgICAgIGlmICghZmlsZU5hbWUpIHsgdGhpcy5sb2dnZXIuZXJyb3IoXCJGaWxlIG5hbWUgbm90IGF2YWlsYWJsZVwiKTsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmR1cGxpY2F0ZU5hbWVzKSB7IHRoaXMubG9nZ2VyLmVycm9yKFwiRHVwbGljYXRlIGNhY2hlIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZUVudHJ5ID0gdGhpcy5kdXBsaWNhdGVOYW1lcy5nZXQoZmlsZU5hbWUpO1xyXG4gICAgICAgIGlmIChkdXBsaWNhdGVFbnRyeSkge1xyXG4gICAgICAgICAgICBmaWxlLmZvckVhY2goZiA9PiBkdXBsaWNhdGVFbnRyeS5wdXNoKGYpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmR1cGxpY2F0ZU5hbWVzLnNldChmaWxlTmFtZSwgZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZmlsZSBmcm9tIHRoZSBkdXBsaWNhdGUgY2FjaGVcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIHJlbW92ZSBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICogQHBhcmFtIG9sZFBhdGggVGhlIG9sZCBwYXRoIG9mIHRoZSBmaWxlXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBmaWxlIHdhcyByZW1vdmVkIGZyb20gdGhlIGNhY2hlLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlRHVwbGljYXRlRW50cnkoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmR1cGxpY2F0ZU5hbWVzKSB7IHRoaXMubG9nZ2VyLmVycm9yKFwiRHVwbGljYXRlIGNhY2hlIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZUVudHJ5ID0gdGhpcy5kdXBsaWNhdGVOYW1lcy5nZXQoZmlsZS5uYW1lKTtcclxuICAgICAgICBpZiAoIWR1cGxpY2F0ZUVudHJ5KSB7IHRoaXMubG9nZ2VyLmVycm9yKFwiRmlsZSAke2ZpbGUubmFtZX0gbm90IGZvdW5kIGluIGR1cGxpY2F0ZSBjYWNoZVwiKTsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IG9sZFBhdGggPz8gZmlsZS5wYXRoO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZHVwbGljYXRlRW50cnkuZmluZEluZGV4KGYgPT4gZi5wYXRoID09PSBwYXRoKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBkdXBsaWNhdGVFbnRyeS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGaWxlICR7ZmlsZS5uYW1lfSBub3QgZm91bmQgaW4gZHVwbGljYXRlIGNhY2hlYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWxlIGZyb20gdGhlIGZpbGUgY2FjaGVcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIHJlbW92ZSBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZmlsZSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlbW92ZUVudHJ5KGZpbGU6IFRGaWxlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpbGVDYWNoZSkgeyB0aGlzLmxvZ2dlci5lcnJvcihcIkZpbGUgY2FjaGUgbm90IGF2YWlsYWJsZVwiKTsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0ZpbGUgPSB0aGlzLmZpbGVDYWNoZS5nZXQoZmlsZS5uYW1lKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZUNhY2hlLmRlbGV0ZShmaWxlLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdGaWxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgRmlsZSAke2ZpbGUubmFtZX0gbm90IGZvdW5kIGluIGNhY2hlYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRmlsZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGF0ZSAmJj0gdGhpcy5yZW1vdmVEdXBsaWNhdGVFbnRyeShmaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuYW1lcyB0aGUgZmlsZSBpbiB0aGUgZmlsZSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgdG8gcmVuYW1lXHJcbiAgICAgKiBAcGFyYW0gb2xkUGF0aCBUaGUgb2xkIHBhdGggb2YgdGhlIGZpbGVcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGZpbGUgd2FzIHJlbmFtZWQgaW4gdGhlIGNhY2hlLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuYW1lRW50cnkoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGlmICghdGhpcy5maWxlQ2FjaGUpIHsgdGhpcy5sb2dnZXIuZXJyb3IoXCJGaWxlIGNhY2hlIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIGNvbnN0IG9sZEZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZUZyb21QYXRoKG9sZFBhdGgpO1xyXG4gICAgICAgIGlmICghb2xkRmlsZU5hbWUpIHsgdGhpcy5sb2dnZXIuZXJyb3IoXCJPbGQgZmlsZSBuYW1lIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRmlsZSA9IHRoaXMuZmlsZUNhY2hlLmdldChvbGRGaWxlTmFtZSk7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZUNhY2hlLmRlbGV0ZShvbGRGaWxlTmFtZSk7XHJcbiAgICAgICAgICAgIHN0YXRlICYmPSB0aGlzLmFkZEVudHJ5KGZpbGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdGaWxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgRmlsZSAke29sZEZpbGVOYW1lfSBub3QgZm91bmQgaW4gY2FjaGVgKTtcclxuICAgICAgICAgICAgc3RhdGUgJiY9IHRoaXMuYWRkRW50cnkoZmlsZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0ZpbGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhdGUgJiY9IHRoaXMucmVtb3ZlRHVwbGljYXRlRW50cnkoZmlsZSwgb2xkUGF0aCk7XHJcbiAgICAgICAgICAgIHN0YXRlICYmPSB0aGlzLmFkZER1cGxpY2F0ZUVudHJ5KFtmaWxlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSBjcmVhdGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIGNyZWF0ZSBpbiB0aGUgZmlsZSBjYWNoZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVFdmVudEhhbmRsZXIoZmlsZTogVEFic3RyYWN0RmlsZSkge1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICBzdGF0ZSAmJj0gdGhpcy5hZGRFbnRyeShmaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGaWxlICR7ZmlsZS5uYW1lfSBjcmVhdGUgaW4gZmlsZSBjYWNoZSBldmVudCBoYW5kbGVyIHN1Y2Nlc3NgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRXJyb3IgY3JlYXRpbmcgZmlsZSAke2ZpbGUubmFtZX0gaW4gZmlsZSBjYWNoZSBldmVudCBoYW5kbGVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgaGFuZGxlciBmb3IgdGhlIHJlbmFtZSBldmVudFxyXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgdG8gcmVuYW1lIGluIHRoZSBmaWxlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gb2xkUGF0aCBUaGUgb2xkIHBhdGggb2YgdGhlIGZpbGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuYW1lRXZlbnRIYW5kbGVyKGZpbGU6IFRBYnN0cmFjdEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRGaWxlTmFtZSA9IG9sZFBhdGguc3BsaXQoJy8nKS5sYXN0KCk7XHJcbiAgICAgICAgICAgIGlmICghb2xkRmlsZU5hbWUpIHsgdGhpcy5sb2dnZXIuZXJyb3IoXCJDYW5ub3QgZXh0cmFjdCBvbGQgZmlsZSBuYW1lIGZyb20gdGhlIHBhdGhcIik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBzdGF0ZSAmJj0gdGhpcy5yZW5hbWVFbnRyeShmaWxlLCBvbGRGaWxlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmlsZSAke2ZpbGUubmFtZX0gcmVuYW1lZCBpbiBmaWxlIGNhY2hlIGV2ZW50IGhhbmRsZXIgc3VjY2Vzc2ApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvciByZW5hbWluZyBmaWxlICR7ZmlsZS5uYW1lfSBpbiBmaWxlIGNhY2hlIGV2ZW50IGhhbmRsZXJgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciB0aGUgZGVsZXRlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byBkZWxldGUgaW4gdGhlIGZpbGUgY2FjaGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGVsZXRlRXZlbnRIYW5kbGVyKGZpbGU6IFRBYnN0cmFjdEZpbGUpIHtcclxuICAgICAgICBsZXQgc3RhdGUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgc3RhdGUgJiY9IHRoaXMucmVtb3ZlRW50cnkoZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmlsZSAke2ZpbGUubmFtZX0gZGVsZXRlIGluIGZpbGUgY2FjaGUgZXZlbnQgaGFuZGxlciBzdWNjZXNzYCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGZpbGUgJHtmaWxlLm5hbWV9IGluIGZpbGUgY2FjaGUgZXZlbnQgaGFuZGxlcmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyB0aGUgZXZlbnRzIGZvciB0aGUgZmlsZSBjYWNoZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdpc3RlckV2ZW50cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5vbigncmVuYW1lJywgdGhpcy5yZW5hbWVFdmVudEhhbmRsZXIpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQub24oJ2RlbGV0ZScsIHRoaXMuZGVsZXRlRXZlbnRIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCB0aGlzLmNyZWF0ZUV2ZW50SGFuZGxlcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50c1JlZ2lzdGVyZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJGaWxlIGNhY2hlIGV2ZW50cyByZWdpc3RlcmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgbmFtZSBmcm9tIHRoZSBmaWxlIHBhdGhcclxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgZmlsZSBwYXRoIHRvIGV4dHJhY3QgdGhlIGZpbGUgbmFtZSBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlsZSBuYW1lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldEZpbGVOYW1lRnJvbVBhdGgoZmlsZVBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IG9sZEZpbGVOYW1lID0gZmlsZVBhdGguc3BsaXQoJy8nKS5sYXN0KCk7XHJcbiAgICAgICAgaWYgKCFvbGRGaWxlTmFtZSkgeyB0aGlzLmxvZ2dlci5lcnJvcihcIkNhbm5vdCBleHRyYWN0IG9sZCBmaWxlIG5hbWUgZnJvbSB0aGUgcGF0aFwiKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgcmV0dXJuIG9sZEZpbGVOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlsZSBmcm9tIHRoZSBmaWxlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZFxyXG4gICAgICogQHJldHVybnMgVGhlIGZpbGUvcyBpZiBmb3VuZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmluZEZpbGVCeU5hbWUoZmlsZU5hbWU6IHN0cmluZyk6IFRGaWxlIHwgQXJyYXk8VEZpbGU+IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCBmb3VuZEZpbGUgPSB0aGlzLmZpbGVDYWNoZT8uZ2V0KGZpbGVOYW1lKTtcclxuICAgICAgICBpZiAoZm91bmRGaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3VuZEZpbGU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZEZpbGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlRW50cnkgPSB0aGlzLmR1cGxpY2F0ZU5hbWVzPy5nZXQoZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZUVudHJ5KSB7IHRoaXMubG9nZ2VyLmVycm9yKGBGaWxlICR7ZmlsZU5hbWV9IG5vdCBmb3VuZCBpbiBkdXBsaWNhdGUgY2FjaGVgKTsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZHVwbGljYXRlRW50cnk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIGZyb20gdGhlIGZpbGUgY2FjaGVcclxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBmaW5kXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlsZS9zIGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaW5kRmlsZUJ5UGF0aChmaWxlUGF0aDogc3RyaW5nKTogVEZpbGUgfCBBcnJheTxURmlsZT4gfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZUZyb21QYXRoKGZpbGVQYXRoKTtcclxuICAgICAgICBpZiAoIWZpbGVOYW1lKSB7IHRoaXMubG9nZ2VyLmVycm9yKFwiRmlsZSBuYW1lIG5vdCBhdmFpbGFibGVcIik7IHJldHVybiB1bmRlZmluZWQ7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kRmlsZUJ5TmFtZShmaWxlTmFtZSk7XHJcbiAgICB9XHJcblxyXG59IiwgIi8vIE5vdGU6IE1ldGFkYXRhQ2FjaGUgY2xhc3NcclxuXHJcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJzcmMvY2xhc3Nlcy9Mb2dnaW5nXCI7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSBcIi4uL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCB7IEFwcCwgQ2FjaGVkTWV0YWRhdGEsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG4vKipcclxuICogRmlsZU1ldGFkYXRhIGludGVyZmFjZVxyXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCB0byBzdG9yZSB0aGUgZmlsZSBhbmQgdGhlIGNhY2hlZCBtZXRhZGF0YSBpbiB0aGUgbWV0YWRhdGEgY2FjaGUuXHJcbiAqIEBwcm9wZXJ0eSB7VEZpbGV9IGZpbGUgVGhlIGZpbGUgb2JqZWN0XHJcbiAqIEBwcm9wZXJ0eSB7Q2FjaGVkTWV0YWRhdGF9IG1ldGFkYXRhIFRoZSBjYWNoZWQgbWV0YWRhdGFcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGaWxlTWV0YWRhdGEgeyBmaWxlOiBURmlsZTsgbWV0YWRhdGE6IENhY2hlZE1ldGFkYXRhIH1cclxuXHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY2xhc3MgZm9yIGNhY2hpbmcgbWV0YWRhdGFcclxuICogQGRlc2NyaXB0aW9uIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjYWNoZSBtZXRhZGF0YSBmb3IgYWxsIGZpbGVzIGluIHRoZSB2YXVsdC4gSXQgaXMgdXNlZCB0byBzcGVlZCB1cCBwcm9jZXNzaW5nIG9mIGRhdGF2aWV3IHF1ZXJpZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhZGF0YUNhY2hlIHtcclxuICAgIHByaXZhdGUgYXBwOiBBcHAgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5hcHA7XHJcbiAgICBwcml2YXRlIGxvZ2dlcjogTG9nZ2luZyA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlcjtcclxuICAgIHByaXZhdGUgbWV0YWRhdGFDYWNoZVByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgbWV0YWRhdGFDYWNoZTogTWFwPHN0cmluZywgRmlsZU1ldGFkYXRhPiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBtZXRhZGF0YUNhY2hlUmVhZHkgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgZXZlbnRzUmVnaXN0ZXJlZCA9IGZhbHNlO1xyXG5cclxuICAgIHN0YXRpYyBpbnN0YW5jZTogTWV0YWRhdGFDYWNoZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWV0YWRhdGEgY2FjaGVcclxuICAgICAqIEByZXR1cm5zIHtGaWxlTWV0YWRhdGFbXX0gQXJyYXkgb2YgRmlsZU1ldGFkYXRhIG9iamVjdHNcclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBtZXRhZGF0YSBjYWNoZSBhcyBhbiBhcnJheSBvZiBGaWxlTWV0YWRhdGEgb2JqZWN0cy4gVGhlIEZpbGVNZXRhZGF0YSBvYmplY3QgY29udGFpbnMgdGhlIGZpbGUgYW5kIHRoZSBjYWNoZWQgbWV0YWRhdGEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgQ2FjaGUoKTogRmlsZU1ldGFkYXRhW10ge1xyXG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhQ2FjaGVSZWFkeSAmJiB0aGlzLm1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tZXRhZGF0YUNhY2hlLnZhbHVlcygpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIk1ldGFkYXRhIGNhY2hlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBNZXRhZGF0YUNhY2hlIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGFDYWNoZX0gVGhlIE1ldGFkYXRhQ2FjaGUgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmICghTWV0YWRhdGFDYWNoZS5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBNZXRhZGF0YUNhY2hlLmluc3RhbmNlID0gbmV3IE1ldGFkYXRhQ2FjaGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhQ2FjaGUuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIE1ldGFkYXRhQ2FjaGUgY2xhc3NcclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGNvbnN0cnVjdG9yIGlzIHByaXZhdGUgYmVjYXVzZSB0aGUgTWV0YWRhdGFDYWNoZSBjbGFzcyBpcyBhIHNpbmdsZXRvbi4gVXNlIHRoZSBnZXRJbnN0YW5jZSgpIG1ldGhvZCB0byBnZXQgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VkRXZlbnRIYW5kbGVyID0gdGhpcy5jaGFuZ2VkRXZlbnRIYW5kbGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZW5hbWVFdmVudEhhbmRsZXIgPSB0aGlzLnJlbmFtZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVsZXRlRXZlbnRIYW5kbGVyID0gdGhpcy5kZWxldGVFdmVudEhhbmRsZXIuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZE1ldGFkYXRhQ2FjaGUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiTWV0YWRhdGEgY2FjaGUgYnVpbHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29uc3RydWN0b3IgZm9yIHRoZSBNZXRhZGF0YUNhY2hlIGNsYXNzXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2QgaXMgdXNlZCB0byB1bnJlZ2lzdGVyIHRoZSBldmVudCBoYW5kbGVycyBmb3IgdGhlIG1ldGFkYXRhIGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZiAoIU1ldGFkYXRhQ2FjaGUuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyLmVycm9yKFwiTWV0YWRhdGEgY2FjaGUgaW5zdGFuY2Ugbm90IGxvYWRlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBNZXRhZGF0YUNhY2hlLmluc3RhbmNlO1xyXG5cclxuICAgICAgICBpZiAoaW5zdGFuY2UuZXZlbnRzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHAudmF1bHQub2ZmKCdyZW5hbWUnLCBpbnN0YW5jZS5yZW5hbWVFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHAubWV0YWRhdGFDYWNoZS5vZmYoJ2NoYW5nZWQnLCBpbnN0YW5jZS5jaGFuZ2VkRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwLm1ldGFkYXRhQ2FjaGUub2ZmKCdkZWxldGVkJywgaW5zdGFuY2UuZGVsZXRlRXZlbnRIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgIGluc3RhbmNlLmV2ZW50c1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlci5kZWJ1ZyhcIk1ldGFkYXRhIGNhY2hlIGV2ZW50cyB1bnJlZ2lzdGVyZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlci5kZWJ1ZyhcIk1ldGFkYXRhIGNhY2hlIGV2ZW50cyBub3QgcmVnaXN0ZXJlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBtZXRhZGF0YSBjYWNoZSBpcyByZWFkeVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1ldGFkYXRhIGNhY2hlIGlzIHJlYWR5LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzQ2FjaGVSZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUNhY2hlUmVhZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciB0aGUgbWV0YWRhdGEgY2FjaGUgdG8gYmUgcmVhZHlcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbWV0YWRhdGEgY2FjaGUgaXMgcmVhZHlcclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG1ldGFkYXRhIGNhY2hlIGlzIHJlYWR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgd2FpdEZvckNhY2hlUmVhZHkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgd2hpbGUgKCF0aGlzLm1ldGFkYXRhQ2FjaGVSZWFkeSkge1xyXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIHRoZSBtZXRhZGF0YSBjYWNoZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRhZGF0YSBjYWNoZSBpcyBidWlsdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGJ1aWxkTWV0YWRhdGFDYWNoZSgpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgRmlsZU1ldGFkYXRhPigpO1xyXG4gICAgICAgIGNvbnN0IGFsbEZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWRkRW50cnlQcm9taXNlcyA9IGFsbEZpbGVzLm1hcChmaWxlID0+IHRoaXMuYWRkRW50cnkoZmlsZSkpO1xyXG5cclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhZGRFbnRyeVByb21pc2VzKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlUmVhZHkgPSB0cnVlO1xyXG5cclxuICAgICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgTWV0YWRhdGEgY2FjaGUgZm9yICR7YWxsRmlsZXMubGVuZ3RofSBmaWxlcyBidWlsdCBpbiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIG1ldGFkYXRhIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byBhZGQgdG8gdGhlIG1ldGFkYXRhIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgYWRkRW50cnkoZmlsZTogVEZpbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlLnNldChmaWxlLnBhdGgsIHsgZmlsZSwgbWV0YWRhdGEgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBObyBtZXRhZGF0YSBmb3VuZCBmb3IgZmlsZSAke2ZpbGUucGF0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTWV0YWRhdGEgY2FjaGUgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhIGZpbGUgZnJvbSB0aGUgbWV0YWRhdGEgY2FjaGVcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIGRlbGV0ZSBmcm9tIHRoZSBtZXRhZGF0YSBjYWNoZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRlbGV0ZUVudHJ5KGZpbGU6IFRGaWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFDYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGUucGF0aCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJNZXRhZGF0YSBjYWNoZSBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBNZXRhZGF0YSBjYWNoZSBlbnRyeSBmb3IgZmlsZSAke2ZpbGUucGF0aH0gZGVsZXRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGEgZmlsZSBpbiB0aGUgbWV0YWRhdGEgY2FjaGVcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIHVwZGF0ZSBpbiB0aGUgbWV0YWRhdGEgY2FjaGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVFbnRyeShmaWxlOiBURmlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KGZpbGUucGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeSAmJiBtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZW50cnkubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYE5vIG1ldGFkYXRhIGNhY2hlIGVudHJ5IGZvdW5kIGZvciBmaWxlICR7ZmlsZS5wYXRofWApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgTm8gbWV0YWRhdGEgZm91bmQgZm9yIGZpbGUgJHtmaWxlLnBhdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIk1ldGFkYXRhIGNhY2hlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYE1ldGFkYXRhIGNhY2hlIGVudHJ5IGZvciBmaWxlICR7ZmlsZS5wYXRofSB1cGRhdGVkYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5hbWUgYSBmaWxlIGluIHRoZSBtZXRhZGF0YSBjYWNoZVxyXG4gICAgICogQHBhcmFtIG5ld0ZpbGUgVGhlIG5ldyBmaWxlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIG9sZFBhdGggVGhlIG9sZCBwYXRoIG9mIHRoZSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgcmVuYW1lRW50cnkobmV3RmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KG9sZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUgPSBuZXdGaWxlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgTm8gbWV0YWRhdGEgY2FjaGUgZW50cnkgZm91bmQgZm9yIGZpbGUgJHtvbGRQYXRofWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJNZXRhZGF0YSBjYWNoZSBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBNZXRhZGF0YSBjYWNoZSBlbnRyeSBmb3IgZmlsZSAke29sZFBhdGh9IHJlbmFtZWQgdG8gJHtuZXdGaWxlLnBhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciB0aGUgcmVuYW1lIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gZmlsZSBOZXcgZmlsZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBvbGRQYXRoIE9sZCBwYXRoIG9mIHRoZSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVuYW1lRXZlbnRIYW5kbGVyKGZpbGU6IFRGaWxlLCBvbGRQYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmlsZSAke2ZpbGUucGF0aH0gcmVuYW1lZCB0byAke29sZFBhdGh9YCk7XHJcbiAgICAgICAgdGhpcy5yZW5hbWVFbnRyeShmaWxlLCBvbGRQYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSBkZWxldGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSBmaWxlIERlbGV0ZWQgZmlsZSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkZWxldGVFdmVudEhhbmRsZXIoZmlsZTogVEZpbGUpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmlsZSAke2ZpbGUucGF0aH0gZGVsZXRlZGApO1xyXG4gICAgICAgIHRoaXMuZGVsZXRlRW50cnkoZmlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciB0aGUgY2hhbmdlZCBldmVudFxyXG4gICAgICogQHBhcmFtIGZpbGUgQ2hhbmdlZCBmaWxlIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoYW5nZWRFdmVudEhhbmRsZXIoZmlsZTogVEZpbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KGZpbGUucGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0VudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVudHJ5KGZpbGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbnRyeShmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlZHJhd01hcmtkb3duVmlldygpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgUmVkcmF3aW5nIG1hcmtkb3duIHZpZXdgKTtcclxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UudXBkYXRlT3B0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtZXRhZGF0YSBjYWNoZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyRXZlbnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ldmVudHNSZWdpc3RlcmVkKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5vbigncmVuYW1lJywgdGhpcy5yZW5hbWVFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKCdjaGFuZ2VkJywgdGhpcy5jaGFuZ2VkRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbignZGVsZXRlZCcsIHRoaXMuZGVsZXRlRXZlbnRIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzUmVnaXN0ZXJlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk1ldGFkYXRhIGNhY2hlIGV2ZW50cyByZWdpc3RlcmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG4vKipcclxuICogTG9nZ2luZyBjbGFzczsgZW5jYXBzdWxhdGVzIGNvbnNvbGUubG9nLCBjb25zb2xlLmRlYnVnLCBjb25zb2xlLndhcm4gYW5kIGNvbnNvbGUuZXJyb3JcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2dpbmcge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IExvZ2dpbmc7XHJcbiAgICBwcml2YXRlIGxvZ0xldmVsOiBMb2dnaW5nTGV2ZWw7XHJcbiAgICBwcml2YXRlIGxvZ1ByZWZpeDogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBMb2dnaW5nIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gbG9nTGV2ZWwgVGhlIGxvZyBsZXZlbCB0byB1c2UuIERlZmF1bHRzIHRvIFwiaW5mb1wiXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvZ0xldmVsOiBMb2dnaW5nTGV2ZWwgPSBcImluZm9cIiwgbG9nUHJlZml4ID0gXCJcIikge1xyXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbDtcclxuICAgICAgICB0aGlzLmxvZ1ByZWZpeCA9IGAke2xvZ1ByZWZpeH06IGA7XHJcbiAgICAgICAgaWYgKHRoaXMubG9nTGV2ZWwgPT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxvZ2dpbmcgZGlzYWJsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExvZ2dpbmcuaW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRMb2dMZXZlbChsb2dMZXZlbDogTG9nZ2luZ0xldmVsKSB7XHJcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgTG9nIGxldmVsIHNldCB0byAke2xvZ0xldmVsfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgTG9nZ2luZyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IExvZ2dpbmcge1xyXG4gICAgICAgIGlmICghTG9nZ2luZy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBMb2dnaW5nLmluc3RhbmNlID0gbmV3IExvZ2dpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExvZ2dpbmcuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZSBpZiB0aGUgbG9nIGxldmVsIGlzIFwidHJhY2VcIlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxQYXJhbXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFjZShtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5sb2dMZXZlbEFjdGl2ZShcInRyYWNlXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdExvZ01lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobG9nTWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgYSBtZXNzYWdlIHRvIHRoZSBjb25zb2xlIGlmIHRoZSBsb2cgbGV2ZWwgaXMgXCJkZWJ1Z1wiXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBcclxuICAgICAqIEBwYXJhbSBvcHRpb25hbFBhcmFtcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlYnVnKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsQWN0aXZlKFwiZGVidWdcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9nTWVzc2FnZSA9IHRoaXMuY29uc3RydWN0TG9nTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc29sZS5kZWJ1Zyhsb2dNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUgaWYgdGhlIGxvZyBsZXZlbCBpcyBcImluZm9cIiBvciBcImRlYnVnXCJcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsUGFyYW1zIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5mbyhtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5sb2dMZXZlbEFjdGl2ZShcImluZm9cIikpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9nTWVzc2FnZSA9IHRoaXMuY29uc3RydWN0TG9nTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGxvZ01lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZSBpZiB0aGUgbG9nIGxldmVsIGlzIFwiaW5mb1wiLCBcImRlYnVnXCIgb3IgXCJ3YXJuXCJcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFxyXG4gICAgICogQHBhcmFtIG9wdGlvbmFsUGFyYW1zIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd2FybihtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5sb2dMZXZlbEFjdGl2ZShcIndhcm5cIikpIHtcclxuICAgICAgICAgICAgY29uc3QgbG9nTWVzc2FnZSA9IHRoaXMuY29uc3RydWN0TG9nTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGxvZ01lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZSBpZiB0aGUgbG9nIGxldmVsIGlzIFwiaW5mb1wiLCBcImRlYnVnXCIsIFwid2FyblwiIG9yIFwiZXJyb3JcIlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxQYXJhbXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcnJvcihtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5sb2dMZXZlbEFjdGl2ZShcImVycm9yXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdExvZ01lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobG9nTWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdExvZ01lc3NhZ2UobWVzc2FnZT86IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubG9nUHJlZml4fSR7bWVzc2FnZX1gO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9nTGV2ZWxBY3RpdmUobG9nTGV2ZWw6IExvZ2dpbmdMZXZlbCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcInRyYWNlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcImRlYnVnXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsICE9PSBcInRyYWNlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcImluZm9cIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9nTGV2ZWwgIT09IFwidHJhY2VcIiAmJiBsb2dMZXZlbCAhPT0gXCJkZWJ1Z1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5sb2dMZXZlbCA9PT0gXCJ3YXJuXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsICE9PSBcInRyYWNlXCIgJiYgbG9nTGV2ZWwgIT09IFwiZGVidWdcIiAmJiBsb2dMZXZlbCAhPT0gXCJpbmZvXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsICE9PSBcInRyYWNlXCIgJiYgbG9nTGV2ZWwgIT09IFwiZGVidWdcIiAmJiBsb2dMZXZlbCAhPT0gXCJpbmZvXCIgJiYgbG9nTGV2ZWwgIT09IFwid2FyblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTG9nZ2luZ0xldmVsID0gXCJub25lXCIgfCBcInRyYWNlXCIgfCBcImRlYnVnXCIgfCBcImluZm9cIiB8IFwid2FyblwiIHwgXCJlcnJvclwiOyIsICJpbXBvcnQgeyBQcmpTZXR0aW5ncyB9IGZyb20gJ3NyYy90eXBlcy9QcmpTZXR0aW5ncyc7XHJcbmltcG9ydCB7IEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgRmlsZUNhY2hlIGZyb20gXCIuLi9saWJzL0ZpbGVDYWNoZVwiO1xyXG5pbXBvcnQgTWV0YWRhdGFDYWNoZSBmcm9tIFwiLi4vbGlicy9NZXRhZGF0YUNhY2hlXCI7XHJcbmltcG9ydCBMb2dnaW5nLCB7IExvZ2dpbmdMZXZlbCB9IGZyb20gJy4vTG9nZ2luZyc7XHJcbmltcG9ydCBQcmogZnJvbSAnc3JjL21haW4nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xvYmFsIHtcclxuICAgIHN0YXRpYyBpbnN0YW5jZTogR2xvYmFsO1xyXG4gICAgcGx1Z2luOiBQcmo7XHJcbiAgICBhcHA6IEFwcDtcclxuICAgIGZpbGVDYWNoZTogRmlsZUNhY2hlO1xyXG4gICAgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZTtcclxuICAgIHNldHRpbmdzOiBQcmpTZXR0aW5ncztcclxuICAgIGxvZ2dlcjogTG9nZ2luZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcmo6IFByaiwgYXBwOiBBcHAsIHNldHRpbmdzOiBQcmpTZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChHbG9iYWwuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdsb2JhbC5pbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwcmo7XHJcblxyXG4gICAgICAgIC8vIE9ic2lkaWFuIEFwcFxyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG5cclxuICAgICAgICAvLyBTZXR0aW5nc1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuXHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2luZyh0aGlzLnNldHRpbmdzLmxvZ0xldmVsIGFzIExvZ2dpbmdMZXZlbCwgXCJQcmpcIik7XHJcblxyXG4gICAgICAgIC8vIFNpbmdsZXRvbjsgYmVmb3JlIGNyZWF0aW5nIHRoZSBjYWNoZSBpbnN0YW5jZXMsIGJlY2F1c2UgdGhleSBuZWVkIHRoZSBhcHAgaW5zdGFuY2VcclxuICAgICAgICBHbG9iYWwuaW5zdGFuY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyBGaWxlIGNhY2hlXHJcbiAgICAgICAgdGhpcy5maWxlQ2FjaGUgPSBGaWxlQ2FjaGUuZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgICAgICAgLy8gTWV0YWRhdGEgY2FjaGVcclxuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUgPSBNZXRhZGF0YUNhY2hlLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBhd2FpdENhY2hlSW5pdGlhbGl6YXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJXYWl0aW5nIGZvciBjYWNoZSBpbml0aWFsaXphdGlvblwiKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmZpbGVDYWNoZS53YWl0Rm9yQ2FjaGVSZWFkeSgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMubWV0YWRhdGFDYWNoZS53YWl0Rm9yQ2FjaGVSZWFkeSgpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiQ2FjaGUgaW5pdGlhbGl6ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIEZpbGVDYWNoZS5kZWNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgTWV0YWRhdGFDYWNoZS5kZWNvbnN0cnVjdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKHByajogUHJqIHwgbnVsbCA9IG51bGwsIGFwcDogQXBwIHwgbnVsbCA9IG51bGwsIHNldHRpbmdzOiBQcmpTZXR0aW5ncyB8IG51bGwgPSBudWxsKTogR2xvYmFsIHtcclxuICAgICAgICBpZiAoIUdsb2JhbC5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIXByaiB8fCAhYXBwIHx8ICFzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2xvYmFsIGluc3RhbmNlIG5vdCBpbml0aWFsaXplZCBhbmQgbm8gYXBwIHByb3ZpZGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEdsb2JhbC5pbnN0YW5jZSA9IG5ldyBHbG9iYWwocHJqLCBhcHAsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdsb2JhbC5pbnN0YW5jZTtcclxuICAgIH1cclxufSIsICIvLyBOb3RlOiBEb2N1bWVudE1vZGVsIGNsYXNzXHJcblxyXG5pbXBvcnQgeyBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBCYXNlTW9kZWwgfSBmcm9tIFwiLi9CYXNlTW9kZWxcIjtcclxuaW1wb3J0IElQcmpNb2RlbCBmcm9tIFwiLi4vaW50ZXJmYWNlcy9JUHJqTW9kZWxcIjtcclxuaW1wb3J0IERvY3VtZW50RGF0YSBmcm9tIFwiLi4vdHlwZXMvRG9jdW1lbnREYXRhXCI7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSBcIi4uL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCBIZWxwZXIgZnJvbSBcIi4uL2xpYnMvSGVscGVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRNb2RlbCBleHRlbmRzIEJhc2VNb2RlbDxEb2N1bWVudERhdGE+IGltcGxlbWVudHMgSVByak1vZGVsPERvY3VtZW50RGF0YT4ge1xyXG4gICAgcHJpdmF0ZSBmaWxlQ2FjaGUgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5maWxlQ2FjaGU7XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVsYXRlZEZpbGVzOiBEb2N1bWVudE1vZGVsW10gfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpbGU6IFRGaWxlKSB7XHJcbiAgICAgICAgc3VwZXIoZmlsZSwgRG9jdW1lbnREYXRhLCBEb2N1bWVudERhdGEueWFtbEtleU1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBkYXRhKCk6IFBhcnRpYWw8RG9jdW1lbnREYXRhPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IFBhcnRpYWw8RG9jdW1lbnREYXRhPikge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHJlbGF0ZWRGaWxlcygpOiBEb2N1bWVudE1vZGVsW10gfCBudWxsIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVsYXRlZEZpbGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVsYXRlZEZpbGVzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRGaWxlcyA9IHRoaXMuZGF0YS5yZWxhdGVkRmlsZXM7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGVkRmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJlbGF0ZWRGaWxlcy5tYXAoKHJlbGF0ZWRGaWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lraWxpbmtEYXRhID0gSGVscGVyLmV4dHJhY3REYXRhRnJvbVdpa2lsaW5rKHJlbGF0ZWRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZEZpbGVuYW1lID0gd2lraWxpbmtEYXRhLmJhc2VuYW1lID8gYCR7d2lraWxpbmtEYXRhLmJhc2VuYW1lfS5tZGAgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmZpbGVDYWNoZS5maW5kRmlsZUJ5TmFtZShtZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUucGF0aCAhPT0gdGhpcy5maWxlLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZEZpbGVzPy5wdXNoKG5ldyBEb2N1bWVudE1vZGVsKGZpbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgdGhpcy5fcmVsYXRlZEZpbGVzID0gbnVsbDsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRlZEZpbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBhbGxUZXh0ID0gdGhpcy5kYXRhLnRpdGxlID8/IFwiXCI7XHJcbiAgICAgICAgYWxsVGV4dCArPSB0aGlzLmRhdGEuZGVzY3JpcHRpb24gPz8gXCJcIjtcclxuICAgICAgICBhbGxUZXh0ICs9IHRoaXMuZGF0YS5kYXRlID8/IFwiXCI7XHJcbiAgICAgICAgYWxsVGV4dCArPSB0aGlzLmRhdGEuZGF0ZU9mRGVsaXZlcnkgPz8gXCJcIjtcclxuICAgICAgICBhbGxUZXh0ICs9IHRoaXMuZGF0YS5maWxlID8/IFwiXCI7XHJcbiAgICAgICAgYWxsVGV4dCArPSB0aGlzLmRhdGEudGFncyA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLnNlbmRlciA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLnJlY2lwaWVudCA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLnJlbGF0ZWRGaWxlcyA/PyBcIlwiO1xyXG4gICAgICAgIHJldHVybiBhbGxUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRXaWtpbGluayh0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgW1ske3RoaXMuZmlsZS5uYW1lfXwke3RleHR9XV1gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgW1ske3RoaXMuZmlsZS5uYW1lfV1dYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudFxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGUgY29udGVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEZpbGVDb250ZW50cygpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcC52YXVsdC5yZWFkKHRoaXMuZmlsZSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDb3Jvc3BvbmRpbmdTeW1ib2woKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLnR5cGUgPT09IFwiTWV0YWRhdGFcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLnN1YlR5cGUgPT09IFwiQ2x1c3RlclwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWwuc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5jbHVzdGVyU3ltYm9sO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWwuc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5oaWRlU3ltYm9sO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3Muc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIngtY2lyY2xlXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZG9jdW1lbnRcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyBjb250YWluaW5nIHRoZSBkZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmRlc2NyaXB0aW9uID8/IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGBJbnB1dGAgaWYgdGhlIGRvY3VtZW50IGlzIGFkZHJlc3NlZCB0byB0aGUgdXNlciBvciBgT3V0cHV0YCBpZiBpdCBjb21lcyBmcm9tIHRoZSB1c2VyLiBPdGhlcndpc2UgYG51bGxgLlxyXG4gICAgICogQHJldHVybnMgU3RhdGUgb2YgdGhlIGRvY3VtZW50LlxyXG4gICAgICogRS5nLiBgSW5wdXRgIGlmIHRoZSBkb2N1bWVudCBpcyBhZGRyZXNzZWQgdG8gdGhlIHVzZXIgb3IgYE91dHB1dGAgaWYgaXQgY29tZXMgZnJvbSB0aGUgdXNlci4gT3RoZXJ3aXNlIGBudWxsYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldElucHV0T3V0cHV0U3RhdGUoKTogbnVsbCB8IFwiSW5wdXRcIiB8IFwiT3V0cHV0XCIge1xyXG4gICAgICAgIGNvbnN0IHVzZXJuYW1lID0gdGhpcy5nbG9iYWwuc2V0dGluZ3MudXNlci5uYW1lO1xyXG4gICAgICAgIGNvbnN0IHNob3J0VXNlcm5hbWUgPSB0aGlzLmdsb2JhbC5zZXR0aW5ncy51c2VyLnNob3J0TmFtZTtcclxuICAgICAgICBpZiAodGhpcy5kYXRhICYmICh0aGlzLmRhdGEuc2VuZGVyIHx8IHRoaXMuZGF0YS5yZWNpcGllbnQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuc2VuZGVyID09PSB1c2VybmFtZSB8fCB0aGlzLmRhdGEuc2VuZGVyID09PSBzaG9ydFVzZXJuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJPdXRwdXRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEucmVjaXBpZW50ID09PSB1c2VybmFtZSB8fCB0aGlzLmRhdGEucmVjaXBpZW50ID09PSBzaG9ydFVzZXJuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnB1dFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5rZWQgZmlsZSBvZiB0aGUgZG9jdW1lbnRcclxuICAgICAqIEByZXR1cm5zIFRGaWxlIG9mIHRoZSBsaW5rZWQgZmlsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RmlsZSgpOiBURmlsZSB7XHJcbiAgICAgICAgY29uc3QgZmlsZUxpbmtEYXRhID0gSGVscGVyLmV4dHJhY3REYXRhRnJvbVdpa2lsaW5rKHRoaXMuZGF0YS5maWxlKTtcclxuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5maWxlQ2FjaGUuZmluZEZpbGVCeU5hbWUoZmlsZUxpbmtEYXRhLmZpbGVuYW1lID8/IFwiXCIpO1xyXG4gICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYE11bHRpcGxlIGZpbGVzIGZvdW5kIGZvciAke2ZpbGVMaW5rRGF0YS5maWxlbmFtZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbGUuZmlyc3QoKSA/PyB0aGlzLmZpbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYE5vIGZpbGVzIGZvdW5kIGZvciAke2ZpbGVMaW5rRGF0YS5maWxlbmFtZX1gKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGFncyBvZiB0aGUgZG9jdW1lbnQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgICogQHJldHVybnMgQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSB0YWdzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUYWdzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5kYXRhLnRhZ3M7XHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZFRhZ3M6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgIGlmICh0YWdzICYmIHR5cGVvZiB0YWdzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3JtYXR0ZWRUYWdzID0gW3RhZ3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhZ3MpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlZFRhZ3MgPSBbLi4udGFnc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVGFncztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnRzIHRoZSBkb2N1bWVudHMgYnkgZGF0ZSBkZXNjZW5kaW5nXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIEFycmF5IG9mIERvY3VtZW50TW9kZWxzIHRvIHNvcnRcclxuICAgICAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gc29ydHMgdGhlIGFycmF5IGluIHBsYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc29ydERvY3VtZW50c0J5RGF0ZURlc2MoZG9jdW1lbnRzOiBEb2N1bWVudE1vZGVsW10pOiB2b2lkIHtcclxuICAgICAgICBkb2N1bWVudHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYS5kYXRhLmRhdGUgJiYgYi5kYXRhLmRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVBID0gbmV3IERhdGUoYS5kYXRhLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZUIgPSBuZXcgRGF0ZShiLmRhdGEuZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUIuZ2V0VGltZSgpIC0gZGF0ZUEuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEuZGF0YS5kYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5kYXRhLmRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnRzIHRoZSBkb2N1bWVudHMgYnkgZGF0ZSBhc2NlbmRpbmdcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgQXJyYXkgb2YgRG9jdW1lbnRNb2RlbHMgdG8gc29ydFxyXG4gICAgICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiBzb3J0cyB0aGUgYXJyYXkgaW4gcGxhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzb3J0RG9jdW1lbnRzQnlEYXRlQXNjKGRvY3VtZW50czogRG9jdW1lbnRNb2RlbFtdKTogdm9pZCB7XHJcbiAgICAgICAgZG9jdW1lbnRzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGEuZGF0YS5kYXRlICYmIGIuZGF0YS5kYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlQSA9IG5ldyBEYXRlKGEuZGF0YS5kYXRlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVCID0gbmV3IERhdGUoYi5kYXRhLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVBLmdldFRpbWUoKSAtIGRhdGVCLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhLmRhdGEuZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5kYXRhLmRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsICIvLyBOb3RlOiBUcmFuc2FjdGlvbk1vZGVsIGNsYXNzXHJcblxyXG5pbXBvcnQgR2xvYmFsIGZyb20gXCJzcmMvY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IExvZ2dpbmcgZnJvbSBcInNyYy9jbGFzc2VzL0xvZ2dpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaGFuZGxlcyB0cmFuc2FjdGlvbnMuXHJcbiAqIEByZW1hcmtzIC0gQSB0cmFuc2FjdGlvbiBpcyBhIHNldCBvZiBjaGFuZ2VzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIG1vZGVsIGF0IG9uY2UuXHJcbiAqIC0gVGhpcyBpcyB1c2VmdWwgd2hlbiBtdWx0aXBsZSBjaGFuZ2VzIG5lZWQgdG8gYmUgYXBwbGllZCB0byB0aGUgbW9kZWwsIGJ1dCB0aGUgY2hhbmdlcyBzaG91bGQgb25seSBiZSB3cml0dGVuIHRvIHRoZSBmaWxlIG9uY2UgYWxsIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXHJcbiAqIC0gVGhpcyBpcyBhbHNvIHVzZWZ1bCB3aGVuIHRoZSBjaGFuZ2VzIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBtb2RlbCwgYnV0IG5vdCB3cml0dGVuIHRvIHRoZSBmaWxlIHlldC5cclxuICogQHR1dG9yaWFsIC0gVG8gc3RhcnQgYSB0cmFuc2FjdGlvbiwgY2FsbCB0aGUgYHN0YXJ0VHJhbnNhY3Rpb25gIG1ldGhvZC5cclxuICogLSBUbyBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgbW9kZWwsIGNhbGwgdGhlIGBmaW5pc2hUcmFuc2FjdGlvbmAgbWV0aG9kLlxyXG4gKiAtIFRvIGRpc2NhcmQgdGhlIGNoYW5nZXMsIGNhbGwgdGhlIGBhYm9ydFRyYW5zYWN0aW9uYCBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25Nb2RlbDxUPiB7XHJcbiAgICBwcm90ZWN0ZWQgbG9nZ2VyOiBMb2dnaW5nID0gR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyO1xyXG4gICAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uQWN0aXZlID0gZmFsc2U7XHJcbiAgICBwcm90ZWN0ZWQgY2hhbmdlczogUGFydGlhbDxUPiA9IHt9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd3JpdGVzIHRoZSBjaGFuZ2VzIHRvIHRoZSBmaWxlLlxyXG4gICAgICogQHJlbWFya3MgLSBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBmaW5pc2hlZCBvciB3aXRob3V0IGEgYWN0aXZlIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5LlxyXG4gICAgICogQHBhcmFtIHVwZGF0ZSBUaGUgY2hhbmdlcyB0byB3cml0ZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHdyaXRlQ2hhbmdlczogKHVwZGF0ZTogVCkgPT4gdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFRyYW5zYWN0aW9uTW9kZWwgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0gd3JpdGVDaGFuZ2VzIEEgZnVuY3Rpb24gdGhhdCB3cml0ZXMgdGhlIGNoYW5nZXMgdG8gdGhlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdyaXRlQ2hhbmdlczogKHVwZGF0ZTogVCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25BY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLndyaXRlQ2hhbmdlcyA9IHdyaXRlQ2hhbmdlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIHRyYW5zYWN0aW9uXHJcbiAgICAgKiBAcmVtYXJrcyAtIElmIGEgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBhY3RpdmUsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBhbmQgbG9ncyBhIHdhcm5pbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGFydFRyYW5zYWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVHJhbnNhY3Rpb25BY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignVHJhbnNhY3Rpb24gYWxyZWFkeSBhY3RpdmUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uQWN0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaGVzIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIEByZW1hcmtzIC0gSWYgbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgYW5kIGxvZ3MgYSB3YXJuaW5nLlxyXG4gICAgICogLSBUaGlzIG1ldGhvZCB3cml0ZXMgdGhlIGNoYW5nZXMgdG8gdGhlIGZpbGUuXHJcbiAgICAgKiBAcmVtYXJrcyAtIElmIHRoZSBgd3JpdGVDaGFuZ2VzYCBtZXRob2QgdGhyb3dzIGFuIGVycm9yLCB0aGUgZXJyb3IgaXMgbG9nZ2VkIGFuZCB0aGUgdHJhbnNhY3Rpb24gaXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbmlzaFRyYW5zYWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1RyYW5zYWN0aW9uQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIHRyYW5zYWN0aW9uIGFjdGl2ZScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVDaGFuZ2VzKHRoaXMuY2hhbmdlcyBhcyBUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiYHdyaXRlQ2hhbmdlc2AgZmFpbGVkIHdpdGggZXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJvcnRzIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIEByZW1hcmtzIC0gSWYgbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgYW5kIGxvZ3MgYSB3YXJuaW5nLlxyXG4gICAgICogLSBUaGlzIG1ldGhvZCBkaXNjYXJkcyBhbGwgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFib3J0VHJhbnNhY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNhY3Rpb25BY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignTm8gdHJhbnNhY3Rpb24gYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0ge307XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbkFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGtleS5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB1cGRhdGUgYXMgcGF0aC4gRXhhbXBsZTogYGRhdGEudGl0bGVgXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZUtleVZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY2hhbmdlcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHJcbiAgICAgICAga2V5cy5mb3JFYWNoKChrLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGtleXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFtrXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFtrXSA9IGN1cnJlbnRba10gfHwge307XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtrXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNUcmFuc2FjdGlvbkFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlQ2hhbmdlcyh0aGlzLmNoYW5nZXMgYXMgVCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZS5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0IGlzVHJhbnNhY3Rpb25BY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25BY3RpdmU7XHJcbiAgICB9XHJcbn0iLCAiaW1wb3J0IHsgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwiLi4vY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25Nb2RlbCB9IGZyb20gXCIuL1RyYW5zYWN0aW9uTW9kZWxcIjtcclxuaW1wb3J0IHsgWWFtbEtleU1hcCB9IGZyb20gXCIuLi90eXBlcy9ZYW1sS2V5TWFwXCI7XHJcbmltcG9ydCBMb2dnaW5nIGZyb20gXCJzcmMvY2xhc3Nlcy9Mb2dnaW5nXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQmFzZU1vZGVsPFQgZXh0ZW5kcyBvYmplY3Q+IGV4dGVuZHMgVHJhbnNhY3Rpb25Nb2RlbDxUPiB7XHJcbiAgICBwcm90ZWN0ZWQgZ2xvYmFsID0gR2xvYmFsLmdldEluc3RhbmNlKCk7XHJcbiAgICBwcm90ZWN0ZWQgYXBwID0gR2xvYmFsLmdldEluc3RhbmNlKCkuYXBwO1xyXG4gICAgcHJvdGVjdGVkIGxvZ2dlcjogTG9nZ2luZyA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlcjtcclxuICAgIHByaXZhdGUgX2ZpbGU6IFRGaWxlO1xyXG4gICAgcHVibGljIGdldCBmaWxlKCk6IFRGaWxlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgY3RvcjogbmV3IChkYXRhPzogUGFydGlhbDxUPikgPT4gVDtcclxuICAgIHByaXZhdGUgZGF0YVByb3h5OiBUO1xyXG4gICAgcHJpdmF0ZSB5YW1sS2V5TWFwOiBZYW1sS2V5TWFwIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBCYXNlTW9kZWwgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byBjcmVhdGUgdGhlIG1vZGVsIGZvci5cclxuICAgICAqIEBwYXJhbSBjdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0geWFtbEtleU1hcCBUaGUgeWFtbCBrZXkgbWFwIHRvIHVzZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlsZTogVEZpbGUsIGN0b3I6IG5ldyAoZGF0YT86IFBhcnRpYWw8VD4pID0+IFQsIHlhbWxLZXlNYXA6IFlhbWxLZXlNYXAgfCB1bmRlZmluZWQpIHtcclxuICAgICAgICBzdXBlcigodXBkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbnRtYXR0ZXIgPSB1cGRhdGUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZmlsZSA9IGZpbGU7XHJcbiAgICAgICAgdGhpcy5jdG9yID0gY3RvcjtcclxuICAgICAgICB0aGlzLmluaXRZYW1sS2V5TWFwKHlhbWxLZXlNYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBvYmplY3QgYXMgYSBwcm94eS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIG9iamVjdCBhcyBhIHByb3h5LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0IF9kYXRhKCk6IFBhcnRpYWw8VD4ge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm94eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJveHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gdGhpcy5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICAgIGlmICghZnJvbnRtYXR0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Zyb250bWF0dGVyIG5vdCBmb3VuZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBlbXB0eU9iamVjdCA9IG5ldyB0aGlzLmN0b3IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMueWFtbEtleU1hcCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnlhbWxLZXlNYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9udG1hdHRlclt0aGlzLnlhbWxLZXlNYXBba2V5XV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltrZXldID0gZnJvbnRtYXR0ZXJbdGhpcy55YW1sS2V5TWFwW2tleV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcm9udG1hdHRlclt0aGlzLnlhbWxLZXlNYXBba2V5XV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGFPYmplY3Q6IFQgPSBuZXcgdGhpcy5jdG9yKGZyb250bWF0dGVyIGFzIFBhcnRpYWw8VD4pO1xyXG4gICAgICAgIHRoaXMuZGF0YVByb3h5ID0gdGhpcy5jcmVhdGVQcm94eShkYXRhT2JqZWN0KSBhcyBUO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJveHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHNldCBfZGF0YSh2YWx1ZXM6IFBhcnRpYWw8VD4pIHtcclxuICAgICAgICBjb25zdCBkYXRhT2JqZWN0OiBUID0gbmV3IHRoaXMuY3Rvcih2YWx1ZXMpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGFPYmplY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVtrZXldID0gdmFsdWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZnJvbnRtYXR0ZXIoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKCkgPz8ge307XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBmcm9udG1hdHRlcih2YWx1ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcclxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKHRoaXMuX2ZpbGUsIChmcm9udG1hdHRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmVzdGVkRnJvbnRtYXR0ZXJPYmplY3RzKGZyb250bWF0dGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb250bWF0dGVyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRnJvbnRtYXR0ZXIgZm9yIGZpbGUgJHt0aGlzLl9maWxlLnBhdGh9IHN1Y2Nlc3NmdWxseSB1cGRhdGVkLmApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHRoZSBmcm9udG1hdHRlciBmb3IgZmlsZSAke3RoaXMuX2ZpbGUucGF0aH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwcm94eSBmb3IgdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjcmVhdGUgYSBwcm94eSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgb2JqZWN0LiBlLmcuIGBkYXRhLnRpdGxlYFxyXG4gICAgICogQHJldHVybnMgVGhlIHByb3h5IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVQcm94eShvYmo6IFBhcnRpYWw8VD4sIHBhdGggPSBcIlwiKTogdW5rbm93biB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShvYmosIHtcclxuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5S2V5ID0gdGhpcy5nZXRQcm9wZXJ0eUtleShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoID8gYCR7cGF0aH0uJHtwcm9wZXJ0eUtleX1gIDogYCR7cHJvcGVydHlLZXl9YDtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJveHkodmFsdWUsIG5ld1BhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5S2V5ID0gdGhpcy5nZXRQcm9wZXJ0eUtleShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7cHJvcGVydHlLZXl9YCA6IGAke3Byb3BlcnR5S2V5fWA7XHJcbiAgICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXlWYWx1ZShuZXdQYXRoLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGB5YW1sS2V5TWFwYCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB5YW1sS2V5TWFwIFRoZSBuZXcgYHlhbWxLZXlNYXBgIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0WWFtbEtleU1hcCh5YW1sS2V5TWFwOiBZYW1sS2V5TWFwIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHlhbWxLZXlNYXApIHtcclxuICAgICAgICAgICAgdGhpcy55YW1sS2V5TWFwID0geWFtbEtleU1hcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRQcm9wZXJ0eUtleShwcm9wZXJ0eTogc3RyaW5nIHwgc3ltYm9sKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHByb3BlcnR5ID09PSAnc3ltYm9sJyA/IHByb3BlcnR5LnRvU3RyaW5nKCkgOiBwcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldE1ldGFkYXRhKCk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkTWV0YWRhdGEgPSB0aGlzLmFwcD8ubWV0YWRhdGFDYWNoZT8uZ2V0Q2FjaGUodGhpcy5fZmlsZS5wYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKGNhY2hlZE1ldGFkYXRhICYmIGNhY2hlZE1ldGFkYXRhLmZyb250bWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRNZXRhZGF0YS5mcm9udG1hdHRlciBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBObyBNZXRhZGF0YSBmb3VuZCBmb3IgJHt0aGlzLl9maWxlLnBhdGh9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZU5lc3RlZEZyb250bWF0dGVyT2JqZWN0cyhmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHVwZGF0ZXM6IG9iamVjdCkge1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy55YW1sS2V5TWFwICYmIHRoaXMueWFtbEtleU1hcFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnlhbWxLZXlNYXBba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIGZyb250bWF0dGVyW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmVzdGVkRnJvbnRtYXR0ZXJPYmplY3RzKGZyb250bWF0dGVyW2tleV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsICJpbXBvcnQgSVByakRhdGEgZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByakRhdGFcIjtcclxuaW1wb3J0IElQcmpEb2N1bWVudCBmcm9tIFwiLi4vaW50ZXJmYWNlcy9JUHJqRG9jdW1lbnRcIjtcclxuaW1wb3J0IHsgWWFtbEtleU1hcCB9IGZyb20gXCIuL1lhbWxLZXlNYXBcIjtcclxuaW1wb3J0IHsgRmlsZVR5cGUsIEZpbGVTdWJUeXBlIH0gZnJvbSBcIi4vUHJqVHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50RGF0YSBpbXBsZW1lbnRzIElQcmpEYXRhLCBJUHJqRG9jdW1lbnQge1xyXG4gICAgdHlwZTogRmlsZVR5cGUgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgc3ViVHlwZTogRmlsZVN1YlR5cGUgfCB1bmRlZmluZWQ7XHJcbiAgICB0aXRsZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGRhdGU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHNlbmRlcjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHJlY2lwaWVudDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGRhdGVPZkRlbGl2ZXJ5OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgaGlkZTogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBmaWxlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgcmVsYXRlZEZpbGVzOiBzdHJpbmdbXSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBjaXRhdGlvblRpdGxlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgdGFnczogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgYW5ub3RhdGlvblRhcmdldDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHN0YXRpYyB5YW1sS2V5TWFwOiBZYW1sS2V5TWFwID0ge1xyXG4gICAgICAgIFwiYW5ub3RhdGlvblRhcmdldFwiOiBcImFubm90YXRpb24tdGFyZ2V0XCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGF0YTogUGFydGlhbDxEb2N1bWVudERhdGE+KSB7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IGRhdGEudGl0bGUgIT09IHVuZGVmaW5lZCA/IGRhdGEudGl0bGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0YS5kYXRlICE9PSB1bmRlZmluZWQgPyBkYXRhLmRhdGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCA/IGRhdGEuZGVzY3JpcHRpb24gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zZW5kZXIgPSBkYXRhLnNlbmRlciAhPT0gdW5kZWZpbmVkID8gZGF0YS5zZW5kZXIgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yZWNpcGllbnQgPSBkYXRhLnJlY2lwaWVudCAhPT0gdW5kZWZpbmVkID8gZGF0YS5yZWNpcGllbnQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRlT2ZEZWxpdmVyeSA9IGRhdGEuZGF0ZU9mRGVsaXZlcnkgIT09IHVuZGVmaW5lZCA/IGRhdGEuZGF0ZU9mRGVsaXZlcnkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5oaWRlID0gZGF0YS5oaWRlICE9PSB1bmRlZmluZWQgPyBkYXRhLmhpZGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5maWxlID0gZGF0YS5maWxlICE9PSB1bmRlZmluZWQgPyBkYXRhLmZpbGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yZWxhdGVkRmlsZXMgPSBkYXRhLnJlbGF0ZWRGaWxlcyAhPT0gdW5kZWZpbmVkID8gZGF0YS5yZWxhdGVkRmlsZXMgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jaXRhdGlvblRpdGxlID0gZGF0YS5jaXRhdGlvblRpdGxlICE9PSB1bmRlZmluZWQgPyBkYXRhLmNpdGF0aW9uVGl0bGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50YWdzID0gZGF0YS50YWdzICE9PSB1bmRlZmluZWQgPyBkYXRhLnRhZ3MgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlICE9PSB1bmRlZmluZWQgPyBkYXRhLnR5cGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdWJUeXBlID0gZGF0YS5zdWJUeXBlICE9PSB1bmRlZmluZWQgPyBkYXRhLnN1YlR5cGUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uVGFyZ2V0ID0gZGF0YS5hbm5vdGF0aW9uVGFyZ2V0ICE9PSB1bmRlZmluZWQgPyBkYXRhLmFubm90YXRpb25UYXJnZXQgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IG1vbWVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG1kNSA9IHJlcXVpcmUoJ2NyeXB0by1qcy9tZDUnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSBkYXRlLCBmaWxlbmFtZSwgZmlsZSBleHRlbnNpb24gYW5kIGRpc3BsYXkgdGV4dCBmcm9tIGEgd2lraWxpbmtcclxuICAgICAqIEBwYXJhbSB3aWtpbGluayBXaWtpbGluayB0byBleHRyYWN0IHRoZSBkYXRhIGZyb20sIGVnLiBbWzIwMjEuMDEuMDEgLSBmaWxlLnR4dHxEaXNwbGF5IHRleHRdXVxyXG4gICAgICogQHJldHVybnMge1dpa2lsaW5rRGF0YX0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGUsIGZpbGVuYW1lLCBmaWxlIGV4dGVuc2lvbiBhbmQgZGlzcGxheSB0ZXh0XHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGV4dHJhY3REYXRhRnJvbVdpa2lsaW5rKHdpa2lsaW5rOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogV2lraWxpbmtEYXRhIHtcclxuICAgICAgICBpZiAod2lraWxpbmsgJiYgdHlwZW9mIHdpa2lsaW5rID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNtYW50bGVkTGlua01hdGNoID0gd2lraWxpbmsubWF0Y2goL1xcW1xcWyguKz8pKD86XFwuKFxcdyspKT8oPzpcXHwoLiopKT9cXF1cXF0vKTtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWRpc21hbnRsZWRMaW5rTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VuYW1lOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0ZWQgZGF0ZSBmb3JtYXQgaXMgWVlZWS5NTS5ERFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZU1hdGNoID0gZGlzbWFudGxlZExpbmtNYXRjaFsxXS5tYXRjaCgvKFxcZHs0fSlcXC4oXFxkezJ9KVxcLihcXGR7Mn0pLyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGAke2RhdGVNYXRjaFsxXX0tJHtkYXRlTWF0Y2hbMl19LSR7ZGF0ZU1hdGNoWzNdfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VuYW1lOiBkaXNtYW50bGVkTGlua01hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogZGlzbWFudGxlZExpbmtNYXRjaFsyXSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogYCR7ZGlzbWFudGxlZExpbmtNYXRjaFsxXX0uJHtkaXNtYW50bGVkTGlua01hdGNoWzJdfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQ6IGRpc21hbnRsZWRMaW5rTWF0Y2hbM11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYmFzZW5hbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBVSUQgZnJvbSB0aGUgZ2l2ZW4gaW5wdXRcclxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gZ2VuZXJhdGUgdGhlIFVJRCBmcm9tXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIFVJRFxyXG4gICAgICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBVSUQgd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoaXMgbWV0aG9kIHVzZXMgdGhlIE1ENSBoYXNoIGFsZ29yaXRobSB0byBnZW5lcmF0ZSB0aGUgVUlEXHJcbiAgICAgKiAtIFRoZSBVSUQgaXMgcHJlZml4ZWQgd2l0aCBhIFwiVVwiIHRvIHByZXZlbnQgdGhlIFVJRCBmcm9tIHN0YXJ0aW5nIHdpdGggYSBudW1iZXIuIFRoZSBcIlVcIiBjb3VudHMgdG8gdGhlIGxlbmd0aCBvZiB0aGUgVUlEXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZVVJRChpbnB1dDogc3RyaW5nLCBsZW5ndGggPSA4KTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gJ1UnICsgdGhpcy5tZDUoaW5wdXQpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIGhhc2guc3Vic3RyaW5nKDAsIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZvcm1hdERhdGUoZGF0ZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcmVnZXhEYXRlID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvO1xyXG4gICAgICAgIGlmICghcmVnZXhEYXRlLnRlc3QoZGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvcm1hdGVkRGF0ZSA9IG1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICBpZiAoZm9ybWF0ZWREYXRlID09PSAnSW52YWxpZCBkYXRlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdGVkRGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNsZWVwcyBmb3IgdGhlIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBtcyBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBzbGVlcFxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIHNsZWVwKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRleHQgaXMgcG9zc2libHkgbWFya2Rvd25cclxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0ZXh0IGlzIHBvc3NpYmx5IG1hcmtkb3duICh0cnVlIG9yIGZhbHNlKVxyXG4gICAgICogQHJlbWFya3MgLSBUaGlzIG1ldGhvZCBjaGVja3MgaWYgdGhlIHRleHQgY29udGFpbnMgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3ltYm9sczpcclxuICAgICAqIC0gYCpgLCBgX2AsIGBbYCwgYF1gLCBgPWAgYW5kIGAtYCBpZiB0aGVyZSBpcyBhIGxpbmUgYnJlYWtcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzUG9zc2libHlNYXJrZG93bih0ZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgcmVnZXhNYXJrZG93blN5bWJvbHM7XHJcbiAgICAgICAgY29uc3QgcmVnZXhMaW5lQnJlYWsgPSAvXFxyP1xcbi87XHJcbiAgICAgICAgY29uc3QgbGluZUJyZWFrID0gcmVnZXhMaW5lQnJlYWsudGVzdCh0ZXh0KTtcclxuICAgICAgICBpZiAobGluZUJyZWFrKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbGluZSBicmVhaywgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhlIGxpc3Qgc3ltYm9sXHJcbiAgICAgICAgICAgIHJlZ2V4TWFya2Rvd25TeW1ib2xzID0gL1sqX1xcLVtcXF09XS87XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbGluZSBicmVhaywgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgZm9yIHRoZSBsaXN0IHN5bWJvbFxyXG4gICAgICAgICAgICByZWdleE1hcmtkb3duU3ltYm9scyA9IC9bKl9bXFxdPV0vO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4TWFya2Rvd25TeW1ib2xzLnRlc3QodGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYW55IG9mIHRoZSB0YWdzIGluIGB0YWdzVG9DaGVja2AgaXMgYSBzdWJzdHJpbmcgb2YgYW55IHRhZyBpbiBgdGFnc1RvQmVDaGVja2VkYFxyXG4gICAgICogQHBhcmFtIHRhZ3NUb0NoZWNrIFRoZSB0YWdzIHRvIGNoZWNrIGFzIHN1YnN0cmluZ3NcclxuICAgICAqIEBwYXJhbSB0YWdzVG9CZUNoZWNrZWQgVGhlIHRhZ3MgdG8gYmUgY2hlY2tlZCBhZ2FpbnN0XHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIGFueSB0YWcgZnJvbSBgdGFnc1RvQ2hlY2tgIGlzIGEgc3Vic3RyaW5nIG9mIGFueSB0YWcgaW4gYHRhZ3NUb0JlQ2hlY2tlZGBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVGFnSW5jbHVkZWQodGFnc1RvQ2hlY2s6IHN0cmluZyB8IHN0cmluZ1tdLCB0YWdzVG9CZUNoZWNrZWQ6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgX3RhZ3NUb0NoZWNrOiBzdHJpbmdbXSA9IEFycmF5LmlzQXJyYXkodGFnc1RvQ2hlY2spID9cclxuICAgICAgICAgICAgdGFnc1RvQ2hlY2sgOiAodGFnc1RvQ2hlY2sgPyBbdGFnc1RvQ2hlY2tdIDogW10pO1xyXG4gICAgICAgIGNvbnN0IF90YWdzVG9CZUNoZWNrZWQ6IHN0cmluZ1tdID0gQXJyYXkuaXNBcnJheSh0YWdzVG9CZUNoZWNrZWQpID9cclxuICAgICAgICAgICAgdGFnc1RvQmVDaGVja2VkIDogKHRhZ3NUb0JlQ2hlY2tlZCA/IFt0YWdzVG9CZUNoZWNrZWRdIDogW10pO1xyXG5cclxuICAgICAgICByZXR1cm4gX3RhZ3NUb0NoZWNrLnNvbWUodGFnVG9DaGVjayA9PlxyXG4gICAgICAgICAgICBfdGFnc1RvQmVDaGVja2VkLnNvbWUodGFnVG9CZUNoZWNrZWQgPT5cclxuICAgICAgICAgICAgICAgIHRhZ1RvQmVDaGVja2VkPy5pbmNsdWRlcyh0YWdUb0NoZWNrKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBXaWtpbGlua0RhdGEgPSB7XHJcbiAgICBkYXRlOiBEYXRlIHwgdW5kZWZpbmVkO1xyXG4gICAgYmFzZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIGV4dGVuc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgZmlsZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIGRpc3BsYXlUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4iLCAiaW1wb3J0IEdsb2JhbCBmcm9tIFwic3JjL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCB7IElQcm9jZXNzb3JTZXR0aW5ncyB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL0lQcm9jZXNzb3JTZXR0aW5nc1wiO1xyXG5pbXBvcnQgeyBNYXJrZG93blJlbmRlckNoaWxkLCBzZXRJY29uIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBUYWJsZSwgeyBUYWJsZUhlYWRlciB9IGZyb20gXCIuLi9UYWJsZVwiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCIuLi9IZWxwZXJcIjtcclxuaW1wb3J0IFJlZHJhd2FibGVCbG9ja1JlbmRlckNvbXBvbmVudCBmcm9tIFwiLi9SZWRyYXdhYmxlQmxvY2tSZW5kZXJDb21wb25lbnRcIjtcclxuaW1wb3J0IElQcmpNb2RlbCBmcm9tIFwic3JjL2ludGVyZmFjZXMvSVByak1vZGVsXCI7XHJcbmltcG9ydCBMbmcgZnJvbSBcInNyYy9jbGFzc2VzL0xuZ1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgVGFibGVCbG9ja1JlbmRlckNvbXBvbmVudDxUIGV4dGVuZHMgSVByak1vZGVsPHVua25vd24+PiBpbXBsZW1lbnRzIFJlZHJhd2FibGVCbG9ja1JlbmRlckNvbXBvbmVudCB7XHJcbiAgICAvLyNyZWdpb24gR2VuZXJhbCBwcm9wZXJ0aWVzXHJcbiAgICBwcm90ZWN0ZWQgZ2xvYmFsID0gR2xvYmFsLmdldEluc3RhbmNlKCk7XHJcbiAgICBwcm90ZWN0ZWQgbG9nZ2VyID0gdGhpcy5nbG9iYWwubG9nZ2VyO1xyXG4gICAgcHJvdGVjdGVkIG1ldGFkYXRhQ2FjaGUgPSB0aGlzLmdsb2JhbC5tZXRhZGF0YUNhY2hlLkNhY2hlO1xyXG4gICAgcHJvdGVjdGVkIGZpbGVDYWNoZSA9IHRoaXMuZ2xvYmFsLmZpbGVDYWNoZTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIENvbXBvbmVudCBwcm9wZXJ0aWVzXHJcbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc29yU2V0dGluZ3M6IElQcm9jZXNzb3JTZXR0aW5ncztcclxuICAgIHByb3RlY3RlZCBjb21wb25lbnQ6IE1hcmtkb3duUmVuZGVyQ2hpbGQ7XHJcbiAgICBwcm90ZWN0ZWQgc2V0dGluZ3M6IHVua25vd247XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIC8vI3JlZ2lvbiBNb2RlbHNcclxuICAgIHByb3RlY3RlZCBtb2RlbHM6IFRbXTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIEhUTUwgcHJvcGVydGllc1xyXG4gICAgcHJvdGVjdGVkIHRhYmxlOiBUYWJsZTtcclxuICAgIHByb3RlY3RlZCB0YWJsZUhlYWRlcnM6IFRhYmxlSGVhZGVyW11cclxuICAgIHByb3RlY3RlZCBoZWFkZXJDb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJvdGVjdGVkIHRhYmxlQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJUHJvY2Vzc29yU2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NvclNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXcgTWFya2Rvd25SZW5kZXJDaGlsZCh0aGlzLnByb2Nlc3NvclNldHRpbmdzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgLy90aGlzLnBhcnNlU2V0dGluZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgY29tcG9uZW50IGZpcnN0IHRpbWUuXHJcbiAgICAgKiBAcmVtYXJrcyBDYWxscyB0aGUgYGRyYXdgIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGJ1aWxkKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgYHRhYmxlQ29udGFpbmVyYCBhbmQgYGhlYWRlckNvbnRhaW5lcmAgZWxlbWVudHMuXHJcbiAgICAgKiBAcmVtYXJrcyAtIENhbGwgdGhpcyBtZXRob2QgdG8gYnVpbGQgdGhlIGJhc2Ugc3RydWN0dXJlIGZpcnN0LlxyXG4gICAgICogLSBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBidWlsZCB0aGUgb3RoZXIgZWxlbWVudHMuXHJcbiAgICAgKiBAcmVtYXJrcyAtIEJ1aWxkIHRoZSBgdGFibGVDb250YWluZXJgIGFuZCBgaGVhZGVyQ29udGFpbmVyYCBlbGVtZW50cy5cclxuICAgICAqIC0gQnVpbGQgdGhlIGBjb250cm9sZSBibG9ja2AgPT4gYWRkIGEgcmVmcmVzaCBidXR0b24gd2hpY2ggY2FsbHMgdGhlIGByZWRyYXdgIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFzeW5jIGRyYXcoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy9DcmVhdGUgaGVhZGVyIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuaGVhZGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JTZXR0aW5ncy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oZWFkZXJDb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1jb250YWluZXInKTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGUgY29udHJvbGUgYmxvY2tcclxuICAgICAgICBjb25zdCBibG9ja0NvbnRyb2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoYmxvY2tDb250cm9sZSk7XHJcbiAgICAgICAgYmxvY2tDb250cm9sZS5jbGFzc0xpc3QuYWRkKCdibG9jay1jb250cm9sZScpO1xyXG5cclxuICAgICAgICAvL0NyZWF0ZSByZWZyZXNoIEJ1dHRvblxyXG4gICAgICAgIGNvbnN0IHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgYmxvY2tDb250cm9sZS5hcHBlbmRDaGlsZChyZWZyZXNoQnV0dG9uKTtcclxuICAgICAgICByZWZyZXNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZnJlc2gtYnV0dG9uJyk7XHJcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi50aXRsZSA9IExuZy5ndChcIlJlZnJlc2hcIik7XHJcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5ocmVmID0gXCIjXCI7XHJcbiAgICAgICAgc2V0SWNvbihyZWZyZXNoQnV0dG9uLCBcInJlZnJlc2gtY3dcIik7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVnaXN0ZXJEb21FdmVudChyZWZyZXNoQnV0dG9uLCAnY2xpY2snLCBhc3luYyAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yU2V0dGluZ3MuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGFibGVDb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMudGFibGVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgndGFibGUtY29udGFpbmVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25lbnQgb24gcmVxdWVzdC4gQ2xlYXJzIHRoZSBjb250YWluZXIgYW5kIGNhbGxzIHRoZSBgZHJhd2AgbWV0aG9kLlxyXG4gICAgICogQHJlbWFya3MgVGhpcyBtZXRob2RlIGNsZWFycyB0aGUgY29udGFpbmVyIGFuZCBjYWxscyB0aGUgYGRyYXdgIG1ldGhvZGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyByZWRyYXcoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JTZXR0aW5ncy5jb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBoZWFkZXIuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFJlbW92ZXMgdGhlIGBkaXNhYmxlYCBjbGFzcyBmcm9tIHRoZSBoZWFkZXIuXHJcbiAgICAgKiAtIFRoZSBoZWFkZXIgaXMgbm90IGdyYXllZCBvdXQgYW55bW9yZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG5vcm1hbGl6ZUhlYWRlcigpIHtcclxuICAgICAgICB0aGlzLmhlYWRlckNvbnRhaW5lci5yZW1vdmVDbGFzcygnZGlzYWJsZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JheXMgb3V0IHRoZSBoZWFkZXIuXHJcbiAgICAgKiBAcmVtYXJrcyAtIEFkZHMgdGhlIGBkaXNhYmxlYCBjbGFzcyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICogLSBUaGUgaGVhZGVyIGlzIGdyYXllZCBvdXQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBncmF5T3V0SGVhZGVyKCkge1xyXG4gICAgICAgIHRoaXMuaGVhZGVyQ29udGFpbmVyLmFkZENsYXNzKCdkaXNhYmxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgc2V0dGluZ3MgZnJvbSB0aGUgTWFya2Rvd24gY29kZSBibG9jay5cclxuICAgICAqIEByZW1hcmtzIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBhcnNlIHRoZSBzZXR0aW5ncy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlU2V0dGluZ3MoKTogdm9pZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0VUlEKG1vZGVsOiBUKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gSGVscGVyLmdlbmVyYXRlVUlEKG1vZGVsLmZpbGUucGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2RlbHMuXHJcbiAgICAgKiBAcmVtYXJrcyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gdGhlIG1vZGVscy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE1vZGVscygpOiBQcm9taXNlPFRbXT5cclxufVxyXG4iLCAiW1xyXG4gICAge1xyXG4gICAgICAgIFwibGFuZ1wiOiBcImVuXCIsXHJcbiAgICAgICAgXCJ0cmFuc2xhdGlvbnNcIjoge1xyXG4gICAgICAgICAgICBcIkRvY3VtZW50VHlwZVwiOiBcIlR5cGVcIixcclxuICAgICAgICAgICAgXCJEYXRlXCI6IFwiRGF0ZVwiLFxyXG4gICAgICAgICAgICBcIlN1YmplY3RcIjogXCJTdWJqZWN0XCIsXHJcbiAgICAgICAgICAgIFwiU2VuZGVyXCI6IFwiU2VuZGVyXCIsXHJcbiAgICAgICAgICAgIFwiUmVjaXBpZW50XCI6IFwiUmVjaXBpZW50XCIsXHJcbiAgICAgICAgICAgIFwiU2VuZFJlY2lwXCI6IFwiU25kLi9SY3AuXCIsXHJcbiAgICAgICAgICAgIFwiQ29udGVudFwiOiBcIkNvbnRlbnRcIixcclxuICAgICAgICAgICAgXCJEZWxpdmVyeURhdGVcIjogXCJEZWxpdmVyeSBkYXRlXCIsXHJcbiAgICAgICAgICAgIFwiVGFnc1wiOiBcIlRhZ3NcIixcclxuICAgICAgICAgICAgXCJGcm9tXCI6IFwiZnJvbTpcIixcclxuICAgICAgICAgICAgXCJUb1wiOiBcInRvOlwiLFxyXG4gICAgICAgICAgICBcIlJlZnJlc2hcIjogXCJSZWZyZXNoXCIsXHJcbiAgICAgICAgICAgIFwiRG9jdW1lbnRzXCI6IFwiRG9jdW1lbnRzXCIsXHJcbiAgICAgICAgICAgIFwiSGlkZURvY3VtZW50c1wiOiBcIkhpZGUgZG9jdW1lbnRzXCIsXHJcbiAgICAgICAgICAgIFwiQ2x1c3RlclwiOiBcIkRvY3VtZW50IENsdXN0ZXJcIixcclxuICAgICAgICAgICAgXCJGaWx0ZXJcIjogXCJGaWx0ZXI6XCIsXHJcbiAgICAgICAgICAgIFwiTWF4U2hvd25FbnRyeXNcIjogXCJNYXguIHNob3duIGVudHJpZXNcIixcclxuICAgICAgICAgICAgXCJTZWFyY2hcIjogXCJTZWFyY2hcIixcclxuICAgICAgICAgICAgXCJEb2N1bWVudERhdGVcIjogXCJEb2N1bWVudCBkYXRlXCIsXHJcbiAgICAgICAgICAgIFwiTWV0YWRhdGFGaWxlXCI6IFwiTWV0YWRhdGEgZmlsZVwiLFxyXG4gICAgICAgICAgICBcIlBERkZpbGVcIjogXCJQREYgZmlsZVwiLFxyXG4gICAgICAgICAgICBcIlRyYWZpY0xpZ2h0XCI6IFwiXHVEODNEXHVERUE2XCIsXHJcbiAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjogXCJEZXNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgICBcIlByaW9yaXR5XCI6IFwiUHJpby5cIixcclxuICAgICAgICAgICAgXCJTdGF0dXNcIjogXCJTdGF0dXNcIixcclxuICAgICAgICAgICAgXCJEdWVEYXRlXCI6IFwiRHVlIGRhdGVcIixcclxuICAgICAgICAgICAgXCJQcmlvcml0eVRleHRcIjogXCJQcmlvcml0eVwiLFxyXG4gICAgICAgICAgICBcIkhpZ2hQcmlvcml0eVwiOiBcIkhpZ2ggcHJpb3JpdHlcIixcclxuICAgICAgICAgICAgXCJNZWRpdW1Qcmlvcml0eVwiOiBcIk1lZGl1bSBwcmlvcml0eVwiLFxyXG4gICAgICAgICAgICBcIkxvd1ByaW9yaXR5XCI6IFwiTG93IHByaW9yaXR5XCIsXHJcbiAgICAgICAgICAgIFwiTm9Qcmlvcml0eVwiOiBcIk5vIHByaW9yaXR5XCIsXHJcbiAgICAgICAgICAgIFwiVGl0bGVcIjogXCJUaXRsZVwiLFxyXG4gICAgICAgICAgICBcIlN0YXR1c0FjdGl2ZVwiOiBcIkFjdGl2ZVwiLFxyXG4gICAgICAgICAgICBcIlN0YXR1c1dhaXRpbmdcIjogXCJXYWl0aW5nXCIsXHJcbiAgICAgICAgICAgIFwiU3RhdHVzTGF0ZXJcIjogXCJMYXRlclwiLFxyXG4gICAgICAgICAgICBcIlN0YXR1c1NvbWVkYXlcIjogXCJTb21lZGF5XCIsXHJcbiAgICAgICAgICAgIFwiU3RhdHVzRG9uZVwiOiBcIkRvbmVcIixcclxuICAgICAgICAgICAgXCJEb25lXCI6IFwiRG9uZVwiLFxyXG4gICAgICAgICAgICBcIlRvcGljXCI6IFwiVG9waWNcIixcclxuICAgICAgICAgICAgXCJQcm9qZWN0XCI6IFwiUHJvamVjdFwiLFxyXG4gICAgICAgICAgICBcIlRhc2tcIjogXCJUYXNrXCIsXHJcbiAgICAgICAgICAgIFwiU2hvd01ldGFkYXRhRmlsZVwiOiBcIlNob3cgbWV0YWRhdGEgZmlsZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBcImxhbmdcIjogXCJkZVwiLFxyXG4gICAgICAgIFwidHJhbnNsYXRpb25zXCI6IHtcclxuICAgICAgICAgICAgXCJEb2N1bWVudFR5cGVcIjogXCJUeXBcIixcclxuICAgICAgICAgICAgXCJEYXRlXCI6IFwiRGF0dW1cIixcclxuICAgICAgICAgICAgXCJTdWJqZWN0XCI6IFwiQmV0cmVmZlwiLFxyXG4gICAgICAgICAgICBcIlNlbmRlclwiOiBcIkFic2VuZGVyXCIsXHJcbiAgICAgICAgICAgIFwiUmVjaXBpZW50XCI6IFwiRW1wZlx1MDBFNG5nZXJcIixcclxuICAgICAgICAgICAgXCJTZW5kUmVjaXBcIjogXCJBYnMuL0VtcGYuXCIsXHJcbiAgICAgICAgICAgIFwiQ29udGVudFwiOiBcIkluaGFsdFwiLFxyXG4gICAgICAgICAgICBcIkRlbGl2ZXJ5RGF0ZVwiOiBcIlp1c3RlbGxkYXR1bVwiLFxyXG4gICAgICAgICAgICBcIlRhZ3NcIjogXCJUYWdzXCIsXHJcbiAgICAgICAgICAgIFwiRnJvbVwiOiBcInZvbjpcIixcclxuICAgICAgICAgICAgXCJUb1wiOiBcImFuOlwiLFxyXG4gICAgICAgICAgICBcIlJlZnJlc2hcIjogXCJBa3R1YWxpc2llcmVuXCIsXHJcbiAgICAgICAgICAgIFwiRG9jdW1lbnRzXCI6IFwiRG9rdW1lbnRlXCIsXHJcbiAgICAgICAgICAgIFwiSGlkZURvY3VtZW50c1wiOiBcIkF1c2dlYmxlbmRldGUgRG9rdW1lbnRlXCIsXHJcbiAgICAgICAgICAgIFwiQ2x1c3RlclwiOiBcIkRva3VtZW50ZW4gQ2x1c3RlclwiLFxyXG4gICAgICAgICAgICBcIkZpbHRlclwiOiBcIkZpbHRlcjpcIixcclxuICAgICAgICAgICAgXCJNYXhTaG93bkVudHJ5c1wiOiBcIk1heC4gYW5nZXplaWd0ZSBFaW50clx1MDBFNGdlXCIsXHJcbiAgICAgICAgICAgIFwiU2VhcmNoXCI6IFwiU3VjaGVcIixcclxuICAgICAgICAgICAgXCJEb2N1bWVudERhdGVcIjogXCJEb2t1bWVudGVuIERhdHVtXCIsXHJcbiAgICAgICAgICAgIFwiTWV0YWRhdGFGaWxlXCI6IFwiTWV0YWRhdGVuIERhdGVpXCIsXHJcbiAgICAgICAgICAgIFwiUERGRmlsZVwiOiBcIlBERiBEYXRlaVwiLFxyXG4gICAgICAgICAgICBcIlRyYWZpY0xpZ2h0XCI6IFwiXHVEODNEXHVERUE2XCIsXHJcbiAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjogXCJCZXNjaHJlaWJ1bmdcIixcclxuICAgICAgICAgICAgXCJQcmlvcml0eVwiOiBcIlByaW8uXCIsXHJcbiAgICAgICAgICAgIFwiU3RhdHVzXCI6IFwiU3RhdHVzXCIsXHJcbiAgICAgICAgICAgIFwiRHVlRGF0ZVwiOiBcIkZcdTAwRTRsbGlnay4tRGF0dW1cIixcclxuICAgICAgICAgICAgXCJQcmlvcml0eVRleHRcIjogXCJQcmlvcml0XHUwMEU0dFwiLFxyXG4gICAgICAgICAgICBcIkhpZ2hQcmlvcml0eVwiOiBcIkhvaGUgUHJpb3JpdFx1MDBFNHRcIixcclxuICAgICAgICAgICAgXCJNZWRpdW1Qcmlvcml0eVwiOiBcIk1pdHRsZXJlIFByaW9yaXRcdTAwRTR0XCIsXHJcbiAgICAgICAgICAgIFwiTG93UHJpb3JpdHlcIjogXCJOaWVkcmlnZSBQcmlvcml0XHUwMEU0dFwiLFxyXG4gICAgICAgICAgICBcIk5vUHJpb3JpdHlcIjogXCJLZWluZSBQcmlvcml0XHUwMEU0dFwiLFxyXG4gICAgICAgICAgICBcIlRpdGxlXCI6IFwiVGl0ZWxcIixcclxuICAgICAgICAgICAgXCJTdGF0dXNBY3RpdmVcIjogXCJBa3RpdlwiLFxyXG4gICAgICAgICAgICBcIlN0YXR1c1dhaXRpbmdcIjogXCJXYXJ0ZW5cIixcclxuICAgICAgICAgICAgXCJTdGF0dXNMYXRlclwiOiBcIlNwXHUwMEU0dGVyXCIsXHJcbiAgICAgICAgICAgIFwiU3RhdHVzU29tZWRheVwiOiBcIklyZ2VuZHdhbm5cIixcclxuICAgICAgICAgICAgXCJTdGF0dXNEb25lXCI6IFwiRXJsZWRpZ3RcIixcclxuICAgICAgICAgICAgXCJEb25lXCI6IFwiRXJsZWRpZ3RcIixcclxuICAgICAgICAgICAgXCJUb3BpY1wiOiBcIlRoZW1hXCIsXHJcbiAgICAgICAgICAgIFwiUHJvamVjdFwiOiBcIlByb2pla3RcIixcclxuICAgICAgICAgICAgXCJUYXNrXCI6IFwiQXVmZ2FiZVwiLFxyXG4gICAgICAgICAgICBcIlNob3dNZXRhZGF0YUZpbGVcIjogXCJNZXRhZGF0ZW4gRGF0ZWkgYW56ZWlnZW5cIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXVxyXG4iLCAiaW1wb3J0IFRyYW5zbGF0aW9ucyBmcm9tICcuLi90cmFuc2xhdGlvbnMuanNvbic7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSBcIi4vR2xvYmFsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMbmcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdHJhbnNsYXRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogQHJlbWFya3MgLSBJZiB0aGUgdHJhbnNsYXRpb24gaXMgbm90IGZvdW5kLCB0aGUga2V5IGlzIHJldHVybmVkLlxyXG4gICAgICogLSBMb29rIGF0IHRoZSBgdHJhbnNsYXRpb25zLmpzb25gIGZpbGUgdG8gc2VlIGFsbCBhdmFpbGFibGUgdHJhbnNsYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGd0KGtleTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBsb2dnZXIgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5sb2dnZXJcclxuICAgICAgICBjb25zdCBsYW5nID0gR2xvYmFsLmdldEluc3RhbmNlKCkuc2V0dGluZ3MubGFuZ3VhZ2U7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb24gPSAoVHJhbnNsYXRpb25zIGFzIFRyYW5zbGF0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB0cmFuc2xhdGlvbi5maW5kKCh2KSA9PiB2LmxhbmcgPT09IGxhbmcpO1xyXG4gICAgICAgIGlmIChsYW5ndWFnZSkge1xyXG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2UudHJhbnNsYXRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZS50cmFuc2xhdGlvbnNba2V5XSBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYFRyYW5zbGF0aW9uIGZvciBrZXkgJHtrZXl9IG5vdCBmb3VuZGApO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBMYW5ndWFnZVRyYW5zbGF0aW9ucyB7XHJcbiAgICBsYW5nOiBzdHJpbmc7XHJcbiAgICB0cmFuc2xhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn1cclxudHlwZSBUcmFuc2xhdGlvbnMgPSBMYW5ndWFnZVRyYW5zbGF0aW9uc1tdOyIsICIvLyBOb3RlOiBTZWFyY2hMaWIgY2xhc3NcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIHNlYXJjaCB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IHJlcHJlc2VudCB0aGUgc2VhcmNoIHRlcm1zXHJcbiAgICAgKiBAcGFyYW0gc2VhcmNoVGV4dCBUaGUgc2VhcmNoIHRleHQgdG8gcGFyc2VcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAtIHRlcm06IFRoZSBzZWFyY2ggdGVybVxyXG4gICAgICogLSBuZWdhdGU6IFdoZXRoZXIgdGhlIHRlcm0gc2hvdWxkIGJlIG5lZ2F0ZWRcclxuICAgICAqIC0gaXNPcGVyYXRvcjogV2hldGhlciB0aGUgdGVybSBpcyBhbiBvcGVyYXRvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2VTZWFyY2hUZXh0KHNlYXJjaFRleHQ6IHN0cmluZyk6IFNlYXJjaFRlcm1zQXJyYXkge1xyXG4gICAgICAgIHNlYXJjaFRleHQgPSBzZWFyY2hUZXh0LnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWFyY2ggdGV4dCBjb250YWlucyBxdW90ZXM6IElmIG5vdCwgcmV0dXJuIHRoZSBzZWFyY2ggdGV4dCBhcyBhIHNpbmdsZSB0ZXJtIChubyBjb21wbGV4IHNlYXJjaCBsb2dpYylcclxuICAgICAgICBpZiAoIXNlYXJjaFRleHQuaW5jbHVkZXMoJ1wiJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7IHRlcm06IHNlYXJjaFRleHQudHJpbSgpLCBuZWdhdGU6IGZhbHNlLCBpc09wZXJhdG9yOiBmYWxzZSB9XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRlcm1zID0gW107XHJcbiAgICAgICAgbGV0IHRlcm0gPSAnJztcclxuICAgICAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgbmVnYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzZWFyY2hUZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5RdW90ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSB0ZXJtIHdpdGggbmVnYXRpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgICAgdGVybXMucHVzaCh7IHRlcm06IHRlcm0udG9Mb3dlckNhc2UoKSwgbmVnYXRlOiBuZWdhdGUsIGlzT3BlcmF0b3I6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBuZWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtICs9IGNoYXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc3BhY2VzIG91dHNpZGUgb2YgcXVvdGVzXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChbJyYnLCAnfCcsICchJ10uaW5jbHVkZXMoY2hhcikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXJtLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtcy5wdXNoKHsgdGVybTogdGVybSwgbmVnYXRlOiBuZWdhdGUsIGlzT3BlcmF0b3I6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBuZWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnIScpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtcy5wdXNoKHsgdGVybTogY2hhciwgbmVnYXRlOiBmYWxzZSwgaXNPcGVyYXRvcjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gKz0gY2hhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRlcm0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0ZXJtcy5wdXNoKHsgdGVybTogdGVybSwgbmVnYXRlOiBuZWdhdGUsIGlzT3BlcmF0b3I6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgYW5kIGFkZCB0aGUgZGVmYXVsdCBBTkQgb3BlcmF0b3JcclxuICAgICAgICBpZiAodGVybXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGVybXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtc1tpXS5pc09wZXJhdG9yICYmICF0ZXJtc1tpICsgMV0uaXNPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZGVmYXVsdCBBTkQgb3BlcmF0b3IgYmV0d2VlbiB0d28gbm9uLW9wZXJhdG9yIHRlcm1zXHJcbiAgICAgICAgICAgICAgICAgICAgdGVybXMuc3BsaWNlKGkgKyAxLCAwLCB7IHRlcm06ICcmJywgbmVnYXRlOiBmYWxzZSwgaXNPcGVyYXRvcjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkgKz0gMjsgLy8gSnVtcCB0byB0aGUgbmV4dCBwYWlyIG9mIHRlcm1zXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGVybXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBzZWFyY2ggbG9naWMgdG8gdGhlIGdpdmVuIHRleHQgY29udGVudFxyXG4gICAgICogQHBhcmFtIHRlcm1zIFRoZSBzZWFyY2ggdGVybXNcclxuICAgICAqIEBwYXJhbSB0ZXh0Q29udGVudCBUaGUgdGV4dCBjb250ZW50IHRvIGFwcGx5IHRoZSBzZWFyY2ggbG9naWMgdG9cclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRleHQgY29udGVudCBtYXRjaGVzIHRoZSBzZWFyY2ggdGVybXMgKHRydWUgb3IgZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhcHBseVNlYXJjaExvZ2ljKHRlcm1zOiBTZWFyY2hUZXJtc0FycmF5LCB0ZXh0Q29udGVudDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAvLyBJZiBvbmx5IG9uZSB0ZXJtIGlzIHByZXNlbnQuLlxyXG4gICAgICAgIGxldCByZXN1bHQgPSB0ZXJtc1swXS5uZWdhdGUgPyAhdGV4dENvbnRlbnQuaW5jbHVkZXModGVybXNbMF0udGVybSkgOiB0ZXh0Q29udGVudC5pbmNsdWRlcyh0ZXJtc1swXS50ZXJtKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0ZXJtcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvck9iaiA9IHRlcm1zW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0VGVybU9iaiA9IHRlcm1zW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRUZXJtTWF0Y2ggPSBuZXh0VGVybU9iai5uZWdhdGUgPyAhdGV4dENvbnRlbnQuaW5jbHVkZXMobmV4dFRlcm1PYmoudGVybSkgOiB0ZXh0Q29udGVudC5pbmNsdWRlcyhuZXh0VGVybU9iai50ZXJtKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvck9iai50ZXJtID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBuZXh0VGVybU1hdGNoO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yT2JqLnRlcm0gPT09ICd8Jykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IG5leHRUZXJtTWF0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2VhcmNoIHRlcm1cclxuICogQHByb3BlcnR5IHRlcm0gVGhlIHNlYXJjaCB0ZXJtXHJcbiAqIEBwcm9wZXJ0eSBuZWdhdGUgV2hldGhlciB0aGUgdGVybSBzaG91bGQgYmUgbmVnYXRlZFxyXG4gKiBAcHJvcGVydHkgaXNPcGVyYXRvciBXaGV0aGVyIHRoZSB0ZXJtIGlzIGFuIG9wZXJhdG9yXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTZWFyY2hUZXJtID0ge1xyXG4gICAgdGVybTogc3RyaW5nO1xyXG4gICAgbmVnYXRlOiBib29sZWFuO1xyXG4gICAgaXNPcGVyYXRvcjogYm9vbGVhbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFycmF5IG9mIHNlYXJjaCB0ZXJtc1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgU2VhcmNoVGVybXNBcnJheSA9IEFycmF5PFNlYXJjaFRlcm0+OyIsICJpbXBvcnQgR2xvYmFsIGZyb20gXCIuLi9jbGFzc2VzL0dsb2JhbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFibGUge1xyXG4gICAgcHVibGljIGdldCBkYXRhKCk6IFN0cnVjdGVkVGFibGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWJsZTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgbG9nZ2VyID0gR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyO1xyXG4gICAgcHJpdmF0ZSBfdGFibGU6IFN0cnVjdGVkVGFibGU7XHJcbiAgICAvKipcclxuICAgICAqIEEgbGlzdCBvZiByb3cgcGxhY2Vob2xkZXJzXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSByb3cgcGxhY2Vob2xkZXJzIGFyZSB1c2VkIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSByb3dzIHdoZW4gaGlkaW5nIGFuZCBzaG93aW5nIHJvd3MuXHJcbiAgICAgKiAtIFRoZSBwbGFjZWhvbGRlcnMgcm93cyBhcmUgZW1wdHkgYW5kIGhhdmUgdGhlIGlkIGBkZWZhdWx0SWRzLnBsYWNlaG9sZGVyYCAoZGVmYXVsdDogYHBsYWNlaG9sZGVyLXJvd2ApLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9yb3dQbGFjZWhvbGRlcnM6IFJvd1BsYWNlaG9sZGVyW10gPSBbXTtcclxuICAgIHByaXZhdGUgX2hlYWRlcnM6IFRhYmxlSGVhZGVyW107XHJcbiAgICBwcml2YXRlIF90YWJsZUlkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF90YWJsZUNsYXNzTGlzdDogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF92aXNpYmxlUm93cyA9IDA7XHJcbiAgICBwcml2YXRlIF9oaWRkZW5Sb3dzID0gMDtcclxuICAgIC8vICAgRGVmYXVsdCBjbGFzc2VzICAvL1xyXG4gICAgcHJpdmF0ZSBkZWZhdWx0Q2xhc3NlcyA9IHtcclxuICAgICAgICB0YWJsZTogWydwcmotdGFibGUnXSxcclxuICAgICAgICBoZWFkZXI6IFsncHJqLXRhYmxlLWhlYWRlciddLFxyXG4gICAgICAgIGhlYWRlclJvdzogWydwcmotdGFibGUtaGVhZGVyLXJvdyddLFxyXG4gICAgICAgIGhlYWRlckNlbGw6IFsncHJqLXRhYmxlLWhlYWRlci1jZWxsJ10sXHJcbiAgICAgICAgYm9keTogWydwcmotdGFibGUtYm9keSddLFxyXG4gICAgICAgIHJvdzogWydwcmotdGFibGUtcm93JywgJ3Byai10YWJsZS1yb3ctaG92ZXInXSxcclxuICAgICAgICBjZWxsOiBbJ3Byai10YWJsZS1jZWxsJ10sXHJcblxyXG4gICAgICAgIGhpZGRlblJvdzogJ2hpZGRlbi1yb3cnLFxyXG4gICAgICAgIGV2ZW5Sb3c6ICdldmVuLXJvdycsXHJcbiAgICAgICAgb2RkUm93OiAnb2RkLXJvdydcclxuICAgIH07XHJcbiAgICAvLyBEZWZhdWx0IElEcyBcclxuICAgIHByaXZhdGUgZGVmYXVsdElkcyA9IHtcclxuICAgICAgICBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlci1yb3dcIlxyXG4gICAgfTtcclxuICAgIC8vIC8vIC8vLy8gLy8gLy8vLyAvLyAvL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZVxyXG4gICAgICogQHBhcmFtIHRhYmxlSGVhZGVycyBBIGxpc3Qgb2YgdGFibGUgaGVhZGVyc1xyXG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCBvZiB0aGUgdGFibGVcclxuICAgICAqIEBwYXJhbSBjbGFzc0xpc3QgVGhlIGNsYXNzIGxpc3Qgb2YgdGhlIHRhYmxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRhYmxlSGVhZGVyczogVGFibGVIZWFkZXJbXSwgaWQ6IHN0cmluZywgY2xhc3NMaXN0OiBzdHJpbmdbXSB8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB0YWJsZUhlYWRlcnM7XHJcbiAgICAgICAgdGhpcy5fdGFibGVJZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX3RhYmxlQ2xhc3NMaXN0ID0gY2xhc3NMaXN0O1xyXG4gICAgICAgIHRoaXMuX3RhYmxlID0gdGhpcy5jcmVhdGVUYWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsdGUgdGhlIGNvbXBsZXRlIHRhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWNvbnN0cnVjdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3RhYmxlLnRhYmxlLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlVGFibGUoKTogU3RydWN0ZWRUYWJsZSB7XHJcbiAgICAgICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xyXG4gICAgICAgIHRhYmxlLmlkID0gdGhpcy5fdGFibGVJZDtcclxuICAgICAgICB0YWJsZS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZGVmYXVsdENsYXNzZXMudGFibGUpO1xyXG4gICAgICAgIGlmICh0aGlzLl90YWJsZUNsYXNzTGlzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl90YWJsZUNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzSXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZS5jbGFzc0xpc3QuYWRkKGNsYXNzSXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFibGVIZWFkZXIgPSB0YWJsZS5jcmVhdGVUSGVhZCgpO1xyXG4gICAgICAgIHRhYmxlSGVhZGVyLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kZWZhdWx0Q2xhc3Nlcy5oZWFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlSGVhZGVyUm93ID0gdGFibGVIZWFkZXIuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgdGFibGVIZWFkZXJSb3cuY2xhc3NMaXN0LmFkZCguLi50aGlzLmRlZmF1bHRDbGFzc2VzLmhlYWRlclJvdyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRhYmxlSGVhZGVyQ2VsbHM6IEhUTUxUYWJsZUNlbGxFbGVtZW50W10gPSBbXTtcclxuICAgICAgICB0aGlzLl9oZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFibGVIZWFkZXJDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kZWZhdWx0Q2xhc3Nlcy5oZWFkZXJDZWxsKTtcclxuICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsLmlkID0gdGhpcy5tYWtlU2FmZUZvcklkKGhlYWRlci50ZXh0KTtcclxuICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsLnRleHRDb250ZW50ID0gaGVhZGVyLnRleHQ7XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIuaGVhZGVyQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlci5oZWFkZXJDbGFzcy5mb3JFYWNoKGNsYXNzSXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsLmNsYXNzTGlzdC5hZGQoY2xhc3NJdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhYmxlSGVhZGVyQ2VsbHMucHVzaCh0YWJsZUhlYWRlckNlbGwpO1xyXG4gICAgICAgICAgICB0YWJsZUhlYWRlclJvdy5hcHBlbmRDaGlsZCh0YWJsZUhlYWRlckNlbGwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHRhYmxlQm9keSA9IHRhYmxlLmNyZWF0ZVRCb2R5KCk7XHJcbiAgICAgICAgdGFibGVCb2R5LmNsYXNzTGlzdC5hZGQoLi4udGhpcy5kZWZhdWx0Q2xhc3Nlcy5ib2R5KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RydWN0ZWRUYWJsZSA9IHtcclxuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxyXG4gICAgICAgICAgICBoZWFkZXI6IHRhYmxlSGVhZGVyLFxyXG4gICAgICAgICAgICBoZWFkZXJSb3c6IHRhYmxlSGVhZGVyUm93LFxyXG4gICAgICAgICAgICBoZWFkZXJDZWxsczogdGFibGVIZWFkZXJDZWxscyxcclxuICAgICAgICAgICAgYm9keTogdGFibGVCb2R5LFxyXG4gICAgICAgICAgICByb3dzOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBzdHJ1Y3RlZFRhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdyB0byB0aGUgdGFibGVcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgbmV3IHJvd1xyXG4gICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIGRhdGEgb2YgdGhlIG5ldyByb3dcclxuICAgICAqIEBwYXJhbSByb3dDbGFzc0xpc3QgVGhlIGNsYXNzIGxpc3Qgb2YgdGhlIG5ldyByb3dcclxuICAgICAqIEBwYXJhbSBoaWRkZW4gV2hldGhlciB0aGUgbmV3IHJvdyBzaG91bGQgYmUgaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRSb3cocm93OiBSb3cpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9hZGRSb3cocm93LnJvd1VpZCwgcm93LnJvd0RhdGEsIHJvdy5yb3dDbGFzc0xpc3QsIHJvdy5oaWRkZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBtdWx0aXBsZSByb3dzIHRvIHRoZSB0YWJsZVxyXG4gICAgICogQHBhcmFtIHJvd3MgVGhlIHJvd3MgdG8gYWRkXHJcbiAgICAgKiBAcGFyYW0gcm93cy5yb3dVaWQgVGhlIFVJRCBvZiB0aGUgbmV3IHJvd1xyXG4gICAgICogQHBhcmFtIHJvd3Mucm93RGF0YSBUaGUgZGF0YSBvZiB0aGUgbmV3IHJvd1xyXG4gICAgICogQHBhcmFtIHJvd3Mucm93Q2xhc3NMaXN0IFRoZSBjbGFzcyBsaXN0IG9mIHRoZSBuZXcgcm93XHJcbiAgICAgKiBAcGFyYW0gcm93cy5oaWRkZW4gV2hldGhlciB0aGUgbmV3IHJvdyBzaG91bGQgYmUgaGlkZGVuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSByb3dzIGFyZSBhZGRlZCBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxyXG4gICAgICogLSBUaGUgcm93cyBhcmUgYWRkZWQgdG8gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAgICogLSBJZiB0aGUgcm93IGlzIGhpZGRlbiwgdGhlIHJvdyBjb250ZW50IGlzIHJlcGxhY2VkIHdpdGggYSBwbGFjZWhvbGRlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFJvd3Mocm93czogUm93W10pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0ZWRSb3dzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByb3dGcmFnbWVudCA9IHRoaXMuY3JlYXRlUm93KHJvdy5yb3dVaWQsIHJvdy5yb3dEYXRhLCByb3cucm93Q2xhc3NMaXN0LCByb3cuaGlkZGVuKTtcclxuICAgICAgICAgICAgaWYgKHJvd0ZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YWJsZS5yb3dzLnB1c2gocm93RnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdy5oaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSb3dzLmFwcGVuZCh0aGlzLl9nZXRQbGFjZWhvbGRlcihyb3cucm93VWlkKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJvd3MuYXBwZW5kKHJvd0ZyYWdtZW50KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdGFibGUuYm9keS5hcHBlbmQoY29sbGVjdGVkUm93cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm93IHRvIHRoZSB0YWJsZVxyXG4gICAgICogQHBhcmFtIHJvd1VpZCBUaGUgVUlEIG9mIHRoZSBuZXcgcm93XHJcbiAgICAgKiBAcGFyYW0gcm93RGF0YSBUaGUgZGF0YSBvZiB0aGUgbmV3IHJvdyBhcyBhbiBhcnJheSBvZiBEb2N1bWVudEZyYWdtZW50cy4gRWFjaCBEb2N1bWVudEZyYWdtZW50IHJlcHJlc2VudHMgYSBjZWxsLlxyXG4gICAgICogQHBhcmFtIHJvd0NsYXNzTGlzdCBUaGUgY2xhc3MgbGlzdCBvZiB0aGUgbmV3IHJvd1xyXG4gICAgICogQHBhcmFtIGhpZGRlbiBXaGV0aGVyIHRoZSBuZXcgcm93IHNob3VsZCBiZSBoaWRkZW5cclxuICAgICAqIEByZW1hcmtzIC0gVGhlIHJvdyBpcyBhZGRlZCB0byB0aGUgaW50ZXJuYWwgYXJyYXkuXHJcbiAgICAgKiAtIElmIHRoZSByb3cgaXMgaGlkZGVuLCB0aGUgcm93IGNvbnRlbnQgaXMgcmVwbGFjZWQgd2l0aCBhIHBsYWNlaG9sZGVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9hZGRSb3cocm93VWlkOiBzdHJpbmcsIHJvd0RhdGE6IERvY3VtZW50RnJhZ21lbnRbXSwgcm93Q2xhc3NMaXN0OiBzdHJpbmdbXSB8IHVuZGVmaW5lZCwgaGlkZGVuOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdGFibGVSb3cgPSB0aGlzLmNyZWF0ZVJvdyhyb3dVaWQsIHJvd0RhdGEsIHJvd0NsYXNzTGlzdCwgaGlkZGVuKTtcclxuICAgICAgICB0aGlzLl90YWJsZS5yb3dzLnB1c2godGFibGVSb3cpO1xyXG5cclxuICAgICAgICBpZiAoaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhYmxlLmJvZHkuYXBwZW5kKHRoaXMuX2dldFBsYWNlaG9sZGVyKHJvd1VpZCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhYmxlLmJvZHkuYXBwZW5kKHRhYmxlUm93KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByb3dcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93IFxyXG4gICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIGRhdGEgb2YgdGhlIHJvdyBhcyBhbiBhcnJheSBvZiBEb2N1bWVudEZyYWdtZW50cy4gRWFjaCBEb2N1bWVudEZyYWdtZW50IHJlcHJlc2VudHMgYSBjZWxsLlxyXG4gICAgICogQHBhcmFtIHJvd0NsYXNzTGlzdCBUaGUgY2xhc3MgbGlzdCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcGFyYW0gaGlkZGVuIFdoZXRoZXIgdGhlIHJvdyBzaG91bGQgYmUgaGlkZGVuLlxyXG4gICAgICogQHJlbWFya3MgKipJZiB0cnVlLCB0aGUgcm93IGlzIGhpZGRlbiBhbmQgdGhlIHJvdyBjb250ZW50IGlzIGxhdGVyIHJlcGxhY2VkIHdpdGggYSBwbGFjZWhvbGRlci4qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcm93IGFzIGFuIEhUTUxUYWJsZVJvd0VsZW1lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVSb3cocm93VWlkOiBzdHJpbmcsIHJvd0RhdGE6IERvY3VtZW50RnJhZ21lbnRbXSwgcm93Q2xhc3NMaXN0OiBzdHJpbmdbXSB8IHVuZGVmaW5lZCwgaGlkZGVuOiBib29sZWFuKTogSFRNTFRhYmxlUm93RWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG5cclxuICAgICAgICB0YWJsZVJvdy5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuZGVmYXVsdENsYXNzZXMucm93KTtcclxuICAgICAgICB0YWJsZVJvdy5zZXRBdHRyaWJ1dGUoJ3Jvdy11aWQnLCByb3dVaWQpO1xyXG4gICAgICAgIGlmIChyb3dDbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgcm93Q2xhc3NMaXN0LmZvckVhY2goY2xhc3NJdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIHRhYmxlUm93LmNsYXNzTGlzdC5hZGQoY2xhc3NJdGVtKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoaWRkZW4pIHtcclxuICAgICAgICAgICAgdGFibGVSb3cuY2xhc3NMaXN0LmFkZCh0aGlzLmRlZmF1bHRDbGFzc2VzLmhpZGRlblJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlblJvd3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJvd09kZE9yRXZlbih0YWJsZVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSb3dzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvd0RhdGEuZm9yRWFjaCgoZGF0YSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFibGVDZWxsID0gdGFibGVSb3cuaW5zZXJ0Q2VsbCgpO1xyXG4gICAgICAgICAgICB0YWJsZUNlbGwuY2xhc3NMaXN0LmFkZCguLi50aGlzLmRlZmF1bHRDbGFzc2VzLmNlbGwpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZGVyc1tpbmRleF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9oZWFkZXJzW2luZGV4XS5jb2x1bW5DbGFzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tpbmRleF0uY29sdW1uQ2xhc3M/LmZvckVhY2goY2xhc3NJdGVtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNlbGwuY2xhc3NMaXN0LmFkZChjbGFzc0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIExhYmVsIGF0dHJpYnV0ZSB0byB0aGUgY2VsbFxyXG4gICAgICAgICAgICB0YWJsZUNlbGwuc2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJywgdGhpcy5faGVhZGVyc1tpbmRleF0udGV4dCk7XHJcbiAgICAgICAgICAgIHRhYmxlQ2VsbC5hcHBlbmRDaGlsZChkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGFibGVSb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByb3cgdG8gb2RkIG9yIGV2ZW5cclxuICAgICAqIEBwYXJhbSB0YWJsZVJvdyBUaGUgcm93IHRvIHNldFxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgcm93IGlzIHNldCB0byBvZGQgb3IgZXZlbiBiYXNlZCBvbiB0aGUgbGFzdCB2aXNpYmxlIHJvdy5cclxuICAgICAqIC0gSWYgbm8gdmlzaWJsZSByb3cgZXhpc3RzLCB0aGUgcm93IGlzIHNldCB0byBldmVuLlxyXG4gICAgICogQHJlbWFya3MgSXQgZG9lcyBub3Qgc2VhcmNoIGZvciB0aGUgbGFzdCB2aXNpYmxlIGxpbmUgaW4gdGhlIEhUTUwgdGFibGUgaXRzZWxmLCBidXQgaW4gYW4gaW50ZXJuYWwgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2V0Um93T2RkT3JFdmVuKHRhYmxlUm93OiBIVE1MVGFibGVSb3dFbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGxhc3RWaXNpYmxlUm93O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl90YWJsZS5yb3dzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGFibGUucm93c1tpXS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5kZWZhdWx0Q2xhc3Nlcy5oaWRkZW5Sb3cpKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZVJvdyA9IHRoaXMuX3RhYmxlLnJvd3NbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdFZpc2libGVSb3cpIHtcclxuICAgICAgICAgICAgdGFibGVSb3cuY2xhc3NMaXN0LmFkZChsYXN0VmlzaWJsZVJvdy5jbGFzc0xpc3QuY29udGFpbnModGhpcy5kZWZhdWx0Q2xhc3Nlcy5ldmVuUm93KSA/IHRoaXMuZGVmYXVsdENsYXNzZXMub2RkUm93IDogdGhpcy5kZWZhdWx0Q2xhc3Nlcy5ldmVuUm93KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YWJsZVJvdy5jbGFzc0xpc3QuYWRkKHRoaXMuZGVmYXVsdENsYXNzZXMuZXZlblJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHZpc2libGUgYW5kIGhpZGRlbiByb3dzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHZpc2libGUgYW5kIGhpZGRlbiByb3dzXHJcbiAgICAgKiBAcmV0dXJucyB2aXNpYmxlUm93cyBUaGUgbnVtYmVyIG9mIHZpc2libGUgcm93c1xyXG4gICAgICogQHJldHVybnMgaGlkZGVuUm93cyBUaGUgbnVtYmVyIG9mIGhpZGRlbiByb3dzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSb3dTdGF0cygpOiB7IHZpc2libGVSb3dzOiBudW1iZXIsIGhpZGRlblJvd3M6IG51bWJlciB9IHtcclxuICAgICAgICByZXR1cm4geyB2aXNpYmxlUm93czogdGhpcy5fdmlzaWJsZVJvd3MsIGhpZGRlblJvd3M6IHRoaXMuX2hpZGRlblJvd3MgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIHJvdyB3aXRoIHRoZSBnaXZlbiBVSURcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSByb3cgaXMgZGVsZXRlZCBmcm9tIHRoZSB0YWJsZSBib2R5IGFuZCB0aGUgaW50ZXJuYWwgYXJyYXkuXHJcbiAgICAgKiAtIElmIGEgcGxhY2Vob2xkZXIgZXhpc3RzLCBpdCBpcyBhbHNvIGRlbGV0ZWQgZnJvbSB0aGUgdGFibGUgYm9keSBhbmQgdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlUm93KHJvd1VpZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgcm93VG9EZWxldGUgPSB0aGlzLmdldFJvdyhyb3dVaWQpO1xyXG4gICAgICAgIGNvbnN0IHJvd1Zpc2libGUgPSByb3dUb0RlbGV0ZSAmJiAhcm93VG9EZWxldGUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZGVmYXVsdENsYXNzZXMuaGlkZGVuUm93KTtcclxuICAgICAgICBpZiAocm93VmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAocm93VG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFibGUuYm9keS5yZW1vdmVDaGlsZChyb3dUb0RlbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJSb3cgbm90IGFjdGl2ZSBpbiB0aGUgdGFibGUuIEVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YWJsZS5yb3dzID0gdGhpcy5fdGFibGUucm93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRBdHRyaWJ1dGUoJ3Jvdy11aWQnKSAhPT0gcm93VWlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVBsYWNlaG9sZGVyKHJvd1VpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVJvd3MtLTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUm93RXZlbk9kZENsYXNzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLl9yZW1vdmVQbGFjZWhvbGRlcihyb3dVaWQpO1xyXG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFibGUuYm9keS5yZW1vdmVDaGlsZChwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQbGFjZWhvbGRlciByb3cgbm90IGFjdGl2ZSBpbiB0aGUgdGFibGUuIEVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGlkZGVuUm93cy0tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHJvdyB0byBoaWRkZW5cclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSByb3cgaXMgc2V0IHRvIGhpZGRlbiBhbmQgdGhlIHJvdyBjb250ZW50IGlzIHJlcGxhY2VkIHdpdGggYSBwbGFjZWhvbGRlci5cclxuICAgICAqIC0gT25seSBpZiB0aGUgc3RhdGUgaGFzIGNoYW5nZWQsIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgb2RkIGFuZCBldmVuIHJvd3MgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGhpZGVSb3cocm93VWlkOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5faGlkZVJvdyhyb3dVaWQpO1xyXG4gICAgICAgIGlmIChjaGFuZ2VzKVxyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hSb3dFdmVuT2RkQ2xhc3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHJvdyB0byBoaWRkZW4sIHJlcGxhY2VzIHRoZSByb3cgY29udGVudCB3aXRoIGEgcGxhY2Vob2xkZXIgYW5kIHVwZGF0ZXMgdGhlIHJvdyBzdGF0c1xyXG4gICAgICogQHBhcmFtIHJvd1VpZCBUaGUgVUlEIG9mIHRoZSByb3dcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIHJvdyBpcyBhbHJlYWR5IGhpZGRlbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaGlkZVJvdyhyb3dVaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBSb3cgJHtyb3dVaWR9IHNob3VsZCBiZSBoaWRkZW4uYCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMudG9nbGVSb3dDbGFzcyhyb3dVaWQsIFt0aGlzLmRlZmF1bHRDbGFzc2VzLmhpZGRlblJvd10sIHRydWUpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBSb3cgJHtyb3dVaWR9IGNoYW5nZXM6ICR7Y2hhbmdlc31gKTtcclxuICAgICAgICBpZiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVSb3dDb250ZW50KHJvd1VpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSb3dzLS07XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlblJvd3MrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgcm93IHRvIHZpc2libGVcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSByb3cgaXMgc2V0IHRvIHZpc2libGUgYW5kIHRoZSByb3cgY29udGVudCBpcyByZXBsYWNlZCB3aXRoIHRoZSBvcmlnaW5hbCBjb250ZW50LlxyXG4gICAgICogLSBPbmx5IGlmIHRoZSBzdGF0ZSBoYXMgY2hhbmdlZCwgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBvZGQgYW5kIGV2ZW4gcm93cyBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1Jvdyhyb3dVaWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9zaG93Um93KHJvd1VpZCk7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMpXHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFJvd0V2ZW5PZGRDbGFzcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgcm93IHRvIHZpc2libGUsIHJlcGxhY2VzIHRoZSBwbGFjZWhvbGRlciB3aXRoIHRoZSBvcmlnaW5hbCByb3cgY29udGVudCBhbmQgdXBkYXRlcyB0aGUgcm93IHN0YXRzXHJcbiAgICAgKiBAcGFyYW0gcm93VWlkIFRoZSBVSUQgb2YgdGhlIHJvd1xyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3RhdGUgaGFzIGNoYW5nZWQuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgcm93IGlzIGFscmVhZHkgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc2hvd1Jvdyhyb3dVaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBSb3cgJHtyb3dVaWR9IHNob3VsZCBiZSBzaG93bi5gKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy50b2dsZVJvd0NsYXNzKHJvd1VpZCwgW3RoaXMuZGVmYXVsdENsYXNzZXMuaGlkZGVuUm93XSwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBSb3cgJHtyb3dVaWR9IGNoYW5nZXM6ICR7Y2hhbmdlc31gKTtcclxuICAgICAgICBpZiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRSb3dDb250ZW50KHJvd1VpZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSb3dzKys7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlblJvd3MtLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzdGF0ZSBvZiBtdWx0aXBsZSByb3dzIHRvIGhpZGRlbiBvciB2aXNpYmxlXHJcbiAgICAgKiBAcGFyYW0gcm93cyBUaGUgcm93cyB0byBjaGFuZ2VcclxuICAgICAqIEBwYXJhbSByb3dzLnJvd1VpZCBUaGUgVUlEIG9mIHRoZSByb3dcclxuICAgICAqIEBwYXJhbSByb3dzLmhpZGRlbiBXaGV0aGVyIHRvIGhpZGUgb3Igc2hvdyB0aGUgcm93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjaGFuZ2VTaG93SGlkZVN0YXRlUm93cyhyb3dzOiBSb3dzU3RhdGVbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBDaGFuZ2UgU2hvdy9IaWRlIHN0YXRlIG9mICR7cm93cy5sZW5ndGh9IHJvd3MuYCk7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBmYWxzZTtcclxuICAgICAgICByb3dzLmZvckVhY2gocm93ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYENoYW5nZSBTaG93L0hpZGUgc3RhdGUgb2YgUm93OiAke3Jvdy5yb3dVaWR9IHRvICR7cm93LmhpZGRlbn0uYCk7XHJcbiAgICAgICAgICAgIGlmIChyb3cuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgSGlkZSBSb3c6ICR7cm93LnJvd1VpZH1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2hpZGVSb3cocm93LnJvd1VpZCk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzIHx8PSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgU2hvdyBSb3c6ICR7cm93LnJvd1VpZH1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Nob3dSb3cocm93LnJvd1VpZCk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzIHx8PSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY2hhbmdlcylcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUm93RXZlbk9kZENsYXNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyB0aGUgcm93IGluIHRhYmxlIGJvZHkgd2l0aCBhIHBsYWNlaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0gcm93VWlkIFRoZSBVSUQgb2YgdGhlIHJvd1xyXG4gICAgICogQHJlbWFya3MgLSBTZWFyY2ggdGhlIHJvdyBpbiB0aGUgaW50ZXJuYWwgYXJyYXksXHJcbiAgICAgKiAtIElmIGZvdW5kLCBnZXQgdGhlIHBsYWNlaG9sZGVyIGZyb20gdGhlIGludGVybmFsIGFycmF5IGFuZCByZXBsYWNlIHRoZSByb3cgaW4gdGhlIHRhYmxlIGJvZHkgd2l0aCB0aGUgcGxhY2Vob2xkZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3JlbW92ZVJvd0NvbnRlbnQocm93VWlkOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvdyhyb3dVaWQpO1xyXG4gICAgICAgIGlmIChyb3cpIHtcclxuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLl9nZXRQbGFjZWhvbGRlcihyb3dVaWQpO1xyXG4gICAgICAgICAgICB0aGlzLl90YWJsZS5ib2R5LnJlcGxhY2VDaGlsZChwbGFjZWhvbGRlciwgcm93KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyB0aGUgcGxhY2Vob2xkZXIgaW4gdGFibGUgYm9keSB3aXRoIHRoZSByb3dcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcmVtYXJrcyAtIFNlYXJjaCB0aGUgcm93IGluIHRoZSBpbnRlcm5hbCBhcnJheSxcclxuICAgICAqIC0gSWYgZm91bmQsIGdldCB0aGUgcGxhY2Vob2xkZXIgZnJvbSB0aGUgaW50ZXJuYWwgYXJyYXkgYW5kIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIGluIHRoZSB0YWJsZSBib2R5IHdpdGggdGhlIHJvdy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfYWRkUm93Q29udGVudChyb3dVaWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93KHJvd1VpZCk7XHJcbiAgICAgICAgaWYgKHJvdykge1xyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMuX2dldFBsYWNlaG9sZGVyKHJvd1VpZCk7XHJcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWJsZS5ib2R5LnJlcGxhY2VDaGlsZChyb3csIHBsYWNlaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBsYWNlaG9sZGVyIHJvdyBub3QgYWN0aXZlIGluIHRoZSB0YWJsZS4gRXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHBsYWNlaG9sZGVyIHJvd1xyXG4gICAgICogQHBhcmFtIHJvd1VpZCBUaGUgVUlEIG9mIHRoZSByb3dcclxuICAgICAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgcGxhY2Vob2xkZXIgcm93XHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBwbGFjZWhvbGRlciByb3cgaXMgZW1wdHkgYW5kIGhhcyB0aGUgaWQgYGRlZmF1bHRJZHMucGxhY2Vob2xkZXJgIChkZWZhdWx0OiBgcGxhY2Vob2xkZXItcm93YCkuXHJcbiAgICAgKiAtIFRoZSBwbGFjZWhvbGRlciByb3cgaXMgYWRkZWQgdG8gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZW5lcmF0ZVBsYWNlaG9sZGVyKHJvd1VpZDogc3RyaW5nKTogSFRNTFRhYmxlUm93RWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIHBsYWNlaG9sZGVyLmlkID0gdGhpcy5kZWZhdWx0SWRzLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgIHBsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgncm93LXVpZCcsIHJvd1VpZCk7XHJcbiAgICAgICAgdGhpcy5fcm93UGxhY2Vob2xkZXJzLnB1c2goeyByb3dVaWQ6IHJvd1VpZCwgcm93OiBwbGFjZWhvbGRlciB9KTtcclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwbGFjZWhvbGRlciByb3cgd2l0aCB0aGUgZ2l2ZW4gVUlEIGZyb20gdGhlIGludGVybmFsIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gcm93VWlkIFRoZSBVSUQgb2YgdGhlIHJvd1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9yZW1vdmVQbGFjZWhvbGRlcihyb3dVaWQ6IHN0cmluZyk6IEhUTUxUYWJsZVJvd0VsZW1lbnQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5fcm93UGxhY2Vob2xkZXJzLmZpbmQocm93UGxhY2Vob2xkZXIgPT4gcm93UGxhY2Vob2xkZXIucm93VWlkID09PSByb3dVaWQpPy5yb3c7XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvd1BsYWNlaG9sZGVycyA9IHRoaXMuX3Jvd1BsYWNlaG9sZGVycy5maWx0ZXIocm93UGxhY2Vob2xkZXIgPT4gcm93UGxhY2Vob2xkZXIucm93VWlkICE9PSByb3dVaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciByb3cgd2l0aCB0aGUgZ2l2ZW4gVUlEXHJcbiAgICAgKiBAcGFyYW0gcm93VWlkIFRoZSBVSUQgb2YgdGhlIHJvd1xyXG4gICAgICogQHJldHVybnMgLSBUaGUgcGxhY2Vob2xkZXIgcm93IHdpdGggdGhlIGdpdmVuIFVJRFxyXG4gICAgICogLSBvciBhIG5ldyBwbGFjZWhvbGRlciByb3cgaWYgbm8gcGxhY2Vob2xkZXIgcm93IHdpdGggdGhlIGdpdmVuIFVJRCBleGlzdHNcclxuICAgICAqIEByZW1hcmtzIC0gSWYgYSBuZXcgcGxhY2Vob2xkZXIgcm93IGlzIGdlbmVyYXRlZCwgaXQgaXMgYWRkZWQgdG8gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRQbGFjZWhvbGRlcihyb3dVaWQ6IHN0cmluZyk6IEhUTUxUYWJsZVJvd0VsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5fcm93UGxhY2Vob2xkZXJzLmZpbmQocm93UGxhY2Vob2xkZXIgPT4gcm93UGxhY2Vob2xkZXIucm93VWlkID09PSByb3dVaWQpPy5yb3c7XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKVxyXG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVBsYWNlaG9sZGVyKHJvd1VpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcm93IHdpdGggdGhlIGdpdmVuIFVJRFxyXG4gICAgICogQHBhcmFtIHJvd1VpZCBUaGUgVUlEIG9mIHRoZSByb3dcclxuICAgICAqIEByZXR1cm5zIFRoZSByb3cgd2l0aCB0aGUgZ2l2ZW4gVUlEIG9yIHVuZGVmaW5lZCBpZiBubyByb3cgd2l0aCB0aGUgZ2l2ZW4gVUlEIGV4aXN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Um93KHJvd1VpZDogc3RyaW5nKTogSFRNTFRhYmxlUm93RWxlbWVudCB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhYmxlLnJvd3MuZmluZChyb3cgPT4gcm93LmdldEF0dHJpYnV0ZSgncm93LXVpZCcpID09PSByb3dVaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgY2xhc3Mgb2YgYSByb3dcclxuICAgICAqIEBwYXJhbSByb3dVaWQgVGhlIFVJRCBvZiB0aGUgcm93XHJcbiAgICAgKiBAcGFyYW0gY2xhc3NMaXN0IFRoZSBjbGFzcyBsaXN0IHRvIHRvZ2dsZVxyXG4gICAgICogQHBhcmFtIGFkZCBXaGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b2dsZVJvd0NsYXNzKHJvd1VpZDogc3RyaW5nLCBjbGFzc0xpc3Q6IHN0cmluZ1tdLCBhZGQ6IGJvb2xlYW4pOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgY2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93KHJvd1VpZCk7XHJcbiAgICAgICAgaWYgKHJvdykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzID0gdGhpcy50b2dnbGVDbGFzcyhyb3csIGNsYXNzTGlzdCwgYWRkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIG9kZCBhbmQgZXZlbiByb3dzIHdpdGggdGhlIGNvcm9zcG9uZGluZyBjbGFzc2VzXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBvZGQgYW5kIGV2ZW4gcm93cyBhcmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgdmlzaWJsZSByb3dzIGZyb20gdGhlIGludGVybmFsIGFycmF5LlxyXG4gICAgICogLSBDaGFuZ2UgdGhlIGNsYXNzZXMgb25seSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVmcmVzaFJvd0V2ZW5PZGRDbGFzcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB2aXNpYmxlUm93cyA9IHRoaXMuX3RhYmxlLnJvd3MuZmlsdGVyKHJvdyA9PiAhcm93LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmRlZmF1bHRDbGFzc2VzLmhpZGRlblJvdykpO1xyXG4gICAgICAgIHZpc2libGVSb3dzLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVDbGFzcyhyb3csIFt0aGlzLmRlZmF1bHRDbGFzc2VzLmV2ZW5Sb3ddLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xhc3Mocm93LCBbdGhpcy5kZWZhdWx0Q2xhc3Nlcy5vZGRSb3ddLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKHJvdywgW3RoaXMuZGVmYXVsdENsYXNzZXMuZXZlblJvd10sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xhc3Mocm93LCBbdGhpcy5kZWZhdWx0Q2xhc3Nlcy5vZGRSb3ddLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9nZ2xlQ2xhc3MoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNsYXNzTGlzdDogc3RyaW5nW10sIGFkZDogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBjaGFuZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcHJlc2VudENsYXNzZXMgPSBlbGVtZW50LmNsYXNzTGlzdDtcclxuICAgICAgICBpZiAoYWRkKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzSXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNlbnRDbGFzc2VzLmNvbnRhaW5zKGNsYXNzSXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3NMaXN0LmZvckVhY2goY2xhc3NJdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVzZW50Q2xhc3Nlcy5jb250YWlucyhjbGFzc0l0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGhlYWRlciBvZiB0aGUgdGFibGVcclxuICAgICAqIEBwYXJhbSBoZWFkZXIgVGhlIGhlYWRlciB0byBjaGFuZ2U7IHRoZSBoZWFkZXIgdGV4dCBtdXN0IG1hdGNoIHRoZSBvcmlnaW5hbCBoZWFkZXIgdGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2hhbmdlSGVhZGVyKGhlYWRlcjogVGFibGVIZWFkZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNoYW5nZUhlYWRlckNsYXNzKGhlYWRlcik7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VDb2x1bW5DbGFzcyhoZWFkZXIpO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcnNbdGhpcy5faGVhZGVycy5maW5kSW5kZXgoaGVhZGVySXRlbSA9PiBoZWFkZXJJdGVtLnRleHQgPT09IGhlYWRlci50ZXh0KV0gPSBoZWFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGFuZ2VIZWFkZXJDbGFzcyhoZWFkZXI6IFRhYmxlSGVhZGVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVySW5kZXggPSB0aGlzLl9oZWFkZXJzLmZpbmRJbmRleChoZWFkZXJJdGVtID0+IGhlYWRlckl0ZW0udGV4dCA9PT0gaGVhZGVyLnRleHQpO1xyXG4gICAgICAgIGNvbnN0IG9sZEhlYWRlckNsYXNzZXMgPSB0aGlzLl9oZWFkZXJzW2hlYWRlckluZGV4XS5oZWFkZXJDbGFzcztcclxuICAgICAgICBjb25zdCBuZXdIZWFkZXJDbGFzc2VzID0gaGVhZGVyLmhlYWRlckNsYXNzO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckNlbGwgPSB0aGlzLl90YWJsZS5oZWFkZXJDZWxsc1toZWFkZXJJbmRleF07XHJcbiAgICAgICAgaWYgKG9sZEhlYWRlckNsYXNzZXMpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVDbGFzcyhoZWFkZXJDZWxsLCBvbGRIZWFkZXJDbGFzc2VzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdIZWFkZXJDbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoaGVhZGVyQ2VsbCwgbmV3SGVhZGVyQ2xhc3NlcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2hhbmdlQ29sdW1uQ2xhc3MoaGVhZGVyOiBUYWJsZUhlYWRlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gdGhpcy5faGVhZGVycy5maW5kSW5kZXgoaGVhZGVySXRlbSA9PiBoZWFkZXJJdGVtLnRleHQgPT09IGhlYWRlci50ZXh0KTtcclxuICAgICAgICBjb25zdCBvbGRIZWFkZXJDbGFzc2VzID0gdGhpcy5faGVhZGVyc1tjb2x1bW5JbmRleF0uaGVhZGVyQ2xhc3M7XHJcbiAgICAgICAgdGhpcy5fdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSByb3cuY2VsbHNbY29sdW1uSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEhlYWRlckNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKGNlbGwsIG9sZEhlYWRlckNsYXNzZXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIuY29sdW1uQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKGNlbGwsIGhlYWRlci5jb2x1bW5DbGFzcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1ha2VTYWZlRm9ySWQoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID09PSAwICYmICFpc05hTihOdW1iZXIoY2hhcikpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIG51bWJlciBiZWNvbWVzIGFuIHVuZGVyc2NvcmVcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhci5tYXRjaCgvW2EtekEtWl0vKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGV0dGVycyBiZWNvbWUgbG93ZXIgY2FzZSBsZXR0ZXJzXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hhci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIubWF0Y2goL1swLTldLykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpZ3VyZXMgYXJlIGFkb3B0ZWRcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgY2hhcmFjdGVycyBiZWNvbWUgdW5kZXJsaW5lc1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdfJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVGFibGVIZWFkZXIgPSB7XHJcbiAgICB0ZXh0OiBzdHJpbmc7XHJcbiAgICBoZWFkZXJDbGFzczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbiAgICBjb2x1bW5DbGFzczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0cnVjdGVkVGFibGUgPSB7XHJcbiAgICB0YWJsZTogSFRNTFRhYmxlRWxlbWVudDtcclxuICAgIGhlYWRlcjogSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ7XHJcbiAgICBoZWFkZXJSb3c6IEhUTUxUYWJsZVJvd0VsZW1lbnQ7XHJcbiAgICBoZWFkZXJDZWxsczogSFRNTFRhYmxlQ2VsbEVsZW1lbnRbXTtcclxuICAgIGJvZHk6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50O1xyXG4gICAgcm93czogSFRNTFRhYmxlUm93RWxlbWVudFtdO1xyXG59XHJcblxyXG50eXBlIFJvd1BsYWNlaG9sZGVyID0ge1xyXG4gICAgcm93VWlkOiBzdHJpbmc7XHJcbiAgICByb3c6IEhUTUxUYWJsZVJvd0VsZW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFJvdyA9IHtcclxuICAgIHJvd1VpZDogc3RyaW5nO1xyXG4gICAgcm93RGF0YTogRG9jdW1lbnRGcmFnbWVudFtdO1xyXG4gICAgcm93Q2xhc3NMaXN0OiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuICAgIGhpZGRlbjogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUm93c1N0YXRlID0ge1xyXG4gICAgcm93VWlkOiBzdHJpbmc7XHJcbiAgICBoaWRkZW46IGJvb2xlYW47XHJcbn0iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBzZXRJY29uIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSBcInNyYy9jbGFzc2VzL0dsb2JhbFwiO1xyXG5pbXBvcnQgTG5nIGZyb20gXCJzcmMvY2xhc3Nlcy9MbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBNYXggc2hvd24gbW9kZWxzIGlucHV0IGNvbXBvbmVudCBjbGFzcyBmb3IgYFRhYmxlQmxvY2tSZW5kZXJDb21wb25lbnRgLlxyXG4gKiBcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIGEgZmlsdGVyIGJ1dHRvbiBjb21wb25lbnQgd2l0aCBhIHN5bWJvbC5cclxuICogSXQgaW5jbHVkZXMgZnVuY3Rpb25hbGl0eSBmb3IgdG9nZ2xpbmcgdGhlIGZpbHRlciBidXR0b24gYW5kIGhhbmRsaW5nIGNsaWNrIGV2ZW50cy5cclxuICogXHJcbiAqIEBzZWUge0BsaW5rIGNyZWF0ZX0gZm9yIGRldGFpbHMgYWJvdXQgY3JlYXRpbmcgYSBmaWx0ZXIgYnV0dG9uIGNvbXBvbmVudC5cclxuICogQHNlZSB7QGxpbmsgRmlsdGVyQ2FsbGJhY2t9IGZvciBkZXRhaWxzIGFib3V0IHRoZSBmaWx0ZXIgY2FsbGJhY2suXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJCdXR0b24ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudHMgdG8uXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIEBwYXJhbSBzeW1ib2wgVGhlIHN5bWJvbCBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIEBwYXJhbSBzdGF0dXMgVGhlIGluaXRpYWwgc3RhdHVzIG9mIHRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogQHBhcmFtIG9uRmlsdGVyIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIGZpbHRlciBidXR0b24gaXMgY2xpY2tlZC4gUGFzc2VzIHRoZSB0eXBlIG9mIHRoZSBmaWx0ZXIgYnV0dG9uIGFuZCB0aGUgc3RhdHVzIG9mIHRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgZmlsdGVyIGJ1dHRvbiBhcyBgRG9jdW1lbnRGcmFnbWVudGAuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBmaWx0ZXIgYnV0dG9uIGNvbnNpc3RzIG9mIGEgZmlsdGVyIGJ1dHRvbiBjb250YWluZXIgYW5kIGEgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIC0gQ1NTIGNsYXNzZXM6XHJcbiAgICAgKiAtIGBmaWx0ZXItc3ltYm9sYCAtIFRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogLSBgZmlsdGVyLXN5bWJvbC1oaWRlYCAtIEFkZGl0aW9uYWwgY2xhc3MgZm9yIHRoZSBmaWx0ZXIgYnV0dG9uIHRvIGhpZGUgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlKFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIHR5cGU6IHN0cmluZyxcclxuICAgICAgICBzeW1ib2w6IHN0cmluZyxcclxuICAgICAgICBzdGF0dXM6IGJvb2xlYW4sXHJcbiAgICAgICAgb25GaWx0ZXI6IEZpbHRlckNhbGxiYWNrKTogRG9jdW1lbnRGcmFnbWVudCB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVySXRlbUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmlsdGVyQnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaGVhZGVySXRlbUNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWx0ZXJCdXR0b25Db250YWluZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBGaWx0ZXJCdXR0b24uY3JlYXRlRmlsdGVyQnV0dG9uKHN0YXR1cywgdHlwZSwgc3ltYm9sLCBjb21wb25lbnQsIG9uRmlsdGVyKTtcclxuICAgICAgICBmaWx0ZXJCdXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhlYWRlckl0ZW1Db250YWluZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgaW5pdGlhbCBzdGF0dXMgb2YgdGhlIGZpbHRlciBidXR0b24uXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIEBwYXJhbSBzeW1ib2wgVGhlIHN5bWJvbCBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZWdpc3RlciB0aGUgZXZlbnRzIHRvLlxyXG4gICAgICogQHBhcmFtIGZpbHRlckNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIGZpbHRlciBidXR0b24gaXMgY2xpY2tlZC4gUGFzc2VzIHRoZSB0eXBlIG9mIHRoZSBmaWx0ZXIgYnV0dG9uIGFuZCB0aGUgc3RhdHVzIG9mIHRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgZmlsdGVyIGJ1dHRvbiBhcyBgRG9jdW1lbnRGcmFnbWVudGAuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBmaWx0ZXIgYnV0dG9uIGlzIGEgYEhUTUxBbmNob3JFbGVtZW50YC5cclxuICAgICAqIC0gQ1NTIGNsYXNzZXM6XHJcbiAgICAgKiAtIGBmaWx0ZXItc3ltYm9sYCAtIFRoZSBmaWx0ZXIgYnV0dG9uLlxyXG4gICAgICogLSBgZmlsdGVyLXN5bWJvbC1oaWRlYCAtIEFkZGl0aW9uYWwgY2xhc3MgZm9yIHRoZSBmaWx0ZXIgYnV0dG9uIHRvIGhpZGUgaXQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUZpbHRlckJ1dHRvbihcclxuICAgICAgICBzdGF0dXM6IGJvb2xlYW4sXHJcbiAgICAgICAgdHlwZTogc3RyaW5nLFxyXG4gICAgICAgIHN5bWJvbDogc3RyaW5nLFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIGZpbHRlckNhbGxiYWNrOiBGaWx0ZXJDYWxsYmFjayk6IERvY3VtZW50RnJhZ21lbnQge1xyXG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmxvZ2dlcjtcclxuICAgICAgICBjb25zdCBmaWx0ZXJCdXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBmaWx0ZXJCdXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcclxuICAgICAgICBmaWx0ZXIuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLXN5bWJvbCcpO1xyXG4gICAgICAgIGlmICghc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGZpbHRlci5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItc3ltYm9sLWhpZGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyLnRpdGxlID0gTG5nLmd0KHR5cGUpO1xyXG4gICAgICAgIGZpbHRlci5ocmVmID0gXCIjXCI7XHJcbiAgICAgICAgc2V0SWNvbihmaWx0ZXIsIHN5bWJvbCk7XHJcblxyXG4gICAgICAgIGNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KGZpbHRlciwgJ2NsaWNrJywgYXN5bmMgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGZpbHRlci5jbGFzc0xpc3QudG9nZ2xlKCdmaWx0ZXItc3ltYm9sLWhpZGUnKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGZpbHRlckNhbGxiYWNrKHR5cGUsIGZpbHRlci5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbHRlci1zeW1ib2wtaGlkZScpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIlRoZSBgb25GaWx0ZXJgIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yIVwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckJ1dHRvbkNvbnRhaW5lcjtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZmlsdGVyIGJ1dHRvbiBpcyBjbGlja2VkLlxyXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBmaWx0ZXIgYnV0dG9uLiBgdHJ1ZWAgaWYgdGhlIGZpbHRlciBidXR0b24gaXMgYWN0aXZlLCBgZmFsc2VgIGlmIG5vdC5cclxuICogQHJlbWFya3MgLSBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGZpbHRlciBidXR0b24gaXMgY2xpY2tlZC5cclxuICovXHJcbnR5cGUgRmlsdGVyQ2FsbGJhY2sgPSAodHlwZTogc3RyaW5nLCBzdGF0dXM6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47IiwgImltcG9ydCB7IENvbXBvbmVudCwgc2V0SWNvbiB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgR2xvYmFsIGZyb20gXCJzcmMvY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IExuZyBmcm9tIFwic3JjL2NsYXNzZXMvTG5nXCI7XHJcblxyXG4vKipcclxuICogTWF4IHNob3duIG1vZGVscyBpbnB1dCBjb21wb25lbnQgY2xhc3MgZm9yIGBUYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50YC5cclxuICogXHJcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBjcmVhdGUgYW5kIG1hbmFnZSBhIG1heCBzaG93biBtb2RlbHMgaW5wdXQgY29tcG9uZW50LlxyXG4gKiBJdCBpbmNsdWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzZXR0aW5nIHVwIHRoZSBtYXggc2hvd24gbW9kZWxzIGlucHV0IGFuZCBoYW5kbGluZyBpbnB1dCBldmVudHMuXHJcbiAqIFxyXG4gKiBAc2VlIHtAbGluayBjcmVhdGV9IGZvciBkZXRhaWxzIGFib3V0IGNyZWF0aW5nIGEgbWF4IHNob3duIG1vZGVscyBpbnB1dCBjb21wb25lbnQuXHJcbiAqIEBzZWUge0BsaW5rIE1heFNob3duTW9kZWxzQ2FsbGJhY2t9IGZvciBkZXRhaWxzIGFib3V0IHRoZSBtYXggc2hvd24gbW9kZWxzIGNhbGxiYWNrLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF4U2hvd25Nb2RlbHNJbnB1dCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1heCBzaG93biBtb2RlbHMgaW5wdXQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudHMgdG8uXHJcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlci5cclxuICAgICAqIEBwYXJhbSBiYXRjaFNpemUgVGhlIGJhdGNoIHNpemUgdG8gYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyIGNoYW5nZXMuIFBhc3NlcyB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuIFlvdSBjYW4gcmV0dXJuIGEgbmV3IG1heCBzaG93biBtb2RlbHMgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbWF4IHNob3duIG1vZGVscyBpbnB1dCBjb21wb25lbnQgYXMgYERvY3VtZW50RnJhZ21lbnRgLlxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgbWF4IHNob3duIG1vZGVscyBpbnB1dCBjb21wb25lbnQgY29uc2lzdHMgb2YgYSBjb250YWluZXIsIGEgbWludXMgc3ltYm9sLCBhIHByZXNlbnRhdGlvbiBzcGFuIGFuZCBhIHBsdXMgc3ltYm9sLlxyXG4gICAgICogLSBDU1MgY2xhc3NlczpcclxuICAgICAqIC0gYGZpbHRlci1tYXgtbW9kZWxzYCAtIFRoZSBjb250YWluZXIgb2YgdGhlIG1heCBzaG93biBtb2RlbHMgaW5wdXQgY29tcG9uZW50LlxyXG4gICAgICogLSBgZmlsdGVyLW1heC1udW1iZXJgIC0gVGhlIHByZXNlbnRhdGlvbiBzcGFuIG9mIHRoZSBtYXggc2hvd24gbW9kZWxzIGlucHV0IGNvbXBvbmVudC5cclxuICAgICAqIC0gYG1pbnVzLWJhdGNoLWJ1dHRvbmAgLSBUaGUgbWludXMgc3ltYm9sIG9mIHRoZSBtYXggc2hvd24gbW9kZWxzIGlucHV0IGNvbXBvbmVudC5cclxuICAgICAqIC0gYHBsdXMtYmF0Y2gtYnV0dG9uYCAtIFRoZSBwbHVzIHN5bWJvbCBvZiB0aGUgbWF4IHNob3duIG1vZGVscyBpbnB1dCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlKGNvbXBvbmVudDogQ29tcG9uZW50LCBkZWZhdWx0VmFsdWU6IG51bWJlciwgYmF0Y2hTaXplOiBudW1iZXIsIG9uQ2hhbmdlOiBNYXhTaG93bk1vZGVsc0NhbGxiYWNrKTogRG9jdW1lbnRGcmFnbWVudCB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVySXRlbUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBjb25zdCBsb2dnZXIgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5sb2dnZXI7XHJcbiAgICAgICAgbGV0IGRlYm91bmNlVGltZXI6IE5vZGVKUy5UaW1lb3V0O1xyXG5cclxuICAgICAgICBjb25zdCBtYXhTaG93bk1vZGVsczogTWF4U2hvd25Nb2RlbE51bWJlciA9IHtcclxuICAgICAgICAgICAgbWF4U2hvd25Nb2RlbHM6ICFpc05hTihwYXJzZUZsb2F0KGRlZmF1bHRWYWx1ZSBhcyB1bmtub3duIGFzIHN0cmluZykpICYmIGlzRmluaXRlKGRlZmF1bHRWYWx1ZSkgPyBOdW1iZXIoZGVmYXVsdFZhbHVlKSA6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBmaWx0ZXJNYXhNb2RlbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBoZWFkZXJJdGVtQ29udGFpbmVyLmFwcGVuZENoaWxkKGZpbHRlck1heE1vZGVsc0NvbnRhaW5lcik7XHJcbiAgICAgICAgZmlsdGVyTWF4TW9kZWxzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1tYXgtbW9kZWxzJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMuY3JlYXRlTnVtYmVyUHJlc2VudGF0aW9uKG1heFNob3duTW9kZWxzLCBjb21wb25lbnQsIGJhdGNoU2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlYm91bmNlT25DaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcclxuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhTaG93bk1vZGVscy5tYXhTaG93bk1vZGVscyA9IChhd2FpdCBvbkNoYW5nZShtYXhTaG93bk1vZGVscy5tYXhTaG93bk1vZGVscykpID8/IG1heFNob3duTW9kZWxzLm1heFNob3duTW9kZWxzO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJUaGUgYG9uQ2hhbmdlYCBjYWxsYmFjayB0aHJldyBhbiBlcnJvciFcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXIubnVtYmVyLnRleHRDb250ZW50ID0gbWF4U2hvd25Nb2RlbHMubWF4U2hvd25Nb2RlbHMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBNYXhTaG93bk1vZGVsc0lucHV0LmNyZWF0ZU51bWJlclByZXNlbnRhdGlvbkV2ZW50KFxyXG4gICAgICAgICAgICBjb21wb25lbnQsXHJcbiAgICAgICAgICAgIG51bWJlci5udW1iZXIsXHJcbiAgICAgICAgICAgIG1heFNob3duTW9kZWxzLFxyXG4gICAgICAgICAgICBiYXRjaFNpemUsXHJcbiAgICAgICAgICAgIGRlYm91bmNlT25DaGFuZ2UpO1xyXG5cclxuICAgICAgICBjb25zdCBtaW51cyA9IHRoaXMuY3JlYXRlU3ltYm9sKFxyXG4gICAgICAgICAgICBcIm1pbnVzXCIsXHJcbiAgICAgICAgICAgIG51bWJlci5udW1iZXIsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudCxcclxuICAgICAgICAgICAgbWF4U2hvd25Nb2RlbHMsXHJcbiAgICAgICAgICAgIGJhdGNoU2l6ZSxcclxuICAgICAgICAgICAgZGVib3VuY2VPbkNoYW5nZSk7XHJcbiAgICAgICAgY29uc3QgcGx1cyA9IHRoaXMuY3JlYXRlU3ltYm9sKFxyXG4gICAgICAgICAgICBcInBsdXNcIixcclxuICAgICAgICAgICAgbnVtYmVyLm51bWJlcixcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBtYXhTaG93bk1vZGVscyxcclxuICAgICAgICAgICAgYmF0Y2hTaXplLFxyXG4gICAgICAgICAgICBkZWJvdW5jZU9uQ2hhbmdlKTtcclxuXHJcbiAgICAgICAgZmlsdGVyTWF4TW9kZWxzQ29udGFpbmVyLmFwcGVuZENoaWxkKG1pbnVzKTtcclxuICAgICAgICBmaWx0ZXJNYXhNb2RlbHNDb250YWluZXIuYXBwZW5kQ2hpbGQobnVtYmVyLmNvbnRhaW5lcik7XHJcbiAgICAgICAgZmlsdGVyTWF4TW9kZWxzQ29udGFpbmVyLmFwcGVuZENoaWxkKHBsdXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gaGVhZGVySXRlbUNvbnRhaW5lcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgcHJlc2VudGF0aW9uIHNwYW4gZm9yIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlci5cclxuICAgICAqIEBwYXJhbSBtYXhTaG93bk1vZGVscyBUaGUgY29udGFpbmVyIGZvciB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjcmVhdGVkIHByZXNlbnRhdGlvbiBzcGFuIGFzIGBEb2N1bWVudEZyYWdtZW50YFxyXG4gICAgICogLSBUaGUgY3JlYXRlZCBwcmVzZW50YXRpb24gc3BhbiBhcyBgSFRNTFNwYW5FbGVtZW50YFxyXG4gICAgICogLSBUaGUgc3BhbiBlbGVtZW50IGhhcyB0aGUgY2xhc3MgYGZpbHRlci1tYXgtbnVtYmVyYC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlTnVtYmVyUHJlc2VudGF0aW9uKFxyXG4gICAgICAgIG1heFNob3duTW9kZWxzOiBNYXhTaG93bk1vZGVsTnVtYmVyLFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIGJhdGNoU2l6ZTogbnVtYmVyKTogeyBjb250YWluZXI6IERvY3VtZW50RnJhZ21lbnQsIG51bWJlcjogSFRNTFNwYW5FbGVtZW50IH0ge1xyXG4gICAgICAgIGNvbnN0IGZpbHRlck1heE1vZGVsc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4U2hvd25OdW1iZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgZmlsdGVyTWF4TW9kZWxzQ29udGFpbmVyLmFwcGVuZENoaWxkKG1heFNob3duTnVtYmVyKTtcclxuICAgICAgICBtYXhTaG93bk51bWJlci5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItbWF4LW51bWJlcicpO1xyXG4gICAgICAgIG1heFNob3duTnVtYmVyLnRpdGxlID0gTG5nLmd0KFwiTWF4U2hvd25FbnRyeXNcIik7XHJcbiAgICAgICAgbWF4U2hvd25OdW1iZXIudGV4dENvbnRlbnQgPSBtYXhTaG93bk1vZGVscy5tYXhTaG93bk1vZGVscy50b1N0cmluZygpO1xyXG5cclxuICAgICAgICByZXR1cm4geyBjb250YWluZXI6IGZpbHRlck1heE1vZGVsc0NvbnRhaW5lciwgbnVtYmVyOiBtYXhTaG93bk51bWJlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbW91c2Ugd2hlZWwgZXZlbnRzIGZvciB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIgcHJlc2VudGF0aW9uIHNwYW4uXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXIgdGhlIGV2ZW50cyB0by5cclxuICAgICAqIEBwYXJhbSBtYXhTaG93bk51bWJlciBUaGUgcHJlc2VudGF0aW9uIHNwYW4gb2YgdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIG1heFNob3duTW9kZWxzIFRoZSBjb250YWluZXIgZm9yIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlci5cclxuICAgICAqIEBwYXJhbSBiYXRjaFNpemUgVGhlIGJhdGNoIHNpemUgdG8gYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICogQHBhcmFtIG9uTWF4U2hvd25Nb2RlbHNDaGFuZ2UgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlTnVtYmVyUHJlc2VudGF0aW9uRXZlbnQoY29tcG9uZW50OiBDb21wb25lbnQsIG1heFNob3duTnVtYmVyOiBIVE1MU3BhbkVsZW1lbnQsIG1heFNob3duTW9kZWxzOiBNYXhTaG93bk1vZGVsTnVtYmVyLCBiYXRjaFNpemU6IG51bWJlciwgb25NYXhTaG93bk1vZGVsc0NoYW5nZTogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIGNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KG1heFNob3duTnVtYmVyLCAnd2hlZWwnLCBhc3luYyAoZXZlbnQ6IFdoZWVsRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWUoXCJtaW51c1wiLCBtYXhTaG93bk1vZGVscywgYmF0Y2hTaXplLCBtYXhTaG93bk51bWJlciwgb25NYXhTaG93bk1vZGVsc0NoYW5nZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlKFwicGx1c1wiLCBtYXhTaG93bk1vZGVscywgYmF0Y2hTaXplLCBtYXhTaG93bk51bWJlciwgb25NYXhTaG93bk1vZGVsc0NoYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHN5bWJvbCBmb3IgdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIHN5bWJvbC4gQ2FuIGJlIGBwbHVzYCBvciBgbWludXNgLlxyXG4gICAgICogQHBhcmFtIG1heFNob3duTnVtYmVyIFRoZSBwcmVzZW50YXRpb24gc3BhbiBvZiB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXIgdGhlIGV2ZW50cyB0by5cclxuICAgICAqIEBwYXJhbSBtYXhTaG93bk1vZGVscyBUaGUgY29udGFpbmVyIGZvciB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gYmF0Y2hTaXplIFRoZSBiYXRjaCBzaXplIHRvIGFkZCBvciBzdWJ0cmFjdC5cclxuICAgICAqIEBwYXJhbSBvbk1heFNob3duTW9kZWxzQ2hhbmdlIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyIGNoYW5nZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzeW1ib2wgYXMgYERvY3VtZW50RnJhZ21lbnRgLlxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgc3ltYm9sIGlzIGEgYEhUTUxBbmNob3JFbGVtZW50YC5cclxuICAgICAqIC0gVGhlIHN5bWJvbCBoYXMgdGhlIGNsYXNzIGBwbHVzLWJhdGNoLWJ1dHRvbmAgb3IgYG1pbnVzLWJhdGNoLWJ1dHRvbmAuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZVN5bWJvbChcclxuICAgICAgICB0eXBlOiBcInBsdXNcIiB8IFwibWludXNcIixcclxuICAgICAgICBtYXhTaG93bk51bWJlcjogSFRNTFNwYW5FbGVtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIG1heFNob3duTW9kZWxzOiBNYXhTaG93bk1vZGVsTnVtYmVyLFxyXG4gICAgICAgIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG4gICAgICAgIG9uTWF4U2hvd25Nb2RlbHNDaGFuZ2U6ICgpID0+IHZvaWQpOiBEb2N1bWVudEZyYWdtZW50IHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJNYXhNb2RlbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1heFNob3duRG9jTWludXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgZmlsdGVyTWF4TW9kZWxzQ29udGFpbmVyLmFwcGVuZENoaWxkKG1heFNob3duRG9jTWludXMpO1xyXG4gICAgICAgIG1heFNob3duRG9jTWludXMuY2xhc3NMaXN0LmFkZChgJHt0eXBlfS1iYXRjaC1idXR0b25gKTtcclxuICAgICAgICBtYXhTaG93bkRvY01pbnVzLnRpdGxlID0gdHlwZTtcclxuICAgICAgICBtYXhTaG93bkRvY01pbnVzLmhyZWYgPSBcIiNcIjtcclxuICAgICAgICBzZXRJY29uKG1heFNob3duRG9jTWludXMsIHR5cGUpO1xyXG5cclxuICAgICAgICBjb21wb25lbnQucmVnaXN0ZXJEb21FdmVudChtYXhTaG93bkRvY01pbnVzLCAnY2xpY2snLCBhc3luYyAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh0eXBlLCBtYXhTaG93bk1vZGVscywgYmF0Y2hTaXplLCBtYXhTaG93bk51bWJlciwgb25NYXhTaG93bk1vZGVsc0NoYW5nZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlck1heE1vZGVsc0NvbnRhaW5lcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIHN5bWJvbC4gQ2FuIGJlIGBwbHVzYCBvciBgbWludXNgLlxyXG4gICAgICogQHBhcmFtIG1heFNob3duTW9kZWxzIFRoZSBjb250YWluZXIgZm9yIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlci5cclxuICAgICAqIEBwYXJhbSBiYXRjaFNpemUgVGhlIGJhdGNoIHNpemUgdG8gYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICogQHBhcmFtIG1heFNob3duTnVtYmVyIFRoZSBwcmVzZW50YXRpb24gc3BhbiBvZiB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gb25NYXhTaG93bk1vZGVsc0NoYW5nZSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlciBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjaGFuZ2VWYWx1ZSh0eXBlOiBzdHJpbmcsIG1heFNob3duTW9kZWxzOiBNYXhTaG93bk1vZGVsTnVtYmVyLCBiYXRjaFNpemU6IG51bWJlciwgbWF4U2hvd25OdW1iZXI6IEhUTUxTcGFuRWxlbWVudCwgb25NYXhTaG93bk1vZGVsc0NoYW5nZTogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBcIm1pbnVzXCIpIHtcclxuICAgICAgICAgICAgaWYgKG1heFNob3duTW9kZWxzLm1heFNob3duTW9kZWxzID49IGJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3RzIGVpdGhlciB0aGUgcmVtYWluZGVyICh0byBhcnJpdmUgYXQgdGhlIG5leHQgbXVsdGlwbGUgb2YgYGJhdGNoU2l6ZWApIG9yIGBiYXRjaFNpemVgIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgbWF4U2hvd25Nb2RlbHMubWF4U2hvd25Nb2RlbHMgLT0gKG1heFNob3duTW9kZWxzLm1heFNob3duTW9kZWxzICUgYmF0Y2hTaXplKSB8fCBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXhTaG93bk1vZGVscy5tYXhTaG93bk1vZGVscyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBZGRzIGVpdGhlciB0aGUgcmVtYWluZGVyICh0byBhcnJpdmUgYXQgdGhlIG5leHQgbXVsdGlwbGUgb2YgYGJhdGNoU2l6ZWApIG9yIGBiYXRjaFNpemVgIGl0c2VsZlxyXG4gICAgICAgICAgICBtYXhTaG93bk1vZGVscy5tYXhTaG93bk1vZGVscyArPSBiYXRjaFNpemUgLSAobWF4U2hvd25Nb2RlbHMubWF4U2hvd25Nb2RlbHMgJSBiYXRjaFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXhTaG93bk51bWJlci50ZXh0Q29udGVudCA9IG1heFNob3duTW9kZWxzLm1heFNob3duTW9kZWxzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgb25NYXhTaG93bk1vZGVsc0NoYW5nZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGNhbGxiYWNrIGZvciBhIGNoYW5nZSBvZiB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgY3VycmVudCBtYXggc2hvd24gbW9kZWxzIG51bWJlci5cclxuICogQHJldHVybnMgLSBUaGUgbmV3IG1heCBzaG93biBtb2RlbHMgbnVtYmVyLlxyXG4gKiAtIElmIHlvdSByZXR1cm4gYHVuZGVmaW5lZGAgdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyIGlzIG5vdCBjaGFuZ2VkLlxyXG4gKiBAcmVtYXJrcyBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1heCBzaG93biBtb2RlbHMgbnVtYmVyIGlzIGNoYW5nZWQuXHJcbiAqL1xyXG50eXBlIE1heFNob3duTW9kZWxzQ2FsbGJhY2sgPSAodmFsdWU6IG51bWJlcikgPT4gUHJvbWlzZTxudW1iZXIgfCB1bmRlZmluZWQ+O1xyXG5cclxuLyoqXHJcbiAqIEEgY29udGFpbmVyIGZvciB0aGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAqIEBwYXJhbSBtYXhTaG93bk1vZGVscyBUaGUgbWF4IHNob3duIG1vZGVscyBudW1iZXIuXHJcbiAqIEByZW1hcmtzIFRoZSBjb250YWluZXIgaXMgdXNlZCB0byBwYXNzIHRoZSBtYXggc2hvd24gbW9kZWxzIG51bWJlciBieSByZWZlcmVuY2UuXHJcbiAqL1xyXG50eXBlIE1heFNob3duTW9kZWxOdW1iZXIgPSB7IG1heFNob3duTW9kZWxzOiBudW1iZXIgfSIsICJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwic3JjL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCBMbmcgZnJvbSBcInNyYy9jbGFzc2VzL0xuZ1wiO1xyXG5cclxuLyoqXHJcbiAqIFNlYXJjaCBpbnB1dCBjb21wb25lbnQgY2xhc3MgZm9yIGBUYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50YC5cclxuICpcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIGEgc2VhcmNoIGlucHV0IGNvbXBvbmVudC5cclxuICogSXQgaW5jbHVkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2V0dGluZyB1cCB0aGUgc2VhcmNoIGJveCBhbmQgaGFuZGxpbmcgaW5wdXQgZXZlbnRzLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBjcmVhdGV9IGZvciBkZXRhaWxzIGFib3V0IGNyZWF0aW5nIGEgc2VhcmNoIGlucHV0IGNvbXBvbmVudC5cclxuICogQHNlZSB7QGxpbmsgU2VhcmNoQ2FsbGJhY2t9IGZvciBkZXRhaWxzIGFib3V0IHRoZSBzZWFyY2ggY2FsbGJhY2suXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnB1dCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2VhcmNoIGlucHV0IGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZWdpc3RlciB0aGUgZXZlbnRzIHRvLlxyXG4gICAgICogQHBhcmFtIG9uU2VhcmNoIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIHNlYXJjaCBib3ggdmFsdWUgY2hhbmdlcy4gUGFzc2VzIHRoZSBzZWFyY2ggYm94IHZhbHVlIGFuZCB0aGUga2V5IHRoYXQgd2FzIHByZXNzZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzZWFyY2ggaW5wdXQgY29tcG9uZW50IGFzIGBEb2N1bWVudEZyYWdtZW50YC5cclxuICAgICAqIEByZW1hcmtzIC0gVGhlIHNlYXJjaCBpbnB1dCBjb21wb25lbnQgY29uc2lzdHMgb2YgYSBsYWJlbCwgYW4gaW5wdXQgc2l6ZXIgYW5kIGEgc2VhcmNoIGJveC5cclxuICAgICAqIC0gQ1NTIGNsYXNzZXM6XHJcbiAgICAgKiAgLSBgZmlsdGVyLXNlYXJjaGAgLSBUaGUgY29udGFpbmVyIG9mIHRoZSBzZWFyY2ggaW5wdXQgY29tcG9uZW50LlxyXG4gICAgICogIC0gYGZpbHRlci10ZXh0YCAtIFRoZSBsYWJlbCBvZiB0aGUgc2VhcmNoIGlucHV0IGNvbXBvbmVudC5cclxuICAgICAqICAtIGBzZWFyY2gtYm94LXNpemVyYCAtIFRoZSBzaXplciBvZiB0aGUgc2VhcmNoIGlucHV0IGNvbXBvbmVudC5cclxuICAgICAqICAtIGBzZWFyY2gtYm94YCAtIFRoZSBzZWFyY2ggYm94IG9mIHRoZSBzZWFyY2ggaW5wdXQgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZShjb21wb25lbnQ6IENvbXBvbmVudCwgb25TZWFyY2g6IFNlYXJjaENhbGxiYWNrKTogRG9jdW1lbnRGcmFnbWVudCB7XHJcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckl0ZW1Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlYXJjaExhYmVsQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaGVhZGVySXRlbUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWFyY2hMYWJlbENvbnRhaW5lcik7XHJcbiAgICAgICAgc2VhcmNoTGFiZWxDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLXNlYXJjaCcpO1xyXG5cclxuICAgICAgICBTZWFyY2hJbnB1dC5jcmVhdGVTZWFyY2hMYWJlbChzZWFyY2hMYWJlbENvbnRhaW5lcik7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94U2l6ZXIgPSBTZWFyY2hJbnB1dC5jcmVhdGVTZWFyY2hCb3hTaXplcihzZWFyY2hMYWJlbENvbnRhaW5lcik7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94SW5wdXQgPSBTZWFyY2hJbnB1dC5jcmVhdGVTZWFyY2hCb3hJbnB1dChzZWFyY2hCb3hTaXplcik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVyIGlucHV0IGV2ZW50IHRvIHNldCB0aGUgc2VhcmNoIGJveCBzaXplciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb21wb25lbnQucmVnaXN0ZXJEb21FdmVudChzZWFyY2hCb3hJbnB1dCwgJ2lucHV0JywgYXN5bmMgKGV2ZW50OiBJbnB1dEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2VhcmNoQm94U2l6ZXJWYWx1ZShzZWFyY2hCb3hTaXplciwgc2VhcmNoQm94SW5wdXQudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlciBrZXlkb3duIGV2ZW50IHRvIGNhbGwgdGhlIHNlYXJjaCBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcmVtYXJrcyAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIGlzIHVzZWQgdG8gc2V0IHRoZSBzZWFyY2ggYm94IHZhbHVlIGFuZCB0aGUgc2VhcmNoIGJveCBzaXplciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb21wb25lbnQucmVnaXN0ZXJEb21FdmVudChzZWFyY2hCb3hJbnB1dCwgJ2tleWRvd24nLCBhc3luYyAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gc2VhcmNoQm94SW5wdXQudmFsdWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IG9uU2VhcmNoKHNlYXJjaEJveElucHV0LnZhbHVlLCBldmVudC5rZXkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiVGhlIGBvblNlYXJjaGAgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IhXCIsIGVycm9yKTtcclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VhcmNoQm94U2l6ZXJWYWx1ZShzZWFyY2hCb3hTaXplciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2hCb3hJbnB1dFZhbHVlKHNlYXJjaEJveElucHV0LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhlYWRlckl0ZW1Db250YWluZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBzZWFyY2ggbGFiZWwuXHJcbiAgICAgKiBAcGFyYW0gc2VhcmNoTGFiZWxDb250YWluZXIgVGhlIGNvbnRhaW5lciB0byBhcHBlbmQgdGhlIGxhYmVsIHRvLiBcclxuICAgICAqIEByZW1hcmtzIC0gVGhlIGxhYmVsIGlzIGEgYEhUTUxTcGFuRWxlbWVudGAuXHJcbiAgICAgKiAtIFRoZSBsYWJlbCB0ZXh0IGlzIGBTZWFyY2hgLXZhbHVlIG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIC0gVGhlIGxhYmVsIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBgZmlsdGVyLXRleHRgLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVTZWFyY2hMYWJlbChzZWFyY2hMYWJlbENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICBzZWFyY2hMYWJlbENvbnRhaW5lci5hcHBlbmRDaGlsZChmaWx0ZXJMYWJlbCk7XHJcbiAgICAgICAgZmlsdGVyTGFiZWwuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLXRleHQnKTtcclxuICAgICAgICBmaWx0ZXJMYWJlbC50ZXh0Q29udGVudCA9IExuZy5ndChcIlNlYXJjaFwiKSArIFwiOlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgc2VhcmNoIGJveCBzaXplci5cclxuICAgICAqIEBwYXJhbSBzZWFyY2hMYWJlbENvbnRhaW5lciBUaGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgc2l6ZXIgdG8uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzZWFyY2ggYm94IHNpemVyLlxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgc2l6ZXIgaXMgYSBgSFRNTExhYmVsRWxlbWVudGAuXHJcbiAgICAgKiAtIFRoZSBzaXplciBoYXMgdGhlIGNsYXNzIGBzZWFyY2gtYm94LXNpemVyYC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlU2VhcmNoQm94U2l6ZXIoc2VhcmNoTGFiZWxDb250YWluZXI6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94U2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xyXG4gICAgICAgIHNlYXJjaExhYmVsQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlYXJjaEJveFNpemVyKTtcclxuICAgICAgICBzZWFyY2hCb3hTaXplci5jbGFzc0xpc3QuYWRkKCdzZWFyY2gtYm94LXNpemVyJyk7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaEJveFNpemVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgc2VhcmNoIGJveCBpbnB1dC5cclxuICAgICAqIEBwYXJhbSBzZWFyY2hCb3hTaXplciBUaGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgaW5wdXQgdG8uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzZWFyY2ggYm94IGlucHV0LlxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgaW5wdXQgaXMgYSBgSFRNTElucHV0RWxlbWVudGAuXHJcbiAgICAgKiAtIFRoZSBpbnB1dCB0eXBlIGlzIGB0ZXh0YC5cclxuICAgICAqIC0gVGhlIGlucHV0IHBsYWNlaG9sZGVyIGlzIGBTZWFyY2hgLXZhbHVlIG9mIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIC0gVGhlIGlucHV0IGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBgc2VhcmNoLWJveGAuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZVNlYXJjaEJveElucHV0KHNlYXJjaEJveFNpemVyOiBIVE1MTGFiZWxFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIHNlYXJjaEJveFNpemVyLmFwcGVuZENoaWxkKHNlYXJjaEJveElucHV0KTtcclxuICAgICAgICBzZWFyY2hCb3hJbnB1dC5jbGFzc0xpc3QuYWRkKCdzZWFyY2gtYm94Jyk7XHJcbiAgICAgICAgc2VhcmNoQm94SW5wdXQudHlwZSA9IFwidGV4dFwiO1xyXG4gICAgICAgIHNlYXJjaEJveElucHV0LnBsYWNlaG9sZGVyID0gTG5nLmd0KFwiU2VhcmNoXCIpO1xyXG4gICAgICAgIHNlYXJjaEJveElucHV0LnZhbHVlID0gXCJcIjtcclxuICAgICAgICByZXR1cm4gc2VhcmNoQm94SW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzZWFyY2ggYm94IHNpemVyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHNlYXJjaEJveFNpemVyIFRoZSBzZWFyY2ggYm94IHNpemVyIHRvIHNldCB0aGUgdmFsdWUgdG8uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0U2VhcmNoQm94U2l6ZXJWYWx1ZShzZWFyY2hCb3hTaXplcjogSFRNTEVsZW1lbnQsIHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBzZWFyY2hCb3hTaXplci5kYXRhc2V0LnZhbHVlID0gXCJfXCIgKyB2YWx1ZSArIFwiX1wiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2VhcmNoIGJveCBpbnB1dCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSBzZWFyY2hCb3hJbnB1dCBUaGUgc2VhcmNoIGJveCBpbnB1dCB0byBzZXQgdGhlIHZhbHVlIHRvLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldFNlYXJjaEJveElucHV0VmFsdWUoc2VhcmNoQm94SW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBzZWFyY2hCb3hJbnB1dC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHNlYXJjaCBjYWxsYmFjay5cclxuICogQHBhcmFtIHNlYXJjaGJveFZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgc2VhcmNoIGJveC5cclxuICogQHBhcmFtIGV2ZW50S2V5IFRoZSBrZXkgdGhhdCB3YXMgcHJlc3NlZC5cclxuICogQHJldHVybnMgVGhlIHZhbHVlIHRvIHNldCB0byB0aGUgc2VhcmNoIGJveCBhbmQgdGhlIHNlYXJjaCBib3ggc2l6ZXIuXHJcbiAqIEByZW1hcmtzIC0gVXNlIHRoZSBgZXZlbnRLZXlgIHRvIGRldGVybWluZSB3aGljaCBrZXkgd2FzIHByZXNzZWQuXHJcbiAqIC0gU3RhcnQgc2VhcmNoIG9uIGBFbnRlcmAga2V5LlxyXG4gKiAtIENsZWFyIHNlYXJjaCBvbiBgRXNjYXBlYCBrZXkuXHJcbiAqL1xyXG50eXBlIFNlYXJjaENhbGxiYWNrID0gKHNlYXJjaGJveFZhbHVlOiBzdHJpbmcsIGV2ZW50S2V5OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPjsiLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBNYXJrZG93blJlbmRlcmVyLCBURmlsZSwgc2V0SWNvbiB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgR2xvYmFsIGZyb20gXCJzcmMvY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IExuZyBmcm9tIFwic3JjL2NsYXNzZXMvTG5nXCI7XHJcbmltcG9ydCBFZGl0YWJsZURhdGFWaWV3IGZyb20gXCJzcmMvbGlicy9FZGl0YWJsZURhdGFWaWV3L0VkaXRhYmxlRGF0YVZpZXdcIjtcclxuaW1wb3J0IEhlbHBlciBmcm9tIFwic3JjL2xpYnMvSGVscGVyXCI7XHJcbmltcG9ydCB7IERvY3VtZW50TW9kZWwgfSBmcm9tIFwic3JjL21vZGVscy9Eb2N1bWVudE1vZGVsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudENvbXBvbmVudHMge1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVDZWxsVGFncyhcclxuICAgICAgICB0YWdDb250YWluZXI6IERvY3VtZW50RnJhZ21lbnQsXHJcbiAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnQsXHJcbiAgICAgICAgdGFnczogc3RyaW5nW10pIHtcclxuICAgICAgICB0YWdzLmZvckVhY2godGFnID0+IHtcclxuICAgICAgICAgICAgbmV3IEVkaXRhYmxlRGF0YVZpZXcodGFnQ29udGFpbmVyLCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICAuYWRkTGluayhsaW5rID0+IGxpbmtcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGFnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZShcIlRhZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW5rVHlwZShcInRhZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRGb3JtYXRvcigodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBocmVmOiBgIyR7dmFsdWV9YCwgdGV4dDogYCMke3ZhbHVlfWAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNlbGxTdW1tYXJ5KFxyXG4gICAgICAgIGRvY3VtZW50TW9kZWw6IERvY3VtZW50TW9kZWwsXHJcbiAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnQsXHJcbiAgICAgICAgc3VtbWFyeVJlbGF0ZWRGaWxlczogRG9jdW1lbnRGcmFnbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZG9jdW1lbnRNb2RlbC5nZXREZXNjcmlwdGlvbigpO1xyXG4gICAgICAgIG5ldyBFZGl0YWJsZURhdGFWaWV3KHN1bW1hcnlSZWxhdGVkRmlsZXMsIGNvbXBvbmVudClcclxuICAgICAgICAgICAgLmFkZFRleHRhcmVhKHRleHRhcmVhID0+IHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUoXCJTdW1tYXJ5XCIpXHJcbiAgICAgICAgICAgICAgICAuZW5hYmxlRWRpdGFiaWxpdHkoKVxyXG4gICAgICAgICAgICAgICAgLnNldFJlbmRlck1hcmtkb3duKClcclxuICAgICAgICAgICAgICAgIC5vblNhdmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1vZGVsLmRhdGEuZGVzY3JpcHRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlUmVsYXRlZEZpbGVzTGlzdChcclxuICAgICAgICByZWxhdGVkRmlsZXNMaXN0OiBEb2N1bWVudEZyYWdtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIGRvY3VtZW50TW9kZWw6IERvY3VtZW50TW9kZWwsXHJcbiAgICAgICAgbm9uZURvY1N5bWJvbDogc3RyaW5nLFxyXG4gICAgICAgIGRhdGVGb3JtYXRTaG9ydDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmVsYXRlZEZpbGVzID0gZG9jdW1lbnRNb2RlbC5yZWxhdGVkRmlsZXM7XHJcbiAgICAgICAgaWYgKCFyZWxhdGVkRmlsZXMgfHwgcmVsYXRlZEZpbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHJlbGF0ZWRGaWxlc0xpc3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncmVsYXRlZC1maWxlcy1jb250YWluZXInKTtcclxuXHJcbiAgICAgICAgY29uc3QgYnJlYWtMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHInKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnJlYWtMaW5lKTtcclxuICAgICAgICBicmVha0xpbmUuY2xhc3NMaXN0LmFkZCgncmVsYXRlZC1maWxlcy1icmVha2xpbmUnKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxpc3QpO1xyXG4gICAgICAgIGxpc3QuY2xhc3NMaXN0LmFkZCgncmVsYXRlZC1maWxlcy1saXN0Jyk7XHJcblxyXG4gICAgICAgIHJlbGF0ZWRGaWxlcy5mb3JFYWNoKHJlbGF0ZWRGaWxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlzdEVudHJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuICAgICAgICAgICAgbGlzdC5hcHBlbmQobGlzdEVudHJ5KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGdyaWRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgbGlzdEVudHJ5LmFwcGVuZENoaWxkKGdyaWRDb250YWluZXIpO1xyXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2dyaWQtY29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpY29uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyLmFwcGVuZChpY29uQ29udGFpbmVyKVxyXG4gICAgICAgICAgICBpY29uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ljb24tY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0T3V0cHV0U3RhdGUgPSByZWxhdGVkRmlsZS5nZXRJbnB1dE91dHB1dFN0YXRlKCk7XHJcbiAgICAgICAgICAgIC8vSW5wdXQsIE91dHB1dCBvciBkZWZhdWx0IGljb25cclxuICAgICAgICAgICAgbGV0IGxpc3RJY29uU3RyaW5nID0gbm9uZURvY1N5bWJvbDtcclxuICAgICAgICAgICAgaWYgKGlucHV0T3V0cHV0U3RhdGUgPT09IFwiSW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgbGlzdEljb25TdHJpbmcgPSBcImNvcm5lci1sZWZ0LWRvd25cIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dE91dHB1dFN0YXRlID09PSBcIk91dHB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0SWNvblN0cmluZyA9IFwiY29ybmVyLXJpZ2h0LXVwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0SWNvbihpY29uQ29udGFpbmVyLCBsaXN0SWNvblN0cmluZyk7XHJcblxyXG4gICAgICAgICAgICAvL01ldGFkYXRhIEZpbGUgTGlua1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lci5hcHBlbmQobWV0YWRhdGFDb250YWluZXIpXHJcbiAgICAgICAgICAgIG1ldGFkYXRhQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21ldGFkYXRhLWZpbGUtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2VsbE1ldGFkYXRhbGluayhtZXRhZGF0YUZyYWdtZW50LCBjb21wb25lbnQsIHJlbGF0ZWRGaWxlKTtcclxuICAgICAgICAgICAgbWV0YWRhdGFDb250YWluZXIuYXBwZW5kQ2hpbGQobWV0YWRhdGFGcmFnbWVudCk7XHJcblxyXG4gICAgICAgICAgICAvL0RhdGVcclxuICAgICAgICAgICAgY29uc3QgZGF0ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lci5hcHBlbmQoZGF0ZUNvbnRhaW5lcilcclxuICAgICAgICAgICAgZGF0ZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkYXRlLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICBuZXcgRWRpdGFibGVEYXRhVmlldyhkYXRlQ29udGFpbmVyLCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICAuYWRkRGF0ZShkYXRlID0+IGRhdGVcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUocmVsYXRlZEZpbGUuZGF0YS5kYXRlID8/IFwibmFcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoXCJEb2N1bWVudCBEYXRlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEZvcm1hdG9yKCh2YWx1ZTogc3RyaW5nKSA9PiBIZWxwZXIuZm9ybWF0RGF0ZSh2YWx1ZSwgSGVscGVyLmZvcm1hdERhdGUodmFsdWUsIGRhdGVGb3JtYXRTaG9ydCkpXHJcbiAgICAgICAgICAgICAgICAgICAgKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyLmFwcGVuZCh0ZXh0Q29udGFpbmVyKVxyXG4gICAgICAgICAgICB0ZXh0Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2RhdGEtY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgLy9UaXRsZSBhbmQgTGlua1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNlbGxGaWxlTGluayhsaW5rRnJhZ21lbnQsIGNvbXBvbmVudCwgcmVsYXRlZEZpbGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGV4dENvbnRhaW5lci5hcHBlbmQobGlua0ZyYWdtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNlbGxTZW5kZXJSZWNpcGllbnQoXHJcbiAgICAgICAgZG9jdW1lbnRNb2RlbDogRG9jdW1lbnRNb2RlbCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBtb2RlbHM6IERvY3VtZW50TW9kZWxbXSk6IERvY3VtZW50RnJhZ21lbnQge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlclJlY2lwaWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBzZW5kZXJSZWNpcGllbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2VuZGVyUmVjaXBpZW50Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlucHV0T3V0cHV0U3RhdGUgPSBkb2N1bWVudE1vZGVsLmdldElucHV0T3V0cHV0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCBzZW5kZXIgPSBkb2N1bWVudE1vZGVsLmRhdGEuc2VuZGVyID8/IG51bGw7XHJcbiAgICAgICAgY29uc3QgcmVjaXBpZW50ID0gZG9jdW1lbnRNb2RlbC5kYXRhLnJlY2lwaWVudCA/PyBudWxsO1xyXG5cclxuICAgICAgICBpZiAoc2VuZGVyICYmIGlucHV0T3V0cHV0U3RhdGUgIT09IFwiT3V0cHV0XCIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VuZGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNlbmRlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb250YWluZXInKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21UbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgZnJvbVRvLmNsYXNzTGlzdC5hZGQoJ2Zyb21UbycpO1xyXG4gICAgICAgICAgICBmcm9tVG8udGV4dENvbnRlbnQgPSBMbmcuZ3QoXCJGcm9tXCIpO1xyXG4gICAgICAgICAgICBzZW5kZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJvbVRvKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgIG5hbWUuY2xhc3NMaXN0LmFkZCgnbmFtZScpO1xyXG4gICAgICAgICAgICBzZW5kZXJDb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRURWU2VuZGVyUmVjaXBpZW50KG5hbWUsIGNvbXBvbmVudCwgc2VuZGVyLCBcIlNlbmRlclwiLCAodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRNb2RlbC5kYXRhLnNlbmRlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LCBtb2RlbHMpO1xyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNlbmRlckNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWNpcGllbnQgJiYgaW5wdXRPdXRwdXRTdGF0ZSAhPT0gXCJJbnB1dFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICByZWNpcGllbnRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmcm9tVG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgIGZyb21Uby5jbGFzc0xpc3QuYWRkKCdmcm9tVG8nKTtcclxuICAgICAgICAgICAgZnJvbVRvLnRleHRDb250ZW50ID0gTG5nLmd0KFwiVG9cIik7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudENvbnRhaW5lci5hcHBlbmRDaGlsZChmcm9tVG8pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgbmFtZS5jbGFzc0xpc3QuYWRkKCduYW1lJyk7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudENvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVFRFZTZW5kZXJSZWNpcGllbnQobmFtZSwgY29tcG9uZW50LCByZWNpcGllbnQsIFwiUmVjaXBpZW50XCIsICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudE1vZGVsLmRhdGEucmVjaXBpZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIG1vZGVscyk7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVjaXBpZW50Q29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlclJlY2lwaWVudDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVFRFZTZW5kZXJSZWNpcGllbnQoXHJcbiAgICAgICAgbmFtZTogSFRNTEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIHZhbHVlOiBzdHJpbmcsXHJcbiAgICAgICAgdGl0bGU6IHN0cmluZyxcclxuICAgICAgICBvblNhdmVDYWxsYmFjazogKHZhbHVlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4sXHJcbiAgICAgICAgbW9kZWxzOiBEb2N1bWVudE1vZGVsW10gPSBbXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWRpdGFibGVEYXRhVmlldyhuYW1lLCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLnNldFRpdGxlKHRpdGxlKVxyXG4gICAgICAgICAgICAgICAgLmVuYWJsZUVkaXRhYmlsaXR5KClcclxuICAgICAgICAgICAgICAgIC5zZXRTdWdnZXN0ZXIoKGlucHV0VmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gbW9kZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mbGF0TWFwKGRvY3VtZW50ID0+IFtkb2N1bWVudC5kYXRhLnNlbmRlciwgZG9jdW1lbnQuZGF0YS5yZWNpcGllbnRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KTogdiBpcyBzdHJpbmcgPT4gdiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2LCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYuaW5jbHVkZXMoaW5wdXRWYWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGljZSgwLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vblNhdmUoKG5ld1ZhbHVlOiBzdHJpbmcpID0+IG9uU2F2ZUNhbGxiYWNrKG5ld1ZhbHVlKSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNlbGxGaWxlTGluayhcclxuICAgICAgICBmaWxlTGluazogRG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBkb2N1bWVudE1vZGVsOiBEb2N1bWVudE1vZGVsLFxyXG4gICAgICAgIGVkaXRhYmlsaXR5ID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmZpbGVDYWNoZTtcclxuICAgICAgICBjb25zdCBhcHAgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5hcHA7XHJcbiAgICAgICAgbmV3IEVkaXRhYmxlRGF0YVZpZXcoZmlsZUxpbmssIGNvbXBvbmVudClcclxuICAgICAgICAgICAgLmFkZExpbmsobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnNldFZhbHVlKGRvY3VtZW50TW9kZWwuZGF0YS50aXRsZSA/PyBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZShMbmcuZ3QoXCJQREZGaWxlXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMaW5rVHlwZShcImZpbGVcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0Rm9ybWF0b3IoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZUZpbGVEYXRhID0gSGVscGVyLmV4dHJhY3REYXRhRnJvbVdpa2lsaW5rKGRvY3VtZW50TW9kZWwuZGF0YS5maWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZUZpbGUgPSBmaWxlQ2FjaGUuZmluZEZpbGVCeU5hbWUoYmFzZUZpbGVEYXRhLmZpbGVuYW1lID8/IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmFzZUZpbGVQYXRoID0gYmFzZUZpbGVEYXRhLmZpbGVuYW1lID8/IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRmlsZSAmJiBiYXNlRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlRmlsZVBhdGggPSBiYXNlRmlsZS5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2NGcmFnbWVudDogRG9jdW1lbnRGcmFnbWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEhlbHBlci5pc1Bvc3NpYmx5TWFya2Rvd24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIoYXBwLCB2YWx1ZSA/PyBcIlwiLCBkaXYsIFwiXCIsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NGcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGhyZWY6IGAke2Jhc2VGaWxlUGF0aH1gLCB0ZXh0OiBgJHt2YWx1ZX1gLCBodG1sOiBkb2NGcmFnbWVudCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRhYmlsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5lbmFibGVFZGl0YWJpbGl0eSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vblNhdmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kZWwuZGF0YS50aXRsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVDZWxsTWV0YWRhdGFsaW5rKFxyXG4gICAgICAgIG1ldGFkYXRhTGluazogRG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBkb2N1bWVudE1vZGVsOiBEb2N1bWVudE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5zZXR0aW5ncztcclxuICAgICAgICBuZXcgRWRpdGFibGVEYXRhVmlldyhtZXRhZGF0YUxpbmssIGNvbXBvbmVudClcclxuICAgICAgICAgICAgLmFkZExpbmsobGluayA9PiBsaW5rXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoZG9jdW1lbnRNb2RlbC5maWxlLnBhdGgpXHJcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUoXCJPcGVuIG1ldGFkYXRhIGZpbGVcIilcclxuICAgICAgICAgICAgICAgIC5zZXRMaW5rVHlwZShcImZpbGVcIilcclxuICAgICAgICAgICAgICAgIC5zZXRGb3JtYXRvcigodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGljb25TdHJpbmcgPSBcIngtY2lyY2xlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50TW9kZWwuZGF0YS5oaWRlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBzZXR0aW5ncy5kb2N1bWVudFNldHRpbmdzLmhpZGVTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50TW9kZWwuZGF0YS5zdWJUeXBlID09PSBcIkNsdXN0ZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IHNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3MuY2x1c3RlclN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBzZXR0aW5ncy5kb2N1bWVudFNldHRpbmdzLnN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRJY29uKGljb24gYXMgdW5rbm93biBhcyBIVE1MRGl2RWxlbWVudCwgaWNvblN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaHJlZjogYCR7dmFsdWV9YCwgdGV4dDogYCR7dmFsdWV9YCwgaHRtbDogaWNvbiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgUGxhdGZvcm0sIHNldEljb24gfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwic3JjL2NsYXNzZXMvR2xvYmFsXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgZ2V0IGNvbnRhaW5lcigpOiBIVE1MRGl2RWxlbWVudCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpcHBpbmdDb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcG9uZW50OiBDb21wb25lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgd2lsbCBiZSBjcmVhdGVkIHRvIGFsbG93IGVkaXRpbmcuXHJcbiAgICAgKiBAcmVtYXJrcyBDcmVhdGUgYSBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgY2hpbGQgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBlZGl0YWJpbGl0eUVuYWJsZWQ6IGJvb2xlYW47XHJcbiAgICAvLyNyZWdpb24gSFRNTCBFbGVtZW50c1xyXG4gICAgcHJpdmF0ZSBzaGlwcGluZ0NvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIGlucHV0IGVsZW1lbnRzLlxyXG4gICAgICogQHJlbWFya3MgSGFzIHRoZSBDU1MgY2xhc3NlcyBgZWRpdGFibGUtZGF0YS12aWV3YCAmIGBkYXRhLWlucHV0LWNvbnRhaW5lcmAuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkYXRhSW5wdXRDb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIGVsZW1lbnRzIHdoaWNoIHNob3cgdGhlIGRhdGEgaW4gYG5vdC1lZGl0YCBtb2RlLlxyXG4gICAgICogQHJlbWFya3MgSGFzIHRoZSBDU1MgY2xhc3NlcyBgZWRpdGFibGUtZGF0YS12aWV3YCAmIGBwcmVzZW50YXRpb24tY29udGFpbmVyYC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHByZXNlbnRhdGlvbkNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGJ1dHRvbkNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGVkaXRCdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBjYW5jZWxCdXR0b246IEhUTUxCdXR0b25FbGVtZW50IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBzYXZlQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIENhbGxiYWNrc1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgYGVkaXRgIGJ1dHRvbi5cclxuICAgICAqIFRoZSBgZGF0YUlucHV0Q29udGFpbmVyYCBpcyB2aXNpYmxlIGFuZCB0aGUgYHByZXNlbnRhdGlvbkNvbnRhaW5lcmAgaXMgaGlkZGVuLlxyXG4gICAgICogRmlsbCB0aGUgYGRhdGFJbnB1dENvbnRhaW5lcmAgd2l0aCB0aGUgaW5wdXQgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG9uRW5hYmxlRWRpdENhbGxiYWNrOiAoKCkgPT4gdm9pZCk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBgY2FuY2VsYCBidXR0b24gb3IgXHJcbiAgICAgKiBhZnRlciB0aGUgYHNhdmVDaGFuZ2VzYC1tZXRob2RlIGlzIGNsaWNrZWQuXHJcbiAgICAgKiBUaGUgYGRhdGFJbnB1dENvbnRhaW5lcmAgaXMgaGlkZGVuIGFuZCB0aGUgYHByZXNlbnRhdGlvbkNvbnRhaW5lcmAgaXMgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgb25EaXNhYmxlRWRpdENhbGxiYWNrOiAoKCkgPT4gdm9pZCk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBgc2F2ZWAgYnV0dG9uLlxyXG4gICAgICogVGhlIGBkYXRhSW5wdXRDb250YWluZXJgIGlzIGhpZGRlbiBhbmQgdGhlIGBwcmVzZW50YXRpb25Db250YWluZXJgIGlzIHZpc2libGUuXHJcbiAgICAgKiBUaGUgY2hhbmdlcyBzaG91bGQgYmUgc2F2ZWQgYW5kIHRoZSBgcHJlc2VudGF0aW9uQ29udGFpbmVyYCBzaG91bGQgYmUgZmlsbGVkIHdpdGggdGhlIG5ldyBkYXRhLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvblNhdmVDYWxsYmFjazogKCgpID0+IFByb21pc2U8dm9pZD4pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgYGVkaXRgIGJ1dHRvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgKiBUaGUgYGRhdGFJbnB1dENvbnRhaW5lcmAgaXMgdmlzaWJsZSBhbmQgdGhlIGBwcmVzZW50YXRpb25Db250YWluZXJgIGlzIGhpZGRlbi5cclxuICAgICAqIEZpbGwgdGhlIGBkYXRhSW5wdXRDb250YWluZXJgIHdpdGggdGhlIGlucHV0IGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvbkZpcnN0RWRpdDogKCgpID0+IHZvaWQpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZmluYWxpemVkLlxyXG4gICAgICogVGhlIGBkYXRhSW5wdXRDb250YWluZXJgIGlzIGhpZGRlbiBhbmQgdGhlIGBwcmVzZW50YXRpb25Db250YWluZXJgIGlzIHZpc2libGUuXHJcbiAgICAgKiBGaWxsIHRoZSBgcHJlc2VudGF0aW9uQ29udGFpbmVyYCB3aXRoIHRoZSBkYXRhLlxyXG4gICAgICogQHJlbWFya3MgRG9uJ3QgZmlsbCB0aGUgYGRhdGFJbnB1dENvbnRhaW5lcmAgd2l0aCB0aGUgaW5wdXQgZWxlbWVudHMhXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgY29tcG9uZW50IGlzIGZpbmlzaGVkIHdoZW4gdGhlIGBvbkZpbmFsaXplYC1jYWxsYmFjayBpcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG9uRmluYWxpemU6ICgoKSA9PiB2b2lkKTtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudDogQ29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5zaGlwcGluZ0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuc2hpcHBpbmdDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3JywgJ2NvbnRhaW5lcicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgYmFzZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBlZGl0YWJpbGl0eUVuYWJsZWQgSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgYmUgY3JlYXRlZCB0byBhbGxvdyBlZGl0aW5nLlxyXG4gICAgICogQHR1dG9yaWFsIFJ1biB0aGlzIG1ldGhvZGUgaW4gdGhlIGBmaW5hbGl6ZWAtbWV0aG9kZSBvZiB0aGUgY2hpbGQgY2xhc3MgYmVmb3JlIGNyZWF0aW5nIHlvdXIgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVCYXNlU3RydWN0dXJlKGVkaXRhYmlsaXR5RW5hYmxlZDogYm9vbGVhbiA9IHRoaXMuZWRpdGFiaWxpdHlFbmFibGVkKTogdm9pZCB7XHJcblxyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3JywgJ3ByZXNlbnRhdGlvbi1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLnNoaXBwaW5nQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJlc2VudGF0aW9uQ29udGFpbmVyKTtcclxuICAgICAgICBpZiAoZWRpdGFiaWxpdHlFbmFibGVkICYmIChQbGF0Zm9ybS5pc01vYmlsZSA/IEdsb2JhbC5nZXRJbnN0YW5jZSgpLnNldHRpbmdzLm1vYmlsZSA6IHRydWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2VkaXRhYmxlLWRhdGEtdmlldycsICdidXR0b24tY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRWRpdEJ1dHRvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnNoaXBwaW5nQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuYnV0dG9uQ29udGFpbmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgYGVkaXRgIGJ1dHRvbiBhbmQgYWRkcyBpdCB0byB0aGUgYGJ1dHRvbkNvbnRhaW5lcmAuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlRWRpdEJ1dHRvbigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmVkaXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVkaXRCdXR0b24pO1xyXG4gICAgICAgIHRoaXMuZWRpdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLmVkaXRCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnV0dG9uJyk7XHJcbiAgICAgICAgc2V0SWNvbih0aGlzLmVkaXRCdXR0b24sICdwZW4nKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KHRoaXMuZWRpdEJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy5lbmFibGVFZGl0TW9kZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGBzYXZlYCBhbmQgYGNhbmNlbGAgYnV0dG9ucyBhbmQgdGhlIGBpbnB1dGAgY29udGFpbmVyIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGBidXR0b25Db250YWluZXJgLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUNvbXBvbmVudHNGb3JFZGl0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGF0YUlucHV0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5kYXRhSW5wdXRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3JywgJ2RhdGEtaW5wdXQtY29udGFpbmVyJywgJ2hpZGRlbicpO1xyXG4gICAgICAgIHRoaXMuc2hpcHBpbmdDb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZGF0YUlucHV0Q29udGFpbmVyLCB0aGlzLnByZXNlbnRhdGlvbkNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgdGhpcy5idXR0b25Db250YWluZXIuaW5zZXJ0QWZ0ZXIodGhpcy5jYW5jZWxCdXR0b24sIHRoaXMuZWRpdEJ1dHRvbik7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnYnV0dG9uJyk7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgc2V0SWNvbih0aGlzLmNhbmNlbEJ1dHRvbiwgJ3gnKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KHRoaXMuY2FuY2VsQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLmRpc2FibGVFZGl0TW9kZSgpKTtcclxuXHJcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgdGhpcy5idXR0b25Db250YWluZXIuaW5zZXJ0QWZ0ZXIodGhpcy5zYXZlQnV0dG9uLCB0aGlzLmNhbmNlbEJ1dHRvbik7XHJcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2VkaXRhYmxlLWRhdGEtdmlldycpO1xyXG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidXR0b24nKTtcclxuICAgICAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgc2V0SWNvbih0aGlzLnNhdmVCdXR0b24sICdjaGVjaycpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlZ2lzdGVyRG9tRXZlbnQodGhpcy5zYXZlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnNhdmVDaGFuZ2VzKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIHRoZSBmaW5hbCBjb25maWd1cmF0aW9uIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaW5hbGl6ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZUJhc2VTdHJ1Y3R1cmUoKTtcclxuICAgICAgICB0aGlzLm9uRmluYWxpemU/LigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBgZWRpdGAgYnV0dG9uLlxyXG4gICAgICogSXQgc2hvdWxkIHN3aXRjaCB0aGUgY29tcG9uZW50IHRvIGVkaXQgbW9kZSBhbmQgXHJcbiAgICAgKiBjcmVhdGUgdGhlIGBzYXZlYCBhbmQgYGNhbmNlbGAgYnV0dG9ucyBpZiBub3QgYWxyZWFkeSBjcmVhdGVkLlxyXG4gICAgICogQHJlbWFya3MgWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kZSB0byBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBgZWRpdGAgYnV0dG9uLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZW5hYmxlRWRpdE1vZGUoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGBzYXZlYCBvciB0aGUgYGNhbmNlbGAgYnV0dG9uIGlzIG5vdCBjcmVhdGVkLCBjcmVhdGUgdGhlbS5cclxuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsQnV0dG9uIHx8ICF0aGlzLnNhdmVCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb21wb25lbnRzRm9yRWRpdCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uRmlyc3RFZGl0Py4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3dpdGNoIG1vZGUgdG8gRWRpdDogaGlkZSB0aGUgYGVkaXRgIGJ1dHRvbiBhbmQgc2hvdyB0aGUgYHNhdmVgIGFuZCBgY2FuY2VsYCBidXR0b25zLlxyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbEJ1dHRvbiAmJiB0aGlzLnNhdmVCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUlucHV0Q29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRCdXR0b24uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHRoaXMub25FbmFibGVFZGl0Q2FsbGJhY2s/LigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgYGNhbmNlbGAgYnV0dG9uIG9yIFxyXG4gICAgICogYWZ0ZXIgdGhlIGBzYXZlQ2hhbmdlc2AtbWV0aG9kZSBpcyBjbGlja2VkLlxyXG4gICAgICogQHJlbWFya3MgWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kZSB0byBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBgY2FuY2VsYCBidXR0b24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkaXNhYmxlRWRpdE1vZGUoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gU3dpdGNoIG1vZGUgdG8gVmlldzogaGlkZSB0aGUgYHNhdmVgIGFuZCBgY2FuY2VsYCBidXR0b25zIGFuZCBzaG93IHRoZSBgZWRpdGAgYnV0dG9uLlxyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbEJ1dHRvbiAmJiB0aGlzLnNhdmVCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Db250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUlucHV0Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNhYmxlRWRpdENhbGxiYWNrPy4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIGBzYXZlYCBidXR0b24uXHJcbiAgICAgKiBAcmVtYXJrcyBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2RlIHRvIHNpbXVsYXRlIGEgY2xpY2sgb24gdGhlIGBzYXZlYCBidXR0b24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhc3luYyBzYXZlQ2hhbmdlcygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBSdW4gdGhlIGNhbGxiYWNrIGFuZCBkaXNhYmxlIGVkaXQgbW9kZS5cclxuICAgICAgICBpZiAodGhpcy5jYW5jZWxCdXR0b24gJiYgdGhpcy5zYXZlQnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMub25TYXZlQ2FsbGJhY2s/LigpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsICJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSBcIi4vQmFzZUNvbXBvbmVudFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgLy8jcmVnaW9uIGJhc2UgcHJvcGVydGllc1xyXG4gICAgcHJvdGVjdGVkIGVkaXRhYmlsaXR5RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgb25FbmFibGVFZGl0Q2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcbiAgICBvbkRpc2FibGVFZGl0Q2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcbiAgICBvblNhdmVDYWxsYmFjazogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICAgIG9uRmlyc3RFZGl0OiAoKSA9PiB2b2lkO1xyXG4gICAgb25GaW5hbGl6ZTogKCkgPT4gdm9pZDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIGV4dGVuZGVkIHByb3BlcnRpZXNcclxuICAgIHByaXZhdGUgX29uUHJlc2VudGF0aW9uOiAodmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfb25TYXZlOiAoKHZhbHVlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4pO1xyXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmc7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIC8vI3JlZ2lvbiBIVE1MIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIHByZXNlbnRhdGlvblNwYW46IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudDogQ29tcG9uZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLm9uRmluYWxpemUgPSB0aGlzLmJ1aWxkXHJcbiAgICAgICAgdGhpcy5vbkZpcnN0RWRpdCA9IHRoaXMuYnVpbGRJbnB1dDtcclxuICAgICAgICB0aGlzLm9uRW5hYmxlRWRpdENhbGxiYWNrID0gdGhpcy5lbmFibGVFZGl0O1xyXG4gICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2sgPSB0aGlzLnNhdmU7XHJcbiAgICAgICAgdGhpcy5vbkRpc2FibGVFZGl0Q2FsbGJhY2sgPSB0aGlzLmRpc2FibGVFZGl0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBDb25maWd1cmF0aW9uIG1ldGhvZHNcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyB0aGUgZWRpdGFiaWxpdHkgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlRWRpdGFiaWxpdHkoKTogRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgdGhpcy5lZGl0YWJpbGl0eUVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKTogRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIHRpdGxlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmb3JtYXRvciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGZvcm1hdG9yIFRoZSBmb3JtYXRvciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBmb3JtYXRvciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZSBpbiBgbm90LWVkaXRgIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGb3JtYXRvcihmb3JtYXRvcjogKHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZyk6IERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIHRoaXMuX29uUHJlc2VudGF0aW9uID0gZm9ybWF0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzYXZlciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBzYXZlciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBzYXZlciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IHNhdmUgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblNhdmUoY2FsbGJhY2s6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XHJcbiAgICAgICAgdGhpcy5fb25TYXZlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gQmFzZSBDYWxsYmFja3NcclxuICAgIHByaXZhdGUgYnVpbGQoKSB7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJlc2VudGF0aW9uU3Bhbik7XHJcblxyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50aXRsZSA9IHRoaXMuX3RpdGxlO1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4uY2xhc3NMaXN0LmFkZCgnZGF0ZS1wcmVzZW50YXRpb24nKTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSB0aGlzLl9vblByZXNlbnRhdGlvbiA/IHRoaXMuX29uUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKSA6IHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRJbnB1dCgpIHtcclxuICAgICAgICB0aGlzLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICB0aGlzLmRhdGFJbnB1dENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KTtcclxuICAgICAgICB0aGlzLmlucHV0LnR5cGUgPSAnZGF0ZSc7XHJcbiAgICAgICAgdGhpcy5pbnB1dC50aXRsZSA9IHRoaXMuX3RpdGxlO1xyXG4gICAgICAgIHRoaXMuaW5wdXQuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5jbGFzc0xpc3QuYWRkKCdkYXRlLWlucHV0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBlbmFibGVFZGl0KCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0aGlzLl92YWx1ZSA/IHRoaXMuX3ZhbHVlIDogJyc7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQuc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNhYmxlRWRpdCgpIHtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSB0aGlzLl9vblByZXNlbnRhdGlvbiA/IHRoaXMuX29uUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKSA6IHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgc2F2ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuaW5wdXQudmFsdWU7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fb25TYXZlPy4odGhpcy5fdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwgImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tIFwiLi9CYXNlQ29tcG9uZW50XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgLy8jcmVnaW9uIGJhc2UgcHJvcGVydGllc1xyXG4gICAgcHJvdGVjdGVkIGVkaXRhYmlsaXR5RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgb25FbmFibGVFZGl0Q2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcbiAgICBvbkRpc2FibGVFZGl0Q2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcbiAgICBvblNhdmVDYWxsYmFjazogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICAgIG9uRmlyc3RFZGl0OiAoKSA9PiB2b2lkO1xyXG4gICAgb25GaW5hbGl6ZTogKCkgPT4gdm9pZDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIGV4dGVuZGVkIHByb3BlcnRpZXNcclxuICAgIHByaXZhdGUgX29uUHJlc2VudGF0aW9uOiAodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgX29uU2F2ZTogKCh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KTtcclxuICAgIHByaXZhdGUgX3ZhbHVlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9vcHRpb25zOiB7IHZhbHVlOiBzdHJpbmc7IHRleHQ6IHN0cmluZzsgfVtdO1xyXG4gICAgcHJpdmF0ZSBnZXQgX3NlbGVjdGVkT3B0aW9uKCk6IHsgdmFsdWU6IHN0cmluZzsgdGV4dDogc3RyaW5nOyB9IHtcclxuICAgICAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMuX29wdGlvbnMuZmluZChvID0+IG8udmFsdWUgPT09IHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRPcHRpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZE9wdGlvbjtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5fdmFsdWUsIHRleHQ6IHRoaXMuX3ZhbHVlIH07XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICAvLyNyZWdpb24gSFRNTCBFbGVtZW50c1xyXG4gICAgcHJpdmF0ZSBwcmVzZW50YXRpb25TcGFuOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgc2VsZWN0OiBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudDogQ29tcG9uZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLm9uRmluYWxpemUgPSB0aGlzLmJ1aWxkXHJcbiAgICAgICAgdGhpcy5vbkZpcnN0RWRpdCA9IHRoaXMuYnVpbGRJbnB1dDtcclxuICAgICAgICB0aGlzLm9uRW5hYmxlRWRpdENhbGxiYWNrID0gdGhpcy5lbmFibGVFZGl0O1xyXG4gICAgICAgIHRoaXMub25TYXZlQ2FsbGJhY2sgPSB0aGlzLnNhdmU7XHJcbiAgICAgICAgdGhpcy5vbkRpc2FibGVFZGl0Q2FsbGJhY2sgPSB0aGlzLmRpc2FibGVFZGl0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBDb25maWd1cmF0aW9uIG1ldGhvZHNcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyB0aGUgZWRpdGFiaWxpdHkgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlRWRpdGFiaWxpdHkoKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0YWJpbGl0eUVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zOiB7IHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZyB9W10pIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIHRpdGxlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGl0bGUodGl0bGU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmb3JtYXRvciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGZvcm1hdG9yIFRoZSBmb3JtYXRvciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIC0gVGhlIGZvcm1hdG9yIGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgY2hhbmdlIGluIGBub3QtZWRpdGAgbW9kZS5cclxuICAgICAqIC0gYHZhbHVlYCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbi4gKE5vdCB0aGUgdGV4dCEpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGb3JtYXRvcihmb3JtYXRvcjogKHZhbHVlOiBzdHJpbmcpID0+IHsgdGV4dDogc3RyaW5nLCBodG1sPzogRG9jdW1lbnRGcmFnbWVudCB9KSB7XHJcbiAgICAgICAgdGhpcy5fb25QcmVzZW50YXRpb24gPSBhc3luYyAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHRleHQsIGh0bWwgfSA9IGZvcm1hdG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGh0bWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5hcHBlbmRDaGlsZChodG1sKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2F2ZXIgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgc2F2ZXIgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBzYXZlciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IHNhdmUgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKiAtIGB2YWx1ZWAgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24uIChOb3QgdGhlIHRleHQhKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25TYXZlKGNhbGxiYWNrOiAodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikge1xyXG4gICAgICAgIHRoaXMuX29uU2F2ZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSBlbmFibGVPcHRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbkZvdW5kID0gdGhpcy5fb3B0aW9ucy5maW5kKG8gPT4gby52YWx1ZSA9PT0gdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIGlmICghb3B0aW9uRm91bmQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xyXG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aGlzLl92YWx1ZX0gKG5vdCBpbiBvcHRpb25zKWA7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xyXG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGlzYWJsZU9wdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEJhc2UgQ2FsbGJhY2tzXHJcbiAgICBwcml2YXRlIGJ1aWxkKCkge1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnByZXNlbnRhdGlvblNwYW4pO1xyXG5cclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGl0bGUgPSB0aGlzLl90aXRsZTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4uY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLmNsYXNzTGlzdC5hZGQoJ3RleHQtcHJlc2VudGF0aW9uJyk7XHJcbiAgICAgICAgdGhpcy5fb25QcmVzZW50YXRpb24/Lih0aGlzLl9zZWxlY3RlZE9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgLy90aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSB0aGlzLl9vblByZXNlbnRhdGlvbiA/IHRoaXMuX29uUHJlc2VudGF0aW9uKHRoaXMuX3NlbGVjdGVkT3B0aW9uLnZhbHVlKSA6IHRoaXMuX3NlbGVjdGVkT3B0aW9uLnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZElucHV0KCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XHJcbiAgICAgICAgdGhpcy5kYXRhSW5wdXRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3QpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LnRpdGxlID0gdGhpcy5fdGl0bGU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuY2xhc3NMaXN0LmFkZCgnc2VsZWN0LWlucHV0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBlbmFibGVFZGl0KCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LnZhbHVlID0gdGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZSA6ICcnO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNhYmxlRWRpdCgpIHtcclxuICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbj8uKHRoaXMuX3NlbGVjdGVkT3B0aW9uLnZhbHVlKTtcclxuICAgICAgICAvL3RoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IHRoaXMuX29uUHJlc2VudGF0aW9uID8gdGhpcy5fb25QcmVzZW50YXRpb24odGhpcy5fc2VsZWN0ZWRPcHRpb24udmFsdWUpIDogdGhpcy5fc2VsZWN0ZWRPcHRpb24udGV4dDtcclxuICAgICAgICB0aGlzLmRpc2FibGVPcHRpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5zZWxlY3QudmFsdWU7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fb25TYXZlPy4odGhpcy5fdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwgImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tIFwiLi9CYXNlQ29tcG9uZW50XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAvLyNyZWdpb24gYmFzZSBwcm9wZXJ0aWVzXHJcbiAgICBwcm90ZWN0ZWQgZWRpdGFiaWxpdHlFbmFibGVkID0gZmFsc2U7XHJcbiAgICBvbkVuYWJsZUVkaXRDYWxsYmFjazogKCkgPT4gdm9pZDtcclxuICAgIG9uRGlzYWJsZUVkaXRDYWxsYmFjazogKCkgPT4gdm9pZDtcclxuICAgIG9uU2F2ZUNhbGxiYWNrOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgb25GaXJzdEVkaXQ6ICgpID0+IHZvaWQ7XHJcbiAgICBvbkZpbmFsaXplOiAoKSA9PiB2b2lkO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICAvLyNyZWdpb24gZXh0ZW5kZWQgcHJvcGVydGllc1xyXG4gICAgcHJpdmF0ZSBfb25QcmVzZW50YXRpb246ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF9vblNhdmU6ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF9zdWdnZXN0ZXI6ICgodmFsdWU6IHN0cmluZykgPT4gc3RyaW5nW10pIHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3BsYWNlaG9sZGVyOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9zdWdnZXN0aW9uczogc3RyaW5nW107XHJcbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBsaW5rVHlwZTogJ3RhZycgfCAnZmlsZScgfCAnZXh0ZXJuYWwnID0gJ2V4dGVybmFsJztcclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgLy8jcmVnaW9uIEhUTUwgRWxlbWVudHNcclxuICAgIHByaXZhdGUgbGluazogSFRNTEFuY2hvckVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGxhYmVsOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGRhdGFsaXN0OiBIVE1MRGF0YUxpc3RFbGVtZW50O1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQpIHtcclxuICAgICAgICBzdXBlcihjb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMub25GaW5hbGl6ZSA9IHRoaXMuYnVpbGRcclxuICAgICAgICB0aGlzLm9uRmlyc3RFZGl0ID0gdGhpcy5idWlsZElucHV0O1xyXG4gICAgICAgIHRoaXMub25FbmFibGVFZGl0Q2FsbGJhY2sgPSB0aGlzLmVuYWJsZUVkaXQ7XHJcbiAgICAgICAgdGhpcy5vblNhdmVDYWxsYmFjayA9IHRoaXMuc2F2ZTtcclxuICAgICAgICB0aGlzLm9uRGlzYWJsZUVkaXRDYWxsYmFjayA9IHRoaXMuZGlzYWJsZUVkaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIENvbmZpZ3VyYXRpb24gbWV0aG9kc1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIHRoZSBlZGl0YWJpbGl0eSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVFZGl0YWJpbGl0eSgpIHtcclxuICAgICAgICB0aGlzLmVkaXRhYmlsaXR5RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcGxhY2Vob2xkZXIgb2YgdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXI6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN1Z2dlc3Rpb25zIGZvciB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBzdWdnZXN0aW9ucyBUaGUgc3VnZ2VzdGlvbnMgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTdWdnZXN0aW9ucyhzdWdnZXN0aW9uczogc3RyaW5nW10pIHtcclxuICAgICAgICB0aGlzLl9zdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGl0bGUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgdGl0bGUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaXRsZSh0aXRsZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB0aXRsZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGxpbmsuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBzZXQuIENhbiBiZSBgdGFnYCwgYGZpbGVgIG9yIGBleHRlcm5hbGAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldExpbmtUeXBlKHR5cGU6ICd0YWcnIHwgJ2ZpbGUnIHwgJ2V4dGVybmFsJykge1xyXG4gICAgICAgIHRoaXMubGlua1R5cGUgPSB0eXBlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3VnZ2VzdGVyIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGVyIFRoZSBzdWdnZXN0ZXIgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgc3VnZ2VzdGVyIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHR5cGVzIGluIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U3VnZ2VzdGVyKHN1Z2dlc3RlcjogKHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVyID0gc3VnZ2VzdGVyO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZm9ybWF0b3Igb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBmb3JtYXRvciBUaGUgZm9ybWF0b3IgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgZm9ybWF0b3IgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2UgaW4gYG5vdC1lZGl0YCBtb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Rm9ybWF0b3IoZm9ybWF0b3I6ICh2YWx1ZTogc3RyaW5nKSA9PiB7IGhyZWY6IHN0cmluZywgdGV4dDogc3RyaW5nLCBodG1sPzogRG9jdW1lbnRGcmFnbWVudCB9KSB7XHJcbiAgICAgICAgdGhpcy5fb25QcmVzZW50YXRpb24gPSBhc3luYyAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rQ29udGVudCA9IGZvcm1hdG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5saW5rLmhyZWYgPSBsaW5rQ29udGVudC5ocmVmO1xyXG4gICAgICAgICAgICBpZiAobGlua0NvbnRlbnQuaHRtbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmFwcGVuZENoaWxkKGxpbmtDb250ZW50Lmh0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy5saW5rLnRleHRDb250ZW50ID0gbGlua0NvbnRlbnQudGV4dDtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5saW5rVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsaW5rQ29udGVudC5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLWhyZWYnLCBsaW5rQ29udGVudC5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVybmFsJzpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQgJiYgdGhpcy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IGxpbmtDb250ZW50LnRleHQgPyBsaW5rQ29udGVudC50ZXh0IDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLmRhdGFzZXQudmFsdWUgPSBsaW5rQ29udGVudC50ZXh0ID8gbGlua0NvbnRlbnQudGV4dCA6IHRoaXMuX3BsYWNlaG9sZGVyID8gdGhpcy5fcGxhY2Vob2xkZXIgOiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzYXZlciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBzYXZlciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBzYXZlciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IHNhdmUgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblNhdmUoY2FsbGJhY2s6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XHJcbiAgICAgICAgdGhpcy5fb25TYXZlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcml2YXRlIHNldFN1Z2dlc3Rpb25zTGlzdChzdWdnZXN0aW9uczogc3RyaW5nW10pIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YWxpc3QpIHJldHVybjtcclxuICAgICAgICB0aGlzLmRhdGFsaXN0LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIHN1Z2dlc3Rpb25zLmZvckVhY2goc3VnZ2VzdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xyXG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBzdWdnZXN0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFsaXN0LmFwcGVuZENoaWxkKG9wdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEJhc2UgQ2FsbGJhY2tzXHJcbiAgICBwcml2YXRlIGJ1aWxkKCkge1xyXG4gICAgICAgIHRoaXMubGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmxpbmspO1xyXG5cclxuICAgICAgICB0aGlzLmxpbmsudGl0bGUgPSB0aGlzLl90aXRsZTtcclxuICAgICAgICB0aGlzLmxpbmsuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5saW5rLmNsYXNzTGlzdC5hZGQoJ2xpbmstcHJlc2VudGF0aW9uJyk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5saW5rVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0YWcnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmNsYXNzTGlzdC5hZGQoJ3RhZycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLnRhcmdldCA9ICdfYmxhbmsnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLnJlbCA9ICdub29wZW5lcic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZmlsZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtcG9zaXRpb24nLCAndG9wJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmsuY2xhc3NMaXN0LmFkZCgnaW50ZXJuYWwtbGluaycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLnRhcmdldCA9ICdfYmxhbmsnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLnJlbCA9ICdub29wZW5lcic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZXh0ZXJuYWwnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbj8uKHRoaXMuX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkSW5wdXQoKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC50aXRsZSA9IHRoaXMuX3RpdGxlO1xyXG4gICAgICAgIHRoaXMuZGF0YUlucHV0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0LXNpemVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLmlucHV0LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQnKTtcclxuICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fcGxhY2Vob2xkZXIgPyB0aGlzLl9wbGFjZWhvbGRlciA6ICcnO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlZ2lzdGVyRG9tRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsLmRhdGFzZXQudmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlID8gdGhpcy5pbnB1dC52YWx1ZSA6IHRoaXMuX3BsYWNlaG9sZGVyID8gdGhpcy5fcGxhY2Vob2xkZXIgOiAnJztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N1Z2dlc3RlciAmJiB0aGlzLmxhYmVsLmRhdGFzZXQudmFsdWUgIT09IHRoaXMuX3BsYWNlaG9sZGVyICYmIHRoaXMubGFiZWwuZGF0YXNldC52YWx1ZSAhPT0gXCJcIilcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3VnZ2VzdGlvbnNMaXN0KHRoaXMuX3N1Z2dlc3Rlcih0aGlzLmlucHV0LnZhbHVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVnaXN0ZXJEb21FdmVudCh0aGlzLmlucHV0LCAna2V5ZG93bicsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoKHRoaXMuX3N1Z2dlc3Rpb25zICYmIHRoaXMuX3N1Z2dlc3Rpb25zLmxlbmd0aCA+IDApIHx8IHRoaXMuX3N1Z2dlc3Rlcikge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKCdsaXN0JywgaWQpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhbGlzdC5pZCA9IGlkO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmFwcGVuZENoaWxkKHRoaXMuZGF0YWxpc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN1Z2dlc3Rpb25zTGlzdCh0aGlzLl9zdWdnZXN0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZW5hYmxlRWRpdCgpIHtcclxuICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbj8uKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5zZWxlY3QoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRpc2FibGVFZGl0KCkge1xyXG4gICAgICAgIHRoaXMuX29uUHJlc2VudGF0aW9uPy4odGhpcy5fdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgc2F2ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuaW5wdXQudmFsdWU7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fb25TYXZlPy4odGhpcy5fdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgTWFya2Rvd25SZW5kZXJlciB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tIFwiLi9CYXNlQ29tcG9uZW50XCI7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSBcInNyYy9jbGFzc2VzL0dsb2JhbFwiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCJzcmMvbGlicy9IZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIC8vI3JlZ2lvbiBiYXNlIHByb3BlcnRpZXNcclxuICAgIHByb3RlY3RlZCBlZGl0YWJpbGl0eUVuYWJsZWQgPSBmYWxzZTtcclxuICAgIG9uRW5hYmxlRWRpdENhbGxiYWNrOiAoKSA9PiB2b2lkO1xyXG4gICAgb25EaXNhYmxlRWRpdENhbGxiYWNrOiAoKSA9PiB2b2lkO1xyXG4gICAgb25TYXZlQ2FsbGJhY2s6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgICBvbkZpcnN0RWRpdDogKCkgPT4gdm9pZDtcclxuICAgIG9uRmluYWxpemU6ICgpID0+IHZvaWQ7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIC8vI3JlZ2lvbiBleHRlbmRlZCBwcm9wZXJ0aWVzXHJcbiAgICBwcml2YXRlIF9vblByZXNlbnRhdGlvbjogKCh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgX29uTWFya2Rvd25QcmVzZW50YXRpb246ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF9vblNhdmU6ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF9zdWdnZXN0ZXI6ICgodmFsdWU6IHN0cmluZykgPT4gc3RyaW5nW10pIHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3BsYWNlaG9sZGVyOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF9zdWdnZXN0aW9uczogc3RyaW5nW107XHJcbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICAvLyNyZWdpb24gSFRNTCBFbGVtZW50c1xyXG4gICAgcHJpdmF0ZSBwcmVzZW50YXRpb25TcGFuOiBIVE1MRWxlbWVudDtcclxuICAgIHByaXZhdGUgbGFiZWw6IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIHByaXZhdGUgZGF0YWxpc3Q6IEhUTUxEYXRhTGlzdEVsZW1lbnQ7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCkge1xyXG4gICAgICAgIHN1cGVyKGNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5vbkZpbmFsaXplID0gdGhpcy5idWlsZFxyXG4gICAgICAgIHRoaXMub25GaXJzdEVkaXQgPSB0aGlzLmJ1aWxkSW5wdXQ7XHJcbiAgICAgICAgdGhpcy5vbkVuYWJsZUVkaXRDYWxsYmFjayA9IHRoaXMuZW5hYmxlRWRpdDtcclxuICAgICAgICB0aGlzLm9uU2F2ZUNhbGxiYWNrID0gdGhpcy5zYXZlO1xyXG4gICAgICAgIHRoaXMub25EaXNhYmxlRWRpdENhbGxiYWNrID0gdGhpcy5kaXNhYmxlRWRpdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gQ29uZmlndXJhdGlvbiBtZXRob2RzXHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgdGhlIGVkaXRhYmlsaXR5IG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuYWJsZUVkaXRhYmlsaXR5KCkge1xyXG4gICAgICAgIHRoaXMuZWRpdGFiaWxpdHlFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmFsdWUodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwbGFjZWhvbGRlciBvZiB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc3VnZ2VzdGlvbnMgZm9yIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25zIFRoZSBzdWdnZXN0aW9ucyB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25zOiBzdHJpbmdbXSkge1xyXG4gICAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSB0aXRsZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpdGxlKHRpdGxlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl90aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3VnZ2VzdGVyIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGVyIFRoZSBzdWdnZXN0ZXIgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgc3VnZ2VzdGVyIGlzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHR5cGVzIGluIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U3VnZ2VzdGVyKHN1Z2dlc3RlcjogKHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVyID0gc3VnZ2VzdGVyO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZm9ybWF0b3Igb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBmb3JtYXRvciBUaGUgZm9ybWF0b3IgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgZm9ybWF0b3IgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2UgaW4gYG5vdC1lZGl0YCBtb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Rm9ybWF0b3IoZm9ybWF0b3I6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz4pIHtcclxuICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbiA9IGFzeW5jICh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IGF3YWl0IGZvcm1hdG9yKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2Rvd24gZm9ybWF0b3Igb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIHJlc29sdmUgaW50ZXJuYWwgbGlua3MuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBmb3JtYXRvciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZSBpbiBgbm90LWVkaXRgIG1vZGUuXHJcbiAgICAgKiAtIFRoZSBjdXN0b20gZm9ybWF0b3IgaXMgaWdub3JlZCBpZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSZW5kZXJNYXJrZG93bihwYXRoID0gXCJcIikge1xyXG4gICAgICAgIHRoaXMuX29uTWFya2Rvd25QcmVzZW50YXRpb24gPSAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgICAgICBpZiAoSGVscGVyLmlzUG9zc2libHlNYXJrZG93bih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmFwcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXJrZG93blJlbmRlcmVyLnJlbmRlcihhcHAsIHZhbHVlLCB0aGlzLnByZXNlbnRhdGlvblNwYW4sIHBhdGgsIHRoaXMuY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzYXZlciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBzYXZlciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBzYXZlciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IHNhdmUgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblNhdmUoY2FsbGJhY2s6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XHJcbiAgICAgICAgdGhpcy5fb25TYXZlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcml2YXRlIHNldFN1Z2dlc3Rpb25zTGlzdChzdWdnZXN0aW9uczogc3RyaW5nW10pIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YWxpc3QpIHJldHVybjtcclxuICAgICAgICB0aGlzLmRhdGFsaXN0LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGlmICghc3VnZ2VzdGlvbnMpIHJldHVybjtcclxuICAgICAgICBzdWdnZXN0aW9ucy5mb3JFYWNoKHN1Z2dlc3Rpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcclxuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gc3VnZ2VzdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5kYXRhbGlzdC5hcHBlbmRDaGlsZChvcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBCYXNlIENhbGxiYWNrc1xyXG4gICAgcHJpdmF0ZSBidWlsZCgpIHtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcmVzZW50YXRpb25TcGFuKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLnRpdGxlID0gdGhpcy5fdGl0bGU7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLmNsYXNzTGlzdC5hZGQoJ2VkaXRhYmxlLWRhdGEtdmlldycpO1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5jbGFzc0xpc3QuYWRkKCd0ZXh0LXByZXNlbnRhdGlvbicpO1xyXG4gICAgICAgIGlmICh0aGlzLl9vbk1hcmtkb3duUHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX29uTWFya2Rvd25QcmVzZW50YXRpb24odGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fb25QcmVzZW50YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fb25QcmVzZW50YXRpb24odGhpcy5fdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkSW5wdXQoKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC50aXRsZSA9IHRoaXMuX3RpdGxlO1xyXG4gICAgICAgIHRoaXMuZGF0YUlucHV0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuY2xhc3NMaXN0LmFkZCgnZWRpdGFibGUtZGF0YS12aWV3Jyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0LXNpemVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLmlucHV0LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQnKTtcclxuICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fcGxhY2Vob2xkZXIgPyB0aGlzLl9wbGFjZWhvbGRlciA6ICcnO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlZ2lzdGVyRG9tRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsLmRhdGFzZXQudmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlID8gdGhpcy5pbnB1dC52YWx1ZSA6IHRoaXMuX3BsYWNlaG9sZGVyID8gdGhpcy5fcGxhY2Vob2xkZXIgOiAnJztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N1Z2dlc3RlciAmJiB0aGlzLmxhYmVsLmRhdGFzZXQudmFsdWUgIT09IHRoaXMuX3BsYWNlaG9sZGVyICYmIHRoaXMubGFiZWwuZGF0YXNldC52YWx1ZSAhPT0gXCJcIilcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3VnZ2VzdGlvbnNMaXN0KHRoaXMuX3N1Z2dlc3Rlcih0aGlzLmlucHV0LnZhbHVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVnaXN0ZXJEb21FdmVudCh0aGlzLmlucHV0LCAna2V5ZG93bicsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoKHRoaXMuX3N1Z2dlc3Rpb25zICYmIHRoaXMuX3N1Z2dlc3Rpb25zLmxlbmd0aCA+IDApIHx8IHRoaXMuX3N1Z2dlc3Rlcikge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKCdsaXN0JywgaWQpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhbGlzdC5pZCA9IGlkO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmFwcGVuZENoaWxkKHRoaXMuZGF0YWxpc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN1Z2dlc3Rpb25zTGlzdCh0aGlzLl9zdWdnZXN0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZW5hYmxlRWRpdCgpIHtcclxuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZSA6ICcnO1xyXG4gICAgICAgIHRoaXMubGFiZWwuZGF0YXNldC52YWx1ZSA9IHRoaXMuX3ZhbHVlID8gdGhpcy5fdmFsdWUgOiB0aGlzLl9wbGFjZWhvbGRlciA/IHRoaXMuX3BsYWNlaG9sZGVyIDogJyc7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQuc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNhYmxlRWRpdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25NYXJrZG93blByZXNlbnRhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9vbk1hcmtkb3duUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX29uUHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9vblNhdmU/Lih0aGlzLl92YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxufVxyXG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gXCIuL0Jhc2VDb21wb25lbnRcIjtcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwic3JjL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCBIZWxwZXIgZnJvbSBcInNyYy9saWJzL0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dGFyZWFDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIC8vI3JlZ2lvbiBiYXNlIHByb3BlcnRpZXNcclxuICAgIHByb3RlY3RlZCBlZGl0YWJpbGl0eUVuYWJsZWQgPSBmYWxzZTtcclxuICAgIG9uRW5hYmxlRWRpdENhbGxiYWNrOiAoKSA9PiB2b2lkO1xyXG4gICAgb25EaXNhYmxlRWRpdENhbGxiYWNrOiAoKSA9PiB2b2lkO1xyXG4gICAgb25TYXZlQ2FsbGJhY2s6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgICBvbkZpcnN0RWRpdDogKCkgPT4gdm9pZDtcclxuICAgIG9uRmluYWxpemU6ICgpID0+IHZvaWQ7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIC8vI3JlZ2lvbiBleHRlbmRlZCBwcm9wZXJ0aWVzXHJcbiAgICBwcml2YXRlIF9vblByZXNlbnRhdGlvbjogKCh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB8IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgX29uTWFya2Rvd25QcmVzZW50YXRpb246ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF9vblNhdmU6ICgodmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPikgfCB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIF92YWx1ZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IHN0cmluZztcclxuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmc7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIC8vI3JlZ2lvbiBIVE1MIEVsZW1lbnRzXHJcbiAgICBwcml2YXRlIHByZXNlbnRhdGlvblNwYW46IEhUTUxFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBsYWJlbDogSFRNTEVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHRleHRhcmVhOiBIVE1MVGV4dEFyZWFFbGVtZW50O1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQpIHtcclxuICAgICAgICBzdXBlcihjb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMub25GaW5hbGl6ZSA9IHRoaXMuYnVpbGRcclxuICAgICAgICB0aGlzLm9uRmlyc3RFZGl0ID0gdGhpcy5idWlsZElucHV0O1xyXG4gICAgICAgIHRoaXMub25FbmFibGVFZGl0Q2FsbGJhY2sgPSB0aGlzLmVuYWJsZUVkaXQ7XHJcbiAgICAgICAgdGhpcy5vblNhdmVDYWxsYmFjayA9IHRoaXMuc2F2ZTtcclxuICAgICAgICB0aGlzLm9uRGlzYWJsZUVkaXRDYWxsYmFjayA9IHRoaXMuZGlzYWJsZUVkaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIENvbmZpZ3VyYXRpb24gbWV0aG9kc1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIHRoZSBlZGl0YWJpbGl0eSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbmFibGVFZGl0YWJpbGl0eSgpIHtcclxuICAgICAgICB0aGlzLmVkaXRhYmlsaXR5RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcGxhY2Vob2xkZXIgb2YgdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXI6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSB0aXRsZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpdGxlKHRpdGxlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl90aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZm9ybWF0b3Igb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBmb3JtYXRvciBUaGUgZm9ybWF0b3IgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgZm9ybWF0b3IgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBjaGFuZ2UgaW4gYG5vdC1lZGl0YCBtb2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Rm9ybWF0b3IoZm9ybWF0b3I6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz4pIHtcclxuICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbiA9IGFzeW5jICh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50ZXh0Q29udGVudCA9IGF3YWl0IGZvcm1hdG9yKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2Rvd24gZm9ybWF0b3Igb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIHJlc29sdmUgaW50ZXJuYWwgbGlua3MuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBmb3JtYXRvciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZSBpbiBgbm90LWVkaXRgIG1vZGUuXHJcbiAgICAgKiAtIFRoZSBjdXN0b20gZm9ybWF0b3IgaXMgaWdub3JlZCBpZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSZW5kZXJNYXJrZG93bihwYXRoID0gXCJcIikge1xyXG4gICAgICAgIHRoaXMuX29uTWFya2Rvd25QcmVzZW50YXRpb24gPSAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgICAgICBpZiAoSGVscGVyLmlzUG9zc2libHlNYXJrZG93bih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLmFwcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXJrZG93blJlbmRlcmVyLnJlbmRlcihhcHAsIHZhbHVlLCB0aGlzLnByZXNlbnRhdGlvblNwYW4sIHBhdGgsIHRoaXMuY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzYXZlciBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBzYXZlciB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcG9uZW50IGl0c2VsZi5cclxuICAgICAqIEByZW1hcmtzIFRoZSBzYXZlciBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IHNhdmUgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblNhdmUoY2FsbGJhY2s6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XHJcbiAgICAgICAgdGhpcy5fb25TYXZlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gQmFzZSBDYWxsYmFja3NcclxuICAgIHByaXZhdGUgYnVpbGQoKSB7XHJcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJlc2VudGF0aW9uU3Bhbik7XHJcblxyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi50aXRsZSA9IHRoaXMuX3RpdGxlO1xyXG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uU3Bhbi5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4uY2xhc3NMaXN0LmFkZCgndGV4dGFyZWEtcHJlc2VudGF0aW9uJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uTWFya2Rvd25QcmVzZW50YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLnRleHRDb250ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fb25NYXJrZG93blByZXNlbnRhdGlvbih0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9vblByZXNlbnRhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9vblByZXNlbnRhdGlvbih0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25TcGFuLnRleHRDb250ZW50ID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRJbnB1dCgpIHtcclxuICAgICAgICB0aGlzLmxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcclxuICAgICAgICB0aGlzLmxhYmVsLnRpdGxlID0gdGhpcy5fdGl0bGU7XHJcbiAgICAgICAgdGhpcy5kYXRhSW5wdXRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLmxhYmVsLmNsYXNzTGlzdC5hZGQoJ3RleHRhcmVhLWlucHV0LXNpemVyJyk7XHJcblxyXG4gICAgICAgIHRoaXMudGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuYXBwZW5kQ2hpbGQodGhpcy50ZXh0YXJlYSk7XHJcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5jbGFzc0xpc3QuYWRkKCdlZGl0YWJsZS1kYXRhLXZpZXcnKTtcclxuICAgICAgICB0aGlzLnRleHRhcmVhLmNsYXNzTGlzdC5hZGQoJ3RleHRhcmVhLWlucHV0Jyk7XHJcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5wbGFjZWhvbGRlciA9IHRoaXMuX3BsYWNlaG9sZGVyID8gdGhpcy5fcGxhY2Vob2xkZXIgOiAnJztcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KHRoaXMudGV4dGFyZWEsICdpbnB1dCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbC5kYXRhc2V0LnZhbHVlID0gdGhpcy50ZXh0YXJlYS52YWx1ZSA/IHRoaXMudGV4dGFyZWEudmFsdWUgOiB0aGlzLl9wbGFjZWhvbGRlciA/IHRoaXMuX3BsYWNlaG9sZGVyIDogJyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVnaXN0ZXJEb21FdmVudCh0aGlzLnRleHRhcmVhLCAna2V5ZG93bicsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZW5hYmxlRWRpdCgpIHtcclxuICAgICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gdGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZSA6ICcnO1xyXG4gICAgICAgIHRoaXMubGFiZWwuZGF0YXNldC52YWx1ZSA9IHRoaXMuX3ZhbHVlID8gdGhpcy5fdmFsdWUgOiB0aGlzLl9wbGFjZWhvbGRlciA/IHRoaXMuX3BsYWNlaG9sZGVyIDogJyc7XHJcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xyXG4gICAgICAgIHRoaXMudGV4dGFyZWEuc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNhYmxlRWRpdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fb25NYXJrZG93blByZXNlbnRhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9vbk1hcmtkb3duUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX29uUHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uUHJlc2VudGF0aW9uKHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNlbnRhdGlvblNwYW4udGV4dENvbnRlbnQgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy50ZXh0YXJlYS52YWx1ZTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9vblNhdmU/Lih0aGlzLl92YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxufVxyXG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBEYXRlQ29tcG9uZW50IGZyb20gXCIuL0NvbXBvbmVudHMvRGF0ZUNvbXBvbmVudFwiO1xyXG5pbXBvcnQgRHJvcGRvd25Db21wb25lbnQgZnJvbSBcIi4vQ29tcG9uZW50cy9Ecm9wZG93bkNvbXBvbmVudFwiO1xyXG5pbXBvcnQgTGlua0NvbXBvbmVudCBmcm9tIFwiLi9Db21wb25lbnRzL0xpbmtDb21wb25lbnRcIjtcclxuaW1wb3J0IFRleHRDb21wb25lbnQgZnJvbSBcIi4vQ29tcG9uZW50cy9UZXh0Q29tcG9uZW50XCI7XHJcbmltcG9ydCBUZXh0YXJlYUNvbXBvbmVudCBmcm9tIFwiLi9Db21wb25lbnRzL1RleHRhcmVhQ29tcG9uZW50XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0YWJsZURhdGFWaWV3IHtcclxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50O1xyXG4gICAgcHJpdmF0ZSBjb21wb25lbnQ6IENvbXBvbmVudDtcclxuICAgIHByaXZhdGUgYXR0cmlidXRlc0xpc3Q6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudCwgY29tcG9uZW50OiBDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBhZGRUZXh0KGNvbmZpZ3VyZTogKGNvbXBvbmVudDogVGV4dENvbXBvbmVudCkgPT4gdm9pZCk6IEVkaXRhYmxlRGF0YVZpZXcge1xyXG4gICAgICAgIGNvbnN0IHRleHRDb21wb25lbnQgPSBuZXcgVGV4dENvbXBvbmVudCh0aGlzLmNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uZmlndXJlKHRleHRDb21wb25lbnQpO1xyXG4gICAgICAgIHRleHRDb21wb25lbnQuZmluYWxpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0ZXh0Q29tcG9uZW50LmNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRUZXh0YXJlYShjb25maWd1cmU6IChjb21wb25lbnQ6IFRleHRhcmVhQ29tcG9uZW50KSA9PiB2b2lkKTogRWRpdGFibGVEYXRhVmlldyB7XHJcbiAgICAgICAgY29uc3QgdGV4dENvbXBvbmVudCA9IG5ldyBUZXh0YXJlYUNvbXBvbmVudCh0aGlzLmNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uZmlndXJlKHRleHRDb21wb25lbnQpO1xyXG4gICAgICAgIHRleHRDb21wb25lbnQuZmluYWxpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0ZXh0Q29tcG9uZW50LmNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRMaW5rKGNvbmZpZ3VyZTogKGNvbXBvbmVudDogTGlua0NvbXBvbmVudCkgPT4gdm9pZCk6IEVkaXRhYmxlRGF0YVZpZXcge1xyXG4gICAgICAgIGNvbnN0IGxpbmtDb21wb25lbnQgPSBuZXcgTGlua0NvbXBvbmVudCh0aGlzLmNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uZmlndXJlKGxpbmtDb21wb25lbnQpO1xyXG4gICAgICAgIGxpbmtDb21wb25lbnQuZmluYWxpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmtDb21wb25lbnQuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZERhdGUoY29uZmlndXJlOiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50KSA9PiB2b2lkKTogRWRpdGFibGVEYXRhVmlldyB7XHJcbiAgICAgICAgY29uc3QgZGF0ZUNvbXBvbmVudCA9IG5ldyBEYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50KTtcclxuICAgICAgICBjb25maWd1cmUoZGF0ZUNvbXBvbmVudCk7XHJcbiAgICAgICAgZGF0ZUNvbXBvbmVudC5maW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKGRhdGVDb21wb25lbnQuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZERyb3Bkb3duKGNvbmZpZ3VyZTogKGNvbXBvbmVudDogRHJvcGRvd25Db21wb25lbnQpID0+IHZvaWQpOiBFZGl0YWJsZURhdGFWaWV3IHtcclxuICAgICAgICBjb25zdCBkcm9wZG93bkNvbXBvbmVudCA9IG5ldyBEcm9wZG93bkNvbXBvbmVudCh0aGlzLmNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uZmlndXJlKGRyb3Bkb3duQ29tcG9uZW50KTtcclxuICAgICAgICBkcm9wZG93bkNvbXBvbmVudC5maW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZHJvcGRvd25Db21wb25lbnQuY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgc2V0SWNvbiB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgTG5nIGZyb20gXCJzcmMvY2xhc3Nlcy9MbmdcIjtcclxuaW1wb3J0IEVkaXRhYmxlRGF0YVZpZXcgZnJvbSBcInNyYy9saWJzL0VkaXRhYmxlRGF0YVZpZXcvRWRpdGFibGVEYXRhVmlld1wiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCJzcmMvbGlicy9IZWxwZXJcIjtcclxuaW1wb3J0IHsgRmlsZVR5cGUgfSBmcm9tIFwic3JjL3R5cGVzL1ByalR5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW5lcmFsQ29tcG9uZW50cyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbGluayB0byB0aGUgZmlsZSBhdCBgcGF0aGAgd2l0aCB0aGUgYGNvcm9zcG9uZGluZ1N5bWJvbGAgYXMgaWNvbi5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgVGhlIGNvbnRhaW5lciB0byBhcHBlbmQgdGhlIGxpbmsgdG8uXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXIgdGhlIGV2ZW50cyB0by5cclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gY29yb3Nwb25kaW5nU3ltYm9sIFRoZSBjb3Jvc3BvbmRpbmcgc3ltYm9sIGZvciB0aGUgZmlsZSB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZU1ldGFkYXRhTGluayhcclxuICAgICAgICBjb250YWluZXI6IERvY3VtZW50RnJhZ21lbnQsXHJcbiAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnQsXHJcbiAgICAgICAgcGF0aDogc3RyaW5nLFxyXG4gICAgICAgIHR5cGU6IEZpbGVUeXBlIHwgdW5kZWZpbmVkIHwgbnVsbCxcclxuICAgICAgICBjb3Jvc3BvbmRpbmdTeW1ib2w6IHN0cmluZykge1xyXG4gICAgICAgIG5ldyBFZGl0YWJsZURhdGFWaWV3KGNvbnRhaW5lciwgY29tcG9uZW50KVxyXG4gICAgICAgICAgICAuYWRkTGluayhsaW5rID0+IGxpbmtcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShwYXRoKVxyXG4gICAgICAgICAgICAgICAgLnNldFRpdGxlKExuZy5ndCh0eXBlID8/IFwiRmlsZVwiKSlcclxuICAgICAgICAgICAgICAgIC5zZXRMaW5rVHlwZShcImZpbGVcIilcclxuICAgICAgICAgICAgICAgIC5zZXRGb3JtYXRvcigodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvblN0cmluZyA9IGNvcm9zcG9uZGluZ1N5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJY29uKGljb24gYXMgdW5rbm93biBhcyBIVE1MRGl2RWxlbWVudCwgaWNvblN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaHJlZjogYCR7dmFsdWV9YCwgdGV4dDogYCR7dmFsdWV9YCwgaHRtbDogaWNvbiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVDZWxsRGF0ZShcclxuICAgICAgICBkYXRlOiBEb2N1bWVudEZyYWdtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIHRpdGxlOiBzdHJpbmcsXHJcbiAgICAgICAgZm9ybWF0OiBzdHJpbmcsXHJcbiAgICAgICAgb25SZWFkOiAoKSA9PiBzdHJpbmcsXHJcbiAgICAgICAgb25Xcml0ZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBuZXcgRWRpdGFibGVEYXRhVmlldyhkYXRlLCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgIC5hZGREYXRlKGRhdGUgPT4gZGF0ZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKG9uUmVhZCgpKVxyXG4gICAgICAgICAgICAgICAgLnNldFRpdGxlKHRpdGxlKVxyXG4gICAgICAgICAgICAgICAgLmVuYWJsZUVkaXRhYmlsaXR5KClcclxuICAgICAgICAgICAgICAgIC5zZXRGb3JtYXRvcigodmFsdWU6IHN0cmluZykgPT4gSGVscGVyLmZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCkpXHJcbiAgICAgICAgICAgICAgICAub25TYXZlKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Xcml0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwgImltcG9ydCB7IERvY3VtZW50TW9kZWwgfSBmcm9tIFwic3JjL21vZGVscy9Eb2N1bWVudE1vZGVsXCI7XHJcbmltcG9ydCBUYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50IGZyb20gXCIuL1RhYmxlQmxvY2tSZW5kZXJDb21wb25lbnRcIjtcclxuaW1wb3J0IHsgSVByb2Nlc3NvclNldHRpbmdzIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvSVByb2Nlc3NvclNldHRpbmdzXCI7XHJcbmltcG9ydCBTZWFyY2gsIHsgU2VhcmNoVGVybXNBcnJheSB9IGZyb20gXCIuLi9TZWFyY2hcIjtcclxuaW1wb3J0IFRhYmxlLCB7IFJvdywgUm93c1N0YXRlLCBUYWJsZUhlYWRlciB9IGZyb20gXCIuLi9UYWJsZVwiO1xyXG5pbXBvcnQgTG5nIGZyb20gXCJzcmMvY2xhc3Nlcy9MbmdcIjtcclxuaW1wb3J0IEZpbHRlckJ1dHRvbiBmcm9tIFwiLi9Jbm5lckNvbXBvbmVudHMvRmlsdGVyQnV0dG9uXCI7XHJcbmltcG9ydCBNYXhTaG93bk1vZGVsc0lucHV0IGZyb20gXCIuL0lubmVyQ29tcG9uZW50cy9NYXhTaG93bk1vZGVsc0lucHV0XCI7XHJcbmltcG9ydCBTZWFyY2hJbnB1dCBmcm9tIFwiLi9Jbm5lckNvbXBvbmVudHMvU2VhcmNoSW5wdXRcIjtcclxuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi4vSGVscGVyXCI7XHJcbmltcG9ydCBEb2N1bWVudENvbXBvbmVudHMgZnJvbSBcIi4vSW5uZXJDb21wb25lbnRzL0RvY3VtZW50Q29tcG9uZW50c1wiO1xyXG5pbXBvcnQgR2VuZXJhbENvbXBvbmVudHMgZnJvbSBcIi4vSW5uZXJDb21wb25lbnRzL0dlbmVyYWxDb21wb25lbnRzXCI7XHJcblxyXG4vKipcclxuICogRG9jdW1lbnQgYmxvY2sgcmVuZGVyIGNvbXBvbmVudCBjbGFzcyBmb3IgYFRhYmxlQmxvY2tSZW5kZXJDb21wb25lbnRgLlxyXG4gKiBAcmVtYXJrcyBUaGlzIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgYSBkb2N1bWVudCBibG9jayByZW5kZXIgY29tcG9uZW50LlxyXG4gKiBAc2VlIHtAbGluayBjcmVhdGV9IGZvciBkZXRhaWxzIGFib3V0IGNyZWF0aW5nIGEgZG9jdW1lbnQgYmxvY2sgcmVuZGVyIGNvbXBvbmVudC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50QmxvY2tSZW5kZXJDb21wb25lbnQgZXh0ZW5kcyBUYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50PERvY3VtZW50TW9kZWw+IHtcclxuICAgIHByb3RlY3RlZCBzZXR0aW5nczogRG9jdW1lbnRCbG9ja1JlbmRlclNldHRpbmdzID0ge1xyXG4gICAgICAgIHRhZ3M6IFtdLFxyXG4gICAgICAgIGRvY1N5bWJvbDogdGhpcy5nbG9iYWwuc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5zeW1ib2wsXHJcbiAgICAgICAgaGlkZURvY1N5bWJvbDogdGhpcy5nbG9iYWwuc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5oaWRlU3ltYm9sLFxyXG4gICAgICAgIGNsdXN0ZXJTeW1ib2w6IHRoaXMuZ2xvYmFsLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3MuY2x1c3RlclN5bWJvbCxcclxuICAgICAgICBub25lRG9jU3ltYm9sOiBcImRpYW1vbmRcIixcclxuICAgICAgICBmaWx0ZXI6IFtcIkRvY3VtZW50c1wiXSxcclxuICAgICAgICBtYXhEb2N1bWVudHM6IHRoaXMuZ2xvYmFsLnNldHRpbmdzLmRlZmF1bHRNYXhTaG93LFxyXG4gICAgICAgIHNlYXJjaDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGJhdGNoU2l6ZTogOCxcclxuICAgICAgICBzbGVlcEJldHdlZW5CYXRjaGVzOiAxMFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YWJsZSBoZWFkZXJzLlxyXG4gICAgICogQHJlbWFya3MgVGhlIHRhYmxlIGhlYWRlcnMgYXJlIHVzZWQgdG8gY3JlYXRlIHRoZSB0YWJsZS5cclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdGFibGVIZWFkZXJzOiBUYWJsZUhlYWRlcltdID0gW1xyXG4gICAgICAgIHsgdGV4dDogTG5nLmd0KFwiRG9jdW1lbnRUeXBlXCIpLCBoZWFkZXJDbGFzczogW10sIGNvbHVtbkNsYXNzOiBbXCJkb250LWRlY29yYXRlLWxpbmtcIiwgXCJmb250LW1lZGl1bVwiXSB9LFxyXG4gICAgICAgIHsgdGV4dDogTG5nLmd0KFwiRGF0ZVwiKSwgaGVhZGVyQ2xhc3M6IFtdLCBjb2x1bW5DbGFzczogW1wiZm9udC14c21hbGxcIl0gfSxcclxuICAgICAgICB7IHRleHQ6IExuZy5ndChcIlN1YmplY3RcIiksIGhlYWRlckNsYXNzOiBbXSwgY29sdW1uQ2xhc3M6IFtdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJTZW5kUmVjaXBcIiksIGhlYWRlckNsYXNzOiBbXSwgY29sdW1uQ2xhc3M6IFtcImZvbnQteHNtYWxsXCJdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJDb250ZW50XCIpLCBoZWFkZXJDbGFzczogW10sIGNvbHVtbkNsYXNzOiBbXCJmb250LXhzbWFsbFwiXSB9LFxyXG4gICAgICAgIHsgdGV4dDogTG5nLmd0KFwiRGVsaXZlcnlEYXRlXCIpLCBoZWFkZXJDbGFzczogW10sIGNvbHVtbkNsYXNzOiBbXCJmb250LXhzbWFsbFwiXSB9LFxyXG4gICAgICAgIHsgdGV4dDogTG5nLmd0KFwiVGFnc1wiKSwgaGVhZGVyQ2xhc3M6IFtdLCBjb2x1bW5DbGFzczogW1widGFnc1wiXSB9XHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJUHJvY2Vzc29yU2V0dGluZ3MpIHtcclxuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgdGhpcy5wYXJzZVNldHRpbmdzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJ1aWxkKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5idWlsZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGNvbXBvbmVudCBhbmQgYWRkcyB0aGUgZG9jdW1lbnRzIHRvIHRoZSB0YWJsZS5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIHRoZSBkb2N1bWVudHMgYXJlIGFkZGVkIHRvIHRoZSB0YWJsZS5cclxuICAgICAqIEByZW1hcmtzIC0gQ2FsbHMgdGhlIGBzdXBlci5kcmF3YCBtZXRob2QuXHJcbiAgICAgKiAtIENhbGxzIHRoZSBgYnVpbGRUYWJsZWAgbWV0aG9kLlxyXG4gICAgICogLSBDYWxscyB0aGUgYGJ1aWxkSGVhZGVyYCBtZXRob2QuXHJcbiAgICAgKiAtIENhbGxzIHRoZSBgYWRkRG9jdW1lbnRzVG9UYWJsZWAgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgZHJhdygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICBjb25zdCBkb2N1bWVudHNQcm9taXNlID0gdGhpcy5nZXRNb2RlbHMoKTtcclxuICAgICAgICBhd2FpdCBzdXBlci5kcmF3KCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZFRhYmxlKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZEhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMuZ3JheU91dEhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMubW9kZWxzID0gKGF3YWl0IGRvY3VtZW50c1Byb21pc2UpO1xyXG5cclxuICAgICAgICBEb2N1bWVudE1vZGVsLnNvcnREb2N1bWVudHNCeURhdGVEZXNjKHRoaXMubW9kZWxzKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmFkZERvY3VtZW50c1RvVGFibGUoKTtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZUhlYWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBSZWRyYXcgRG9jdW1lbnRzIChmb3IgJHt0aGlzLm1vZGVscy5sZW5ndGh9IERvY3MuKSBydW5zIGZvciAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgaGVhZGVyLlxyXG4gICAgICogQHJlbWFya3MgLSBUaGUgaGVhZGVyIGlzIHNhdmVkIGluIHRoZSBgaGVhZGVyQ29udGFpbmVyYCBwcm9wZXJ0eS5cclxuICAgICAqIC0gQ3JlYXRlcyB0aGUgYGZpbHRlciBjb250YWluZXJgLlxyXG4gICAgICogLSBDcmVhdGVzIHRoZSBgZmlsdGVyIGxhYmVsYC5cclxuICAgICAqIC0gQ3JlYXRlcyB0aGUgYGZpbHRlciBidXR0b25zYDogYERvY3VtZW50c2AsIGBIaWRlRG9jdW1lbnRzYCBhbmQgYENsdXN0ZXJgLlxyXG4gICAgICogLSBDcmVhdGVzIHRoZSBgbWF4IGRvY3VtZW50cyBpbnB1dGAuXHJcbiAgICAgKiAtIENyZWF0ZXMgdGhlIGBzZWFyY2ggYm94YC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZEhlYWRlcigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBGaWx0ZXIgY29udGFpbmVyXHJcbiAgICAgICAgY29uc3QgaGVhZGVyRmlsdGVyQnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWRlckZpbHRlckJ1dHRvbnMpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuY2xhc3NMaXN0LmFkZCgnaGVhZGVyLWl0ZW0nKTtcclxuICAgICAgICBoZWFkZXJGaWx0ZXJCdXR0b25zLmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1zeW1ib2xzJyk7XHJcblxyXG4gICAgICAgIC8vIEZpbHRlciBsYWJlbFxyXG4gICAgICAgIGNvbnN0IGZpbHRlckxhYmVsQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5hcHBlbmRDaGlsZChmaWx0ZXJMYWJlbENvbnRhaW5lcik7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgZmlsdGVyTGFiZWxDb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsdGVyTGFiZWwpO1xyXG4gICAgICAgIGZpbHRlckxhYmVsLmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1zeW1ib2wnKTtcclxuICAgICAgICBmaWx0ZXJMYWJlbC50ZXh0Q29udGVudCA9IExuZy5ndChcIkZpbHRlclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRGaWx0ZXJCdXR0b24gPSBGaWx0ZXJCdXR0b24uY3JlYXRlKFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgXCJEb2N1bWVudHNcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kb2NTeW1ib2wsXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZmlsdGVyLmluY2x1ZGVzKFwiRG9jdW1lbnRzXCIpLFxyXG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyQnV0dG9uLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGaWx0ZXJCdXR0b24pO1xyXG5cclxuICAgICAgICBjb25zdCBoaWRlRG9jdW1lbnRGaWx0ZXJCdXR0b24gPSBGaWx0ZXJCdXR0b24uY3JlYXRlKFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgXCJIaWRlRG9jdW1lbnRzXCIsXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaGlkZURvY1N5bWJvbCxcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXIuaW5jbHVkZXMoXCJIaWRlRG9jdW1lbnRzXCIpLFxyXG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyQnV0dG9uLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQoaGlkZURvY3VtZW50RmlsdGVyQnV0dG9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2x1c3RlckZpbHRlckJ1dHRvbiA9IEZpbHRlckJ1dHRvbi5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBcIkNsdXN0ZXJcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jbHVzdGVyU3ltYm9sLFxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyhcIkNsdXN0ZXJcIiksXHJcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJCdXR0b24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5hcHBlbmRDaGlsZChjbHVzdGVyRmlsdGVyQnV0dG9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4RG9jdW1lbnRzID0gTWF4U2hvd25Nb2RlbHNJbnB1dC5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1heERvY3VtZW50cyxcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWwuc2V0dGluZ3MuZGVmYXVsdE1heFNob3csXHJcbiAgICAgICAgICAgIHRoaXMub25NYXhEb2N1bWVudHNDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5hcHBlbmRDaGlsZChtYXhEb2N1bWVudHMpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hCb3ggPSBTZWFyY2hJbnB1dC5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VhcmNoLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQoc2VhcmNoQm94KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBmaWx0ZXIgYnV0dG9uIGlzIGNsaWNrZWQuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZmlsdGVyIGJ1dHRvbi5cclxuICAgICAqIEBwYXJhbSBzdGF0dXMgVGhlIG5ldyBzdGF0dXMgb2YgdGhlIGZpbHRlciBidXR0b24uXHJcbiAgICAgKiBAcmVtYXJrcyBSdW5zIHRoZSBgb25GaWx0ZXJgIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBvbkZpbHRlckJ1dHRvbih0eXBlOiBzdHJpbmcsIHN0YXR1czogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyh0eXBlIGFzIEZpbHRlcmVkRG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZmlsdGVyID0gdGhpcy5zZXR0aW5ncy5maWx0ZXIuZmlsdGVyKHYgPT4gdiAhPT0gdHlwZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXIucHVzaCh0eXBlIGFzIEZpbHRlcmVkRG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uRmlsdGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgbWF4IGRvY3VtZW50cyBpbnB1dCBpcyBjaGFuZ2VkLlxyXG4gICAgICogQHBhcmFtIG1heERvY3VtZW50cyBUaGUgbmV3IG1heCBkb2N1bWVudHMgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWQgd2hlbiB0aGUgZG9jdW1lbnRzIGFyZSBmaWx0ZXJlZC5cclxuICAgICAqIEByZW1hcmtzIFJ1bnMgdGhlIGBvbkZpbHRlcmAgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uTWF4RG9jdW1lbnRzQ2hhbmdlKG1heERvY3VtZW50czogbnVtYmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzLm1heERvY3VtZW50cyA9IG1heERvY3VtZW50cztcclxuICAgICAgICB0aGlzLm9uRmlsdGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBzZWFyY2ggYm94IGlzIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0gc2VhcmNoIFRoZSBzZWFyY2ggdGV4dC5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0aGF0IHdhcyBwcmVzc2VkLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNlYXJjaCB0ZXh0LlxyXG4gICAgICogQHJlbWFya3MgLSBJZiB0aGUgYEVudGVyYCBrZXkgd2FzIHByZXNzZWQsIHRoZSBzZWFyY2ggaXMgYXBwbGllZC5cclxuICAgICAqIC0gSWYgdGhlIGBFc2NhcGVgIGtleSB3YXMgcHJlc3NlZCwgdGhlIHNlYXJjaCBpcyByZXNldC5cclxuICAgICAqIC0gQWZ0ZXIgdGhlIHNlYXJjaCBpcyBhcHBsaWVkLCB0aGUgYG9uRmlsdGVyYCBtZXRob2QgaXMgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uU2VhcmNoKHNlYXJjaDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2ggIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2VhcmNoID0gU2VhcmNoLnBhcnNlU2VhcmNoVGV4dChzZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkZpbHRlcigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zZWFyY2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJFc2NhcGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNlYXJjaCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbkZpbHRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlcnMgdGhlIGRvY3VtZW50cyBhbmQgc2hvd3MvaGlkZXMgdGhlbSBpbiB0aGUgdGFibGUuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBkb2N1bWVudHMgYXJlIGZpbHRlcmVkIGJ5IHRoZSBgZmlsdGVyYCBzZXR0aW5nLFxyXG4gICAgICogc2VhcmNoZWQgYnkgdGhlIGBzZWFyY2hgIHNldHRpbmcgXHJcbiAgICAgKiBhbmQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaXMgbGltaXRlZCBieSB0aGUgYG1heERvY3VtZW50c2AgaWYgbm8gc2VhcmNoIGlzIGFwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgb25GaWx0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5ncmF5T3V0SGVhZGVyKCk7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hTaXplID0gdGhpcy5zZXR0aW5ncy5iYXRjaFNpemU7XHJcbiAgICAgICAgY29uc3Qgc2xlZXBCZXR3ZWVuQmF0Y2hlcyA9IHRoaXMuc2V0dGluZ3Muc2xlZXBCZXR3ZWVuQmF0Y2hlcztcclxuICAgICAgICBsZXQgc2xlZXBQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzTGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJvd3M6IFJvd3NTdGF0ZVtdID0gW107XHJcbiAgICAgICAgbGV0IHZpc2libGVSb3dzID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHRoaXMubW9kZWxzW2ldO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgcm93VWlkID0gdGhpcy5nZXRVSUQoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBsZXQgaGlkZSA9IHRoaXMuZ2V0SGlkZVN0YXRlKGRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgRG9jdW1lbnQgJHtyb3dVaWR9IGlzIGhpZGRlbiBieSBzdGF0ZTogJHtoaWRlfWApO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgVmlzaWJsZSByb3dzOiAke3Zpc2libGVSb3dzfTsgTWF4IHNob3duIERvY3M6ICR7dGhpcy5zZXR0aW5ncy5tYXhEb2N1bWVudHN9YCk7XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlUm93cyA+PSB0aGlzLnNldHRpbmdzLm1heERvY3VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgaGlkZSA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgRG9jdW1lbnQgJHtyb3dVaWR9IGlzIGhpZGRlbiBieSBtYXggY291bnRzOiAke2hpZGV9YCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGlkZSkge1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHsgcm93VWlkLCBoaWRkZW46IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUm93cysrO1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHsgcm93VWlkLCBoaWRkZW46IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKGkgIT09IDAgJiYgaSAlIGJhdGNoU2l6ZSA9PT0gMCkgfHwgaSA9PT0gZG9jdW1lbnRzTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXBQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYEJhdGNoc2l6ZSByZWFjaGVkLiBDaGFuZ2Ugcm93czogJHtyb3dzLmxlbmd0aH1gKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudGFibGUuY2hhbmdlU2hvd0hpZGVTdGF0ZVJvd3Mocm93cyk7XHJcbiAgICAgICAgICAgICAgICByb3dzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBzbGVlcFByb21pc2UgPSBIZWxwZXIuc2xlZXAoc2xlZXBCZXR3ZWVuQmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubm9ybWFsaXplSGVhZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBkb2N1bWVudHMgdG8gdGhlIHRhYmxlLlxyXG4gICAgICogQHBhcmFtIGJhdGNoU2l6ZSBUaGUgYmF0Y2ggc2l6ZS5cclxuICAgICAqIEBwYXJhbSBzbGVlcEJldHdlZW5CYXRjaGVzIFRoZSBzbGVlcCB0aW1lIGJldHdlZW4gdGhlIGJhdGNoZXMuXHJcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWQgd2hlbiB0aGUgZG9jdW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgdGFibGUuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSBkb2N1bWVudHMgYXJlIGFkZGVkIHRvIHRoZSB0YWJsZSBpbiBiYXRjaGVzLlxyXG4gICAgICogLSBUaGUgYmF0Y2ggc2l6ZSBpcyBkZWZpbmVkIGluIHRoZSBgYmF0Y2hTaXplYCBwYXJhbWV0ZXIuIERlZmF1bHQgaXMgYHNldHRpbmdzLmJhdGNoU2l6ZWAuXHJcbiAgICAgKiAtIFRoZSBzbGVlcCB0aW1lIGJldHdlZW4gdGhlIGJhdGNoZXMgaXMgZGVmaW5lZCBpbiB0aGUgYHNsZWVwQmV0d2VlbkJhdGNoZXNgIHBhcmFtZXRlci4gRGVmYXVsdCBpcyBgc2V0dGluZ3Muc2xlZXBCZXR3ZWVuQmF0Y2hlc2AuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgYWRkRG9jdW1lbnRzVG9UYWJsZShiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzLmJhdGNoU2l6ZSwgc2xlZXBCZXR3ZWVuQmF0Y2hlcyA9IHRoaXMuc2V0dGluZ3Muc2xlZXBCZXR3ZWVuQmF0Y2hlcyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGxldCBzbGVlcFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICBjb25zdCBkb2N1bWVudHNMZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgcm93czogUm93W10gPSBbXTtcclxuICAgICAgICBsZXQgcm93UHJvbWlzZTogUHJvbWlzZTxSb3c+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBpZiAoZG9jdW1lbnRzTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByb3dQcm9taXNlID0gdGhpcy5nZW5lcmF0ZVRhYmxlUm93KHRoaXMubW9kZWxzWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdmlzaWJsZVJvd3MgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3VtZW50c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gaSArIDEgPCBkb2N1bWVudHNMZW5ndGggPyB0aGlzLm1vZGVsc1tpICsgMV0gOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgcm93ID0gYXdhaXQgcm93UHJvbWlzZTtcclxuICAgICAgICAgICAgcm93UHJvbWlzZSA9IGRvY3VtZW50ID8gdGhpcy5nZW5lcmF0ZVRhYmxlUm93KGRvY3VtZW50KSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cgJiYgIXJvdy5oaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlUm93cyA8IHRoaXMuc2V0dGluZ3MubWF4RG9jdW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVJvd3MrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3cpXHJcbiAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoaSAhPT0gMCAmJiBpICUgYmF0Y2hTaXplID09PSAwKSB8fCBpID09PSBkb2N1bWVudHNMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcFByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlLmFkZFJvd3Mocm93cyk7XHJcbiAgICAgICAgICAgICAgICByb3dzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBzbGVlcFByb21pc2UgPSBIZWxwZXIuc2xlZXAoc2xlZXBCZXR3ZWVuQmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSB0YWJsZSByb3cgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudE1vZGVsIFRoZSBkb2N1bWVudCB0byBnZW5lcmF0ZSB0aGUgdGFibGUgcm93IGZvci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGFibGUgcm93LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVGFibGVSb3coZG9jdW1lbnRNb2RlbDogRG9jdW1lbnRNb2RlbCk6IFByb21pc2U8Um93PiB7XHJcbiAgICAgICAgY29uc3Qgcm93Q2xhc3NMaXN0OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJvd0RhdGE6IERvY3VtZW50RnJhZ21lbnRbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJvd1VpZCA9IHRoaXMuZ2V0VUlEKGRvY3VtZW50TW9kZWwpO1xyXG5cclxuICAgICAgICAvLyBSb3cgMCAtLSBNZXRhZGF0YSBMaW5rXHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFMaW5rID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIHJvd0RhdGEucHVzaChtZXRhZGF0YUxpbmspO1xyXG4gICAgICAgIERvY3VtZW50Q29tcG9uZW50cy5jcmVhdGVDZWxsTWV0YWRhdGFsaW5rKFxyXG4gICAgICAgICAgICBtZXRhZGF0YUxpbmssXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBkb2N1bWVudE1vZGVsKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDEgLS0gRGF0ZVxyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKGRhdGUpO1xyXG4gICAgICAgIEdlbmVyYWxDb21wb25lbnRzLmNyZWF0ZUNlbGxEYXRlKFxyXG4gICAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgTG5nLmd0KFwiRG9jdW1lbnREYXRlXCIpLFxyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbC5zZXR0aW5ncy5kYXRlRm9ybWF0LFxyXG4gICAgICAgICAgICAoKSA9PiBkb2N1bWVudE1vZGVsLmRhdGEuZGF0ZSA/PyBcIm5hXCIsXHJcbiAgICAgICAgICAgIGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiBkb2N1bWVudE1vZGVsLmRhdGEuZGF0ZSA9IHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDIgLS0gRmlsZSBMaW5rXHJcbiAgICAgICAgY29uc3QgZmlsZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKGZpbGVMaW5rKTtcclxuICAgICAgICBEb2N1bWVudENvbXBvbmVudHMuY3JlYXRlQ2VsbEZpbGVMaW5rKFxyXG4gICAgICAgICAgICBmaWxlTGluayxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIGRvY3VtZW50TW9kZWwpO1xyXG5cclxuICAgICAgICAvLyBSb3cgMyAtLSBTZW5kZXIgUmVjaXBpZW50XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyUmVjaXBpZW50ID0gRG9jdW1lbnRDb21wb25lbnRzLmNyZWF0ZUNlbGxTZW5kZXJSZWNpcGllbnQoXHJcbiAgICAgICAgICAgIGRvY3VtZW50TW9kZWwsXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICB0aGlzLm1vZGVscyk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKHNlbmRlclJlY2lwaWVudCk7XHJcblxyXG4gICAgICAgIC8vIFJvdyA0IC0tIFN1bW1hcnkgJiBSZWxhdGVkIEZpbGVzXHJcbiAgICAgICAgY29uc3Qgc3VtbWFyeVJlbGF0ZWRGaWxlcyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICByb3dEYXRhLnB1c2goc3VtbWFyeVJlbGF0ZWRGaWxlcyk7XHJcbiAgICAgICAgRG9jdW1lbnRDb21wb25lbnRzLmNyZWF0ZUNlbGxTdW1tYXJ5KFxyXG4gICAgICAgICAgICBkb2N1bWVudE1vZGVsLFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgc3VtbWFyeVJlbGF0ZWRGaWxlcyk7XHJcbiAgICAgICAgRG9jdW1lbnRDb21wb25lbnRzLmNyZWF0ZVJlbGF0ZWRGaWxlc0xpc3QoXHJcbiAgICAgICAgICAgIHN1bW1hcnlSZWxhdGVkRmlsZXMsXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBkb2N1bWVudE1vZGVsLFxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLm5vbmVEb2NTeW1ib2wsXHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsLnNldHRpbmdzLmRhdGVGb3JtYXRTaG9ydCk7XHJcblxyXG4gICAgICAgIC8vIFJvdyA1IC0tIERhdGUgb2YgZGVsaXZlcnlcclxuICAgICAgICBjb25zdCBkZWxpdmVyeURhdGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKGRlbGl2ZXJ5RGF0ZSk7XHJcbiAgICAgICAgR2VuZXJhbENvbXBvbmVudHMuY3JlYXRlQ2VsbERhdGUoXHJcbiAgICAgICAgICAgIGRlbGl2ZXJ5RGF0ZSxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIExuZy5ndChcIkRlbGl2ZXJ5RGF0ZVwiKSxcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWwuc2V0dGluZ3MuZGF0ZUZvcm1hdCxcclxuICAgICAgICAgICAgKCkgPT4gZG9jdW1lbnRNb2RlbC5kYXRhLmRhdGVPZkRlbGl2ZXJ5ID8/IFwibmFcIixcclxuICAgICAgICAgICAgYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IGRvY3VtZW50TW9kZWwuZGF0YS5kYXRlT2ZEZWxpdmVyeSA9IHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDYgLS0gVGFnc1xyXG4gICAgICAgIGNvbnN0IHRhZ3MgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKHRhZ3MpO1xyXG4gICAgICAgIERvY3VtZW50Q29tcG9uZW50cy5jcmVhdGVDZWxsVGFncyhcclxuICAgICAgICAgICAgdGFncyxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIGRvY3VtZW50TW9kZWwuZ2V0VGFncygpKTtcclxuXHJcbiAgICAgICAgY29uc3QgaGlkZSA9IHRoaXMuZ2V0SGlkZVN0YXRlKGRvY3VtZW50TW9kZWwsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdyA9IHtcclxuICAgICAgICAgICAgcm93VWlkLFxyXG4gICAgICAgICAgICByb3dEYXRhLFxyXG4gICAgICAgICAgICByb3dDbGFzc0xpc3QsXHJcbiAgICAgICAgICAgIGhpZGRlbjogaGlkZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJvdztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEhpZGVTdGF0ZShkb2N1bWVudDogRG9jdW1lbnRNb2RlbCwgbWF4VmlzaWJsZVJvd3M6IG51bWJlciB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBzZWFyY2hSZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgbWF4Um93cyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWFyY2gpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHNlYXJjaFJlc3VsdCA9IFNlYXJjaC5hcHBseVNlYXJjaExvZ2ljKHRoaXMuc2V0dGluZ3Muc2VhcmNoLCB0ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXhWaXNpYmxlUm93cyAmJiBtYXhWaXNpYmxlUm93cyA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgcm93U3RhdHMgPSB0aGlzLnRhYmxlLmdldFJvd1N0YXRzKCk7XHJcbiAgICAgICAgICAgIG1heFJvd3MgPSByb3dTdGF0cy52aXNpYmxlUm93cyA+PSBtYXhWaXNpYmxlUm93cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGhpZGUgPSB0aGlzLmRldGVybWluZUhpZGVTdGF0ZShkb2N1bWVudCk7XHJcblxyXG4gICAgICAgIGlmIChzZWFyY2hSZXN1bHQgJiYgIWhpZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTaG93cyB0aGUgZG9jdW1lbnQsIGlmIGl0IGlzIG5vdCBoaWRkZW4gYW5kIHRoZSBzZWFyY2ggd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc2VhcmNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBIaWRlIHRoZSBkb2N1bWVudCwgaWYgdGhlIHNlYXJjaCB3YXMgbm90IHN1Y2Nlc3NmdWwgYW5kIGFwbGljYWJsZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIXNlYXJjaFJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4Um93cyB8fCBoaWRlOyAvLyBFbHNlIHRoZSBkb2N1bWVudCBpcyBoaWRkZW4sIGlmIHRoZSBtYXggcm93cyBhcmUgcmVhY2hlZCBvciB0aGUgZG9jdW1lbnQgdHlwZSBpcyBoaWRkZW5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBoaWRlOyAvLyBTdGFuZGFyZC1WZXJoYWx0ZW5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGRvY3VtZW50IHNob3VsZCBiZSBoaWRkZW4uXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMgSWYgdGhlIGRvY3VtZW50IHNob3VsZCBiZSBoaWRkZW4gcmV0dXJucyBgdHJ1ZWAsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEByZW1hcmtzIC0gVGhlIGRvY3VtZW50IGlzIGhpZGRlbiBpZiB0aGUgYGZpbHRlcmAgc2V0dGluZyBub3QgaW5jbHVkZXMgdGhlIGRvY3VtZW50IHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGV0ZXJtaW5lSGlkZVN0YXRlKGRvY3VtZW50OiBEb2N1bWVudE1vZGVsKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZmlsdGVyLmluY2x1ZGVzKFwiRG9jdW1lbnRzXCIpICYmIGRvY3VtZW50LmRhdGEuaGlkZSAhPT0gdHJ1ZSAmJiBkb2N1bWVudC5kYXRhLnN1YlR5cGUgIT09IFwiQ2x1c3RlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZmlsdGVyLmluY2x1ZGVzKFwiQ2x1c3RlclwiKSAmJiBkb2N1bWVudC5kYXRhLnN1YlR5cGUgPT09IFwiQ2x1c3RlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZmlsdGVyLmluY2x1ZGVzKFwiSGlkZURvY3VtZW50c1wiKSAmJiBkb2N1bWVudC5kYXRhLmhpZGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyB0aGUgdGFibGUuXHJcbiAgICAgKiBAcmVtYXJrcyAtIFRoZSB0YWJsZSBpcyBzYXZlZCBpbiB0aGUgYHRhYmxlYCBwcm9wZXJ0eS5cclxuICAgICAqIC0gVGhlIHRhYmxlIGlzIGFwcGVuZGVkIHRvIHRoZSBgdGFibGVDb250YWluZXJgLlxyXG4gICAgICogLSBUaGUgdGFibGUgaGFzIHRoZSBDU1MgY2xhc3MgYGRvY3VtZW50LXRhYmxlYC5cclxuICAgICAqIC0gVGhlIHRhYmxlIGhhcyB0aGUgaGVhZGVycyBmcm9tIHRoZSBgdGFibGVIZWFkZXJzYCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZFRhYmxlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMudGFibGUgPSBuZXcgVGFibGUodGhpcy50YWJsZUhlYWRlcnMsIFwiZG9jdW1lbnQtdGFibGVcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGFibGUuZGF0YS50YWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZHJhdygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gc3VwZXIucmVkcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIHNldHRpbmdzIGdpdmVuIGJ5IHRoZSB1c2VyIHBlciBZQU1MIGluIGNvZGUgYmxvY2suXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgc2V0dGluZ3MgYXJlIHBhcnNlZCBhbmQgc2F2ZWQgaW4gdGhlIGBzZXR0aW5nc2AgcHJvcGVydHkuXHJcbiAgICAgKiBAcmVtYXJrcyBTZXR0aW5nczpcclxuICAgICAqIC0gYHRhZ3NgOiBDYW4gYmUgYGFsbGAsIGB0aGlzYCBvciBhIGxpc3Qgb2YgdGFncy5cclxuICAgICAqIGB0aGlzYCBtZWFucyB0aGUgdGFncyBvZiB0aGUgY3VycmVudCBkb2N1bWVudC5cclxuICAgICAqIC0gYG1heERvY3VtZW50c2A6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdG8gc2hvdyBvbiBzYW1lIHRpbWUuXHJcbiAgICAgKiAtIGBmaWx0ZXJgOiBNdXN0IGJlIGFuIGFycmF5LiBZb3UgY2FuIGFkZCB0aGUgZm9sbG93aW5nIHZhbHVlczpcclxuICAgICAqIGBEb2N1bWVudHNgLCBgSGlkZURvY3VtZW50c2Agb3IgYENsdXN0ZXJgLiBUaGUgdmFsdWVzIHByZXNlbnQgdGhlIGRvY3VtZW50IHR5cGVzLlxyXG4gICAgICogQWxsIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgYXJyYXkgYXJlIHNob3duLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyc2VTZXR0aW5ncygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NvclNldHRpbmdzLm9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRhZ3NcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSBcImFsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudGFncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLnZhbHVlID09PSBcInRoaXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5wcm9jZXNzb3JTZXR0aW5ncz8uZnJvbnRtYXR0ZXI/LnRhZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnRhZ3MucHVzaCguLi50YWdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnRhZ3MucHVzaCh0YWdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudGFncyA9IG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF4RG9jdW1lbnRzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tYXhEb2N1bWVudHMgPSBvcHRpb24udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXIgPSBvcHRpb24udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb2RlbHMgZm9yIHRoZSB0YWJsZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtb2RlbHMgZm9yIHRoZSB0YWJsZS5cclxuICAgICAqIEByZW1hcmtzIC0gVGhlIG1vZGVscyBhcmUgdGhlIGRvY3VtZW50cy5cclxuICAgICAqIC0gVGhlIGRvY3VtZW50cyBhcmUgZmlsdGVyZWQgYnkgdGhlIGB0YWdzYCBzZXR0aW5nLiBcclxuICAgICAqIElmIHRhZ3MgYXJlIGVtcHR5LCBhbGwgZG9jdW1lbnRzIGFyZSByZXR1cm5lZCwgXHJcbiAgICAgKiBlbHNlIG9ubHkgdGhlIGRvY3VtZW50cyB3aXRoIHRoZSB0YWdzIGFyZSByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFzeW5jIGdldE1vZGVscygpOiBQcm9taXNlPERvY3VtZW50TW9kZWxbXT4ge1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlRm9sZGVyID0gdGhpcy5nbG9iYWwuc2V0dGluZ3MudGVtcGxhdGVGb2xkZXI7XHJcbiAgICAgICAgY29uc3QgYWxsRG9jdW1lbnRGaWxlcyA9IHRoaXMubWV0YWRhdGFDYWNoZS5maWx0ZXIoZmlsZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRGaWx0ZXIgPSBmaWxlLm1ldGFkYXRhLmZyb250bWF0dGVyPy50eXBlID09PSBcIk1ldGFkYXRhXCIgJiZcclxuICAgICAgICAgICAgICAgIGZpbGUuZmlsZS5wYXRoICE9PSB0aGlzLnByb2Nlc3NvclNldHRpbmdzLnNvdXJjZSAmJlxyXG4gICAgICAgICAgICAgICAgIWZpbGUuZmlsZS5wYXRoLnN0YXJ0c1dpdGgodGVtcGxhdGVGb2xkZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50YWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0ZpbHRlciA9IEhlbHBlci5pc1RhZ0luY2x1ZGVkKHRoaXMuc2V0dGluZ3MudGFncywgZmlsZS5tZXRhZGF0YS5mcm9udG1hdHRlcj8udGFncyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlciAmJiB0YWdGaWx0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gYWxsRG9jdW1lbnRGaWxlcy5tYXAoZmlsZSA9PiBuZXcgRG9jdW1lbnRNb2RlbChmaWxlLmZpbGUpKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpZiB0aGUgZmlsZSB0YWdzIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2V0dGluZyB0YWdzLlxyXG4gICAgICogQHBhcmFtIGZpbGVUYWdzIFRoZSB0YWdzIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHNldHRpbmdUYWdzIFRoZSB0YWdzIG9mIHRoZSBzZXR0aW5ncy5cclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBmaWxlIHRhZ3MgYXJlIGluY2x1ZGVkIGluIHRoZSBzZXR0aW5nIHRhZ3MuXHJcbiAgICAgKiBAcmVtYXJrcyAtIElmIHRoZSBmaWxlIHRhZ3MgYXJlIGFuIGFycmF5LCBvbmUgdGFnIG11c3QgYmUgaW5jbHVkZWQuXHJcbiAgICAgKiAtIElmIHRoZSBmaWxlIHRhZ3MgYXJlIGEgc3RyaW5nLCB0aGUgc3RyaW5nIG11c3QgYmUgaW5jbHVkZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNUYWdJbmNsdWRlZChmaWxlVGFnczogc3RyaW5nIHwgc3RyaW5nW10sIHNldHRpbmdUYWdzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVUYWdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsZVRhZ3Muc29tZSh0YWcgPT4gc2V0dGluZ1RhZ3MuaW5jbHVkZXModGFnKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdUYWdzLmluY2x1ZGVzKGZpbGVUYWdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHR5cGVzIG9mIGRvY3VtZW50cyB0byBzaG93LlxyXG4gKiBAcmVtYXJrcyAtIGBEb2N1bWVudHNgIC0gU2hvdyBkb2N1bWVudHMuXHJcbiAqIC0gYEhpZGVEb2N1bWVudHNgIC0gU2hvdyBoaWRkZW4gZG9jdW1lbnRzLlxyXG4gKiAtIGBDbHVzdGVyYCAtIFNob3cgY2x1c3RlcnMuXHJcbiAqL1xyXG50eXBlIEZpbHRlcmVkRG9jdW1lbnQgPSBcIkRvY3VtZW50c1wiIHwgXCJIaWRlRG9jdW1lbnRzXCIgfCBcIkNsdXN0ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2V0dGluZ3MgZm9yIHRoZSBkb2N1bWVudCBibG9jayByZW5kZXIgY29tcG9uZW50LlxyXG4gKiBAcmVtYXJrcyBUaGUgc2V0dGluZ3MgYXJlIHBhcnNlZCBmcm9tIHRoZSBZQU1MIG9wdGlvbnMgaW4gdGhlIGNvZGUgYmxvY2suXHJcbiAqL1xyXG50eXBlIERvY3VtZW50QmxvY2tSZW5kZXJTZXR0aW5ncyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBkb2N1bWVudHMuXHJcbiAgICAgKiBDYW4gYmUgYGFsbGAsIGB0aGlzYCBvciBhIGxpc3Qgb2Ygc3BlY2lmaWMgdGFncy5cclxuICAgICAqIGBhbGxgIGluY2x1ZGVzIGFsbCBkb2N1bWVudHMgcmVnYXJkbGVzcyBvZiB0aGVpciB0YWdzLlxyXG4gICAgICogYHRoaXNgIGluY2x1ZGVzIGRvY3VtZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgdGFncyBhcyB0aGUgY3VycmVudCBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgdGFnczogc3RyaW5nW10sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTeW1ib2wgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRvY1N5bWJvbDogc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ltYm9sIHVzZWQgdG8gaW5kaWNhdGUgaGlkZGVuIGRvY3VtZW50cy5cclxuICAgICAqL1xyXG4gICAgaGlkZURvY1N5bWJvbDogc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ltYm9sIHJlcHJlc2VudGluZyBhIGNsdXN0ZXIgb2YgZG9jdW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBjbHVzdGVyU3ltYm9sOiBzdHJpbmcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTeW1ib2wgdXNlZCBmb3IgZG9jdW1lbnRzIHRoYXQgZG9uJ3QgZml0IGFueSBvdGhlciBjYXRlZ29yeS5cclxuICAgICAqL1xyXG4gICAgbm9uZURvY1N5bWJvbDogc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIGZvciB0aGUgZG9jdW1lbnQgdHlwZXMgdG8gZGlzcGxheS5cclxuICAgICAqIE11c3QgYmUgYW4gYXJyYXkgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XHJcbiAgICAgKiBgRG9jdW1lbnRzYCwgYEhpZGVEb2N1bWVudHNgLCBgQ2x1c3RlcmAuXHJcbiAgICAgKiBPbmx5IHRoZSBkb2N1bWVudCB0eXBlcyBsaXN0ZWQgaW4gdGhlIGFycmF5IHdpbGwgYmUgc2hvd24uXHJcbiAgICAgKi9cclxuICAgIGZpbHRlcjogRmlsdGVyZWREb2N1bWVudFtdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGRvY3VtZW50cyB0byBzaG93IGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIG1heERvY3VtZW50czogbnVtYmVyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoIHRlcm1zIGFycmF5IHVzZWQgdG8gZmlsdGVyIHRoZSBkb2N1bWVudHMuXHJcbiAgICAgKiBJZiB1bmRlZmluZWQsIG5vIHNlYXJjaCBmaWx0ZXIgaXMgYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgc2VhcmNoOiBTZWFyY2hUZXJtc0FycmF5IHwgdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcHJvY2VzcyBpbiBvbmUgYmF0Y2guXHJcbiAgICAgKi9cclxuICAgIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbWUgdG8gd2FpdCAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHByb2Nlc3NpbmcgYmF0Y2hlcyBvZiBkb2N1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIHNsZWVwQmV0d2VlbkJhdGNoZXM6IG51bWJlclxyXG59O1xyXG4iLCAiaW1wb3J0IHsgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgQmFzZU1vZGVsIH0gZnJvbSBcIi4vQmFzZU1vZGVsXCI7XHJcbmltcG9ydCBJUHJqTW9kZWwgZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByak1vZGVsXCI7XHJcbmltcG9ydCBJUHJqRGF0YSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9JUHJqRGF0YVwiO1xyXG5pbXBvcnQgSVByalRhc2tNYW5hZ2VtZW50IGZyb20gXCIuLi9pbnRlcmZhY2VzL0lQcmpUYXNrTWFuYWdlbWVudFwiO1xyXG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tIFwic3JjL3R5cGVzL1ByalR5cGVzXCI7XHJcbmltcG9ydCBQcm9qZWN0RGF0YSBmcm9tIFwic3JjL3R5cGVzL1Byb2plY3REYXRhXCI7XHJcbmltcG9ydCBUYXNrRGF0YSBmcm9tIFwic3JjL3R5cGVzL1Rhc2tEYXRhXCI7XHJcbmltcG9ydCBUb3BpY0RhdGEgZnJvbSBcInNyYy90eXBlcy9Ub3BpY0RhdGFcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFQgZXh0ZW5kcyBJUHJqRGF0YSAmIElQcmpUYXNrTWFuYWdlbWVudD4gZXh0ZW5kcyBCYXNlTW9kZWw8VD4gaW1wbGVtZW50cyBJUHJqTW9kZWw8VD4ge1xyXG4gICAgY29uc3RydWN0b3IoZmlsZTogVEZpbGUsIGN0b3I6IG5ldyAoZGF0YT86IFBhcnRpYWw8VD4pID0+IFQpIHtcclxuICAgICAgICBzdXBlcihmaWxlLCBjdG9yLCB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBQYXJ0aWFsPFQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IFBhcnRpYWw8VD4pIHtcclxuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG92ZXJyaWRlIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IGFsbFRleHQgPSB0aGlzLmRhdGEudGl0bGUgPz8gXCJcIjtcclxuICAgICAgICBhbGxUZXh0ICs9IHRoaXMuZGF0YS5kZXNjcmlwdGlvbiA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLnN0YXR1cyA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLmR1ZSA/PyBcIlwiO1xyXG4gICAgICAgIGFsbFRleHQgKz0gdGhpcy5kYXRhLnRhZ3MgPz8gXCJcIjtcclxuICAgICAgICByZXR1cm4gYWxsVGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29yb3Nwb25kaW5nU3ltYm9sKCk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmRhdGEudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdUb3BpYyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWwuc2V0dGluZ3MucHJqU2V0dGluZ3MudG9waWNTeW1ib2w7XHJcbiAgICAgICAgICAgIGNhc2UgJ1Byb2plY3QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnNldHRpbmdzLnByalNldHRpbmdzLnByb2plY3RTeW1ib2w7XHJcbiAgICAgICAgICAgIGNhc2UgJ1Rhc2snOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnNldHRpbmdzLnByalNldHRpbmdzLnRhc2tTeW1ib2w7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3gtY2lyY2xlJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0cyB0aGUgbW9kZWxzIGJ5IHVyZ2VuY3kgZGVzY2VuZGluZ1xyXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudE1vZGVscyB0byBzb3J0XHJcbiAgICAgKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHNvcnRzIHRoZSBhcnJheSBpbiBwbGFjZVxyXG4gICAgICogQHNlZSB7QGxpbmsgc3RhdHVzVG9OdW1iZXJ9XHJcbiAgICAgKiBAc2VlIHtAbGluayBjYWxjdWxhdGVVcmdlbmN5fVxyXG4gICAgICogQHNlZSB7QGxpbmsgZ2V0TGFzdEhpc3RvcnlEYXRlfVxyXG4gICAgICogQHJlbWFya3MgVGhlIHNvcnRpbmcgaXMgZG9uZSBhcyBmb2xsb3dzOlxyXG4gICAgICogLSBJZiBib3RoIGFyZSBgZG9uZWAsIHNvcnQgYnkgbGFzdCBoaXN0b3J5IGVudHJ5XHJcbiAgICAgKiAtIElmIGBhYCBvciBgYmAgaXMgZG9uZSwgc29ydCBpdCBsb3dlclxyXG4gICAgICogLSBCb3RoIGFyZSBub3QgZG9uZSwgc29ydCBieSB1cmdlbmN5XHJcbiAgICAgKiAtIEJvdGggaGF2ZSB0aGUgc2FtZSB1cmdlbmN5LCBzb3J0IGJ5IHN0YXR1c1xyXG4gICAgICogLSBCb3RoIGhhdmUgdGhlIHNhbWUgc3RhdHVzLCBzb3J0IGJ5IHByaW9yaXR5XHJcbiAgICAgKiAtIEZhbGxiYWNrIHRvIHNvcnRpbmcgYnkgbGFzdCBoaXN0b3J5IGVudHJ5XHJcbiAgICAgKiAtIEZhbGxiYWNrIHRvIHN0b3Agc29ydGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNvcnRNb2RlbHNCeVVyZ2VuY3kobW9kZWxzOiAoUHJqVGFza01hbmFnZW1lbnRNb2RlbDxUYXNrRGF0YSB8IFRvcGljRGF0YSB8IFByb2plY3REYXRhPilbXSk6IHZvaWQge1xyXG4gICAgICAgIG1vZGVscy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIGJvdGggYXJlIGBkb25lYCwgc29ydCBieSBsYXN0IGhpc3RvcnkgZW50cnlcclxuICAgICAgICAgICAgY29uc3QgYURhdGUgPSBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLmdldExhc3RIaXN0b3J5RGF0ZShhKTtcclxuICAgICAgICAgICAgY29uc3QgYkRhdGUgPSBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLmdldExhc3RIaXN0b3J5RGF0ZShiKTtcclxuICAgICAgICAgICAgaWYgKGEuZGF0YS5zdGF0dXMgPT09ICdEb25lJyAmJiBiLmRhdGEuc3RhdHVzID09PSAnRG9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSAmJiBiRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiRGF0ZS5nZXRUaW1lKCkgLSBhRGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGBhYCBpcyBkb25lLCBzb3J0IGl0IGxvd2VyXHJcbiAgICAgICAgICAgIGlmIChhLmRhdGEuc3RhdHVzID09PSAnRG9uZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIGBiYCBpcyBkb25lLCBzb3J0IGl0IGxvd2VyXHJcbiAgICAgICAgICAgIGlmIChiLmRhdGEuc3RhdHVzID09PSAnRG9uZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQm90aCBhcmUgbm90IGRvbmUsIHNvcnQgYnkgdXJnZW5jeVxyXG4gICAgICAgICAgICBjb25zdCBhVXJnZW5jeSA9IFByalRhc2tNYW5hZ2VtZW50TW9kZWwuY2FsY3VsYXRlVXJnZW5jeShhKTtcclxuICAgICAgICAgICAgY29uc3QgYlVyZ2VuY3kgPSBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLmNhbGN1bGF0ZVVyZ2VuY3koYik7XHJcbiAgICAgICAgICAgIGlmIChiVXJnZW5jeSAhPT0gYVVyZ2VuY3kpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiVXJnZW5jeSAtIGFVcmdlbmN5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCb3RoIGhhdmUgdGhlIHNhbWUgdXJnZW5jeSwgc29ydCBieSBzdGF0dXNcclxuICAgICAgICAgICAgY29uc3QgYVN0YXR1cyA9IFByalRhc2tNYW5hZ2VtZW50TW9kZWwuc3RhdHVzVG9OdW1iZXIoYS5kYXRhLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJTdGF0dXMgPSBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLnN0YXR1c1RvTnVtYmVyKGIuZGF0YS5zdGF0dXMpO1xyXG4gICAgICAgICAgICBpZiAoYlN0YXR1cyAhPT0gYVN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJTdGF0dXMgLSBhU3RhdHVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCb3RoIGhhdmUgdGhlIHNhbWUgc3RhdHVzLCBzb3J0IGJ5IHByaW9yaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IGFQcmlyb3JpdHkgPSBhLmRhdGEucHJpb3JpdHkgPz8gMDtcclxuICAgICAgICAgICAgY29uc3QgYlByaXJvcml0eSA9IGIuZGF0YS5wcmlvcml0eSA/PyAwO1xyXG4gICAgICAgICAgICBpZiAoYlByaXJvcml0eSAhPT0gYVByaXJvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJQcmlyb3JpdHkgLSBhUHJpcm9yaXR5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzb3J0aW5nIGJ5IGxhc3QgaGlzdG9yeSBlbnRyeVxyXG4gICAgICAgICAgICBpZiAoYURhdGUgJiYgYkRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiRGF0ZS5nZXRUaW1lKCkgLSBhRGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHN0b3Agc29ydGluZ1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhdHVzLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGF0dXMuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgbnVtYmVyIHJlcHJlc2VudGF0aW9uIGlzOlxyXG4gICAgICogLSBgQWN0aXZlYCA9IDNcclxuICAgICAqIC0gYFdhaXRpbmdgID0gMlxyXG4gICAgICogLSBgTGF0ZXJgID0gMVxyXG4gICAgICogLSBgU29tZWRheWAgPSAwXHJcbiAgICAgKiAtIGB1bmRlZmluZWRgID0gLTFcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc3RhdHVzVG9OdW1iZXIoc3RhdHVzOiBTdGF0dXMgfCB1bmRlZmluZWQgfCBudWxsKTogbnVtYmVyIHtcclxuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlICdBY3RpdmUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgIGNhc2UgJ1dhaXRpbmcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIGNhc2UgJ0xhdGVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBjYXNlICdTb21lZGF5JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VXJnZW5jeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLmNhbGN1bGF0ZVVyZ2VuY3kodGhpcyBhcyAoUHJqVGFza01hbmFnZW1lbnRNb2RlbDxUYXNrRGF0YSB8IFRvcGljRGF0YSB8IFByb2plY3REYXRhPikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGFncyBvZiB0aGUgbW9kZWwgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgICogQHJldHVybnMgQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSB0YWdzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUYWdzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5kYXRhLnRhZ3M7XHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZFRhZ3M6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgIGlmICh0YWdzICYmIHR5cGVvZiB0YWdzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3JtYXR0ZWRUYWdzID0gW3RhZ3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhZ3MpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlZFRhZ3MgPSBbLi4udGFnc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVGFncztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHVyZ2VuY3kgb2YgdGhlIG1vZGVsLlxyXG4gICAgICogQHBhcmFtIG1vZGVsIFRoZSBtb2RlbCB0byBjYWxjdWxhdGUgdGhlIHVyZ2VuY3kgZm9yLlxyXG4gICAgICogQHJldHVybnMgVGhlIHVyZ2VuY3kgb2YgdGhlIG1vZGVsLlxyXG4gICAgICogQHJlbWFya3MgVGhlIHVyZ2VuY3kgaXMgY2FsY3VsYXRlZCBhcyBmb2xsb3dzOlxyXG4gICAgICogLSBObyBgc3RhdHVzYCBvciBgc3RhdHVzYCBpcyAnRG9uZScgPSAtMlxyXG4gICAgICogLSBObyBgZHVlYCBvciBgc3RhdHVzYCBpcyAnU29tZWRheScgPSAtMVxyXG4gICAgICogLSBEdWUgZGF0ZSBpcyB0b2RheSBvciBpbiB0aGUgcGFzdCA9IDNcclxuICAgICAqIC0gRHVlIGRhdGUgaXMgaW4gdGhlIG5leHQgMyBkYXlzID0gMlxyXG4gICAgICogLSBEdWUgZGF0ZSBpcyBpbiB0aGUgbmV4dCA3IGRheXMgPSAxXHJcbiAgICAgKiAtIER1ZSBkYXRlIGlzIGluIG1vcmUgdGhlIGZ1dHVyZSA9IDBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlVXJnZW5jeShtb2RlbDogKFByalRhc2tNYW5hZ2VtZW50TW9kZWw8VGFza0RhdGEgfCBUb3BpY0RhdGEgfCBQcm9qZWN0RGF0YT4pKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAoIW1vZGVsLmRhdGEuc3RhdHVzIHx8IG1vZGVsLmRhdGEuc3RhdHVzID09PSAnRG9uZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1vZGVsLmRhdGEuZHVlIHx8IG1vZGVsLmRhdGEuc3RhdHVzID09PSAnU29tZWRheScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKG1vZGVsLmRhdGEuZHVlKTtcclxuICAgICAgICBkdWVEYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG5cclxuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdG9kYXkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VJbkRheXMgPSAoZHVlRGF0ZS5nZXRUaW1lKCkgLSB0b2RheS5nZXRUaW1lKCkpIC8gKDEwMDAgKiAzNjAwICogMjQpO1xyXG5cclxuICAgICAgICBsZXQgdXJnZW5jeSA9IDA7XHJcblxyXG4gICAgICAgIGlmIChkaWZmZXJlbmNlSW5EYXlzIDw9IDApIHtcclxuICAgICAgICAgICAgdXJnZW5jeSA9IDM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlSW5EYXlzIDw9IDMpIHtcclxuICAgICAgICAgICAgdXJnZW5jeSA9IDI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlSW5EYXlzIDw9IDcpIHtcclxuICAgICAgICAgICAgdXJnZW5jeSA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXJnZW5jeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgb2YgdGhlIGxhc3QgaGlzdG9yeSBlbnRyeS5cclxuICAgICAqIEBwYXJhbSBtb2RlbCBUaGUgbW9kZWwgdG8gZ2V0IHRoZSBsYXN0IGhpc3RvcnkgZW50cnkgZGF0ZSBmcm9tLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgb2YgdGhlIGxhc3QgaGlzdG9yeSBlbnRyeS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TGFzdEhpc3RvcnlEYXRlKG1vZGVsOiAoUHJqVGFza01hbmFnZW1lbnRNb2RlbDxUYXNrRGF0YSB8IFRvcGljRGF0YSB8IFByb2plY3REYXRhPikpOiBEYXRlIHwgbnVsbCB7XHJcbiAgICAgICAgaWYgKG1vZGVsLmRhdGEuaGlzdG9yeSAmJiBBcnJheS5pc0FycmF5KG1vZGVsLmRhdGEuaGlzdG9yeSkgJiYgbW9kZWwuZGF0YS5oaXN0b3J5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgaGlzdG9yeSA9IG1vZGVsLmRhdGEuaGlzdG9yeTtcclxuICAgICAgICAgICAgY29uc3QgbGFzdEVudHJ5ID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobGFzdEVudHJ5LmRhdGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IElQcmpEYXRhIGZyb20gXCIuLi9pbnRlcmZhY2VzL0lQcmpEYXRhXCI7XHJcbmltcG9ydCBJUHJqVGFza01hbmFnZW1lbnQgZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByalRhc2tNYW5hZ2VtZW50XCI7XHJcbmltcG9ydCB7IFN0YXR1cywgUHJpb3JpdHksIEVuZXJneSwgRmlsZVR5cGUsIEZpbGVTdWJUeXBlLCBIaXN0b3J5RW50cmllcyB9IGZyb20gXCIuL1ByalR5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BpY0RhdGEgaW1wbGVtZW50cyBJUHJqRGF0YSwgSVByalRhc2tNYW5hZ2VtZW50IHtcclxuICAgIHR5cGU6IEZpbGVUeXBlIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHN1YlR5cGU6IEZpbGVTdWJUeXBlIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHRpdGxlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBzdGF0dXM6IFN0YXR1cyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBwcmlvcml0eTogUHJpb3JpdHkgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgZW5lcmd5OiBFbmVyZ3kgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgZHVlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgdGFnczogc3RyaW5nW10gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgaGlzdG9yeTogSGlzdG9yeUVudHJpZXMgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGE6IFBhcnRpYWw8VG9waWNEYXRhPikge1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlICE9PSB1bmRlZmluZWQgPyBkYXRhLnRpdGxlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkYXRhLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgPyBkYXRhLmRlc2NyaXB0aW9uIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gZGF0YS5zdGF0dXMgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3RhdHVzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBkYXRhLnByaW9yaXR5ICE9PSB1bmRlZmluZWQgPyBkYXRhLnByaW9yaXR5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZW5lcmd5ID0gZGF0YS5lbmVyZ3kgIT09IHVuZGVmaW5lZCA/IGRhdGEuZW5lcmd5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZHVlID0gZGF0YS5kdWUgIT09IHVuZGVmaW5lZCA/IGRhdGEuZHVlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGFncyA9IGRhdGEudGFncyAhPT0gdW5kZWZpbmVkID8gZGF0YS50YWdzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkID8gZGF0YS50eXBlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3ViVHlwZSA9IGRhdGEuc3ViVHlwZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5zdWJUeXBlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGRhdGEuaGlzdG9yeSAhPT0gdW5kZWZpbmVkID8gZGF0YS5oaXN0b3J5IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCAiaW1wb3J0IHsgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFRvcGljRGF0YSBmcm9tIFwic3JjL3R5cGVzL1RvcGljRGF0YVwiO1xyXG5pbXBvcnQgeyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsIH0gZnJvbSBcIi4vUHJqVGFza01hbmFnZW1lbnRNb2RlbFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvcGljTW9kZWwgZXh0ZW5kcyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFRvcGljRGF0YT4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpbGU6IFRGaWxlKSB7XHJcbiAgICAgICAgc3VwZXIoZmlsZSwgVG9waWNEYXRhKTtcclxuICAgIH1cclxuXHJcbn0iLCAiaW1wb3J0IElQcmpEYXRhIGZyb20gXCIuLi9pbnRlcmZhY2VzL0lQcmpEYXRhXCI7XHJcbmltcG9ydCBJUHJqVGFza01hbmFnZW1lbnQgZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByalRhc2tNYW5hZ2VtZW50XCI7XHJcbmltcG9ydCB7IFN0YXR1cywgUHJpb3JpdHksIEVuZXJneSwgRmlsZVR5cGUsIEZpbGVTdWJUeXBlLCBIaXN0b3J5RW50cmllcyB9IGZyb20gXCIuL1ByalR5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0RGF0YSBpbXBsZW1lbnRzIElQcmpEYXRhLCBJUHJqVGFza01hbmFnZW1lbnQge1xyXG4gICAgdHlwZTogRmlsZVR5cGUgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgc3ViVHlwZTogRmlsZVN1YlR5cGUgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgdGl0bGU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHN0YXR1czogU3RhdHVzIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHByaW9yaXR5OiBQcmlvcml0eSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBlbmVyZ3k6IEVuZXJneSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBkdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB0YWdzOiBzdHJpbmdbXSB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBoaXN0b3J5OiBIaXN0b3J5RW50cmllcyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGF0YTogUGFydGlhbDxQcm9qZWN0RGF0YT4pIHtcclxuICAgICAgICB0aGlzLnRpdGxlID0gZGF0YS50aXRsZSAhPT0gdW5kZWZpbmVkID8gZGF0YS50aXRsZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkID8gZGF0YS5kZXNjcmlwdGlvbiA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IGRhdGEuc3RhdHVzICE9PSB1bmRlZmluZWQgPyBkYXRhLnN0YXR1cyA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gZGF0YS5wcmlvcml0eSAhPT0gdW5kZWZpbmVkID8gZGF0YS5wcmlvcml0eSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmVuZXJneSA9IGRhdGEuZW5lcmd5ICE9PSB1bmRlZmluZWQgPyBkYXRhLmVuZXJneSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmR1ZSA9IGRhdGEuZHVlICE9PSB1bmRlZmluZWQgPyBkYXRhLmR1ZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnRhZ3MgPSBkYXRhLnRhZ3MgIT09IHVuZGVmaW5lZCA/IGRhdGEudGFncyA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCA/IGRhdGEudHlwZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN1YlR5cGUgPSBkYXRhLnN1YlR5cGUgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3ViVHlwZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmhpc3RvcnkgPSBkYXRhLmhpc3RvcnkgIT09IHVuZGVmaW5lZCA/IGRhdGEuaGlzdG9yeSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwgImltcG9ydCB7IFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBQcm9qZWN0RGF0YSBmcm9tIFwic3JjL3R5cGVzL1Byb2plY3REYXRhXCI7XHJcbmltcG9ydCB7IFByalRhc2tNYW5hZ2VtZW50TW9kZWwgfSBmcm9tIFwiLi9QcmpUYXNrTWFuYWdlbWVudE1vZGVsXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvamVjdE1vZGVsIGV4dGVuZHMgUHJqVGFza01hbmFnZW1lbnRNb2RlbDxQcm9qZWN0RGF0YT4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpbGU6IFRGaWxlKSB7XHJcbiAgICAgICAgc3VwZXIoZmlsZSwgUHJvamVjdERhdGEpO1xyXG4gICAgfVxyXG5cclxufSIsICJpbXBvcnQgSVByakRhdGEgZnJvbSBcIi4uL2ludGVyZmFjZXMvSVByakRhdGFcIjtcclxuaW1wb3J0IElQcmpUYXNrTWFuYWdlbWVudCBmcm9tIFwiLi4vaW50ZXJmYWNlcy9JUHJqVGFza01hbmFnZW1lbnRcIjtcclxuaW1wb3J0IHsgU3RhdHVzLCBQcmlvcml0eSwgRW5lcmd5LCBGaWxlVHlwZSwgRmlsZVN1YlR5cGUsIEhpc3RvcnlFbnRyaWVzIH0gZnJvbSBcIi4vUHJqVHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tEYXRhIGltcGxlbWVudHMgSVByakRhdGEsIElQcmpUYXNrTWFuYWdlbWVudCB7XHJcbiAgICB0eXBlOiBGaWxlVHlwZSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBzdWJUeXBlOiBGaWxlU3ViVHlwZSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICB0aXRsZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgc3RhdHVzOiBTdGF0dXMgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpb3JpdHk6IFByaW9yaXR5IHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGVuZXJneTogRW5lcmd5IHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGR1ZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIHRhZ3M6IHN0cmluZ1tdIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIGhpc3Rvcnk6IEhpc3RvcnlFbnRyaWVzIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhOiBQYXJ0aWFsPFRhc2tEYXRhPikge1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlICE9PSB1bmRlZmluZWQgPyBkYXRhLnRpdGxlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkYXRhLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgPyBkYXRhLmRlc2NyaXB0aW9uIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gZGF0YS5zdGF0dXMgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3RhdHVzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBkYXRhLnByaW9yaXR5ICE9PSB1bmRlZmluZWQgPyBkYXRhLnByaW9yaXR5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZW5lcmd5ID0gZGF0YS5lbmVyZ3kgIT09IHVuZGVmaW5lZCA/IGRhdGEuZW5lcmd5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZHVlID0gZGF0YS5kdWUgIT09IHVuZGVmaW5lZCA/IGRhdGEuZHVlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGFncyA9IGRhdGEudGFncyAhPT0gdW5kZWZpbmVkID8gZGF0YS50YWdzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkID8gZGF0YS50eXBlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3ViVHlwZSA9IGRhdGEuc3ViVHlwZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5zdWJUeXBlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGRhdGEuaGlzdG9yeSAhPT0gdW5kZWZpbmVkID8gZGF0YS5oaXN0b3J5IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCAiaW1wb3J0IHsgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFRhc2tEYXRhIGZyb20gXCJzcmMvdHlwZXMvVGFza0RhdGFcIjtcclxuaW1wb3J0IHsgUHJqVGFza01hbmFnZW1lbnRNb2RlbCB9IGZyb20gXCIuL1ByalRhc2tNYW5hZ2VtZW50TW9kZWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBUYXNrTW9kZWwgZXh0ZW5kcyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFRhc2tEYXRhPiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZmlsZTogVEZpbGUpIHtcclxuICAgICAgICBzdXBlcihmaWxlLCBUYXNrRGF0YSk7XHJcbiAgICB9XHJcblxyXG5cclxufSIsICJpbXBvcnQgeyBDb21wb25lbnQsIE1hcmtkb3duUmVuZGVyZXIsIHNldEljb24gfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IEdsb2JhbCBmcm9tIFwic3JjL2NsYXNzZXMvR2xvYmFsXCI7XHJcbmltcG9ydCBMbmcgZnJvbSBcInNyYy9jbGFzc2VzL0xuZ1wiO1xyXG5pbXBvcnQgRWRpdGFibGVEYXRhVmlldyBmcm9tIFwic3JjL2xpYnMvRWRpdGFibGVEYXRhVmlldy9FZGl0YWJsZURhdGFWaWV3XCI7XHJcbmltcG9ydCBIZWxwZXIgZnJvbSBcInNyYy9saWJzL0hlbHBlclwiO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbmltcG9ydCB7IFByalRhc2tNYW5hZ2VtZW50TW9kZWwgfSBmcm9tIFwic3JjL21vZGVscy9QcmpUYXNrTWFuYWdlbWVudE1vZGVsXCI7XHJcbmltcG9ydCB7IEZpbGVUeXBlLCBTdGF0dXMsIFVyZ2VuY3lTeW1ib2xzIH0gZnJvbSBcInNyYy90eXBlcy9QcmpUeXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdENvbXBvbmVudHMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRpdGxlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgVGhlIGNvbnRhaW5lciB0byBhcHBlbmQgdGhlIHRpdGxlIHRvLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudHMgdG8uXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSBvblJlYWQgT24gcmVhZCBjYWxsYmFjay4gUmV0dXJucyB0aGUgdGl0bGUuXHJcbiAgICAgKiBAcGFyYW0gb25Xcml0ZSBPbiB3cml0ZSBjYWxsYmFjay4gUGFzc2VzIHRoZSBuZXcgdGl0bGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlVGl0bGUoXHJcbiAgICAgICAgY29udGFpbmVyOiBEb2N1bWVudEZyYWdtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIHBhdGg6IHN0cmluZyxcclxuICAgICAgICBvblJlYWQ6ICgpID0+IHN0cmluZyxcclxuICAgICAgICBvbldyaXRlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCkge1xyXG4gICAgICAgIG5ldyBFZGl0YWJsZURhdGFWaWV3KGNvbnRhaW5lciwgY29tcG9uZW50KVxyXG4gICAgICAgICAgICAuYWRkTGluayhsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGxpbmsuc2V0VmFsdWUob25SZWFkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFRpdGxlKExuZy5ndChcIlRpdGxlXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihMbmcuZ3QoXCJUaXRsZVwiKSlcclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGlua1R5cGUoXCJmaWxlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEZvcm1hdG9yKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXRsZTogRG9jdW1lbnRGcmFnbWVudCB8IHVuZGVmaW5lZCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJY29uKHRpdGxlIGFzIHVua25vd24gYXMgSFRNTERpdkVsZW1lbnQsIFwicGFwZXJjbGlwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEhlbHBlci5pc1Bvc3NpYmx5TWFya2Rvd24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyKEdsb2JhbC5nZXRJbnN0YW5jZSgpLmFwcCwgdmFsdWUgPz8gXCJcIiwgZGl2LCBcIlwiLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUuYXBwZW5kQ2hpbGQoZGl2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaHJlZjogYCR7cGF0aH1gLCB0ZXh0OiBgJHt2YWx1ZX1gLCBodG1sOiB0aXRsZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmVuYWJsZUVkaXRhYmlsaXR5KClcclxuICAgICAgICAgICAgICAgICAgICAub25TYXZlKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uV3JpdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHN1bW1hcnkgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBUaGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgc3VtbWFyeSB0by5cclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZWdpc3RlciB0aGUgZXZlbnRzIHRvLlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIFRoZSBkZXNjcmlwdGlvbiB0byBkaXNwbGF5LlxyXG4gICAgICogQHBhcmFtIG9uV3JpdGUgT24gd3JpdGUgY2FsbGJhY2suIFBhc3NlcyB0aGUgbmV3IGRlc2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVN1bW1hcnkoXHJcbiAgICAgICAgY29udGFpbmVyOiBEb2N1bWVudEZyYWdtZW50LFxyXG4gICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcsXHJcbiAgICAgICAgb25Xcml0ZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBuZXcgRWRpdGFibGVEYXRhVmlldyhjb250YWluZXIsIGNvbXBvbmVudClcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUoTG5nLmd0KFwiRGVzY3JpcHRpb25cIikpXHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoTG5nLmd0KFwiRGVzY3JpcHRpb25cIikpXHJcbiAgICAgICAgICAgICAgICAuZW5hYmxlRWRpdGFiaWxpdHkoKVxyXG4gICAgICAgICAgICAgICAgLnNldFJlbmRlck1hcmtkb3duKClcclxuICAgICAgICAgICAgICAgIC5vblNhdmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbldyaXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3RhdHVzKFxyXG4gICAgICAgIGNvbnRhaW5lcjogRG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBvblJlYWQ6ICgpID0+IHN0cmluZyxcclxuICAgICAgICBvbldyaXRlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCkge1xyXG4gICAgICAgIG5ldyBFZGl0YWJsZURhdGFWaWV3KGNvbnRhaW5lciwgY29tcG9uZW50KVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5zZXRPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBcIkFjdGl2ZVwiLCB0ZXh0OiBMbmcuZ3QoXCJTdGF0dXNBY3RpdmVcIikgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBcIldhaXRpbmdcIiwgdGV4dDogTG5nLmd0KFwiU3RhdHVzV2FpdGluZ1wiKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IFwiTGF0ZXJcIiwgdGV4dDogTG5nLmd0KFwiU3RhdHVzTGF0ZXJcIikgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBcIlNvbWVkYXlcIiwgdGV4dDogTG5nLmd0KFwiU3RhdHVzU29tZWRheVwiKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IFwiRG9uZVwiLCB0ZXh0OiBMbmcuZ3QoXCJTdGF0dXNEb25lXCIpIH1cclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUoTG5nLmd0KFwiU3RhdHVzXCIpKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKG9uUmVhZCgpKVxyXG4gICAgICAgICAgICAgICAgLm9uU2F2ZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbldyaXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZW5hYmxlRWRpdGFiaWxpdHkoKVxyXG4gICAgICAgICAgICAgICAgLnNldEZvcm1hdG9yKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gdmFsdWUgYXMgU3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpY29uU3RyaW5nOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFjdGl2ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHUyNkExXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIldhaXRpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBcIlx1MjNGM1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMYXRlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERDFDXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNvbWVkYXlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBcIlx1RDgzRFx1RENDNlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEb25lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3RyaW5nID0gXCJcdTI3MTRcdUZFMEZcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHUyNkExXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogYCR7aWNvblN0cmluZ31gLCBodG1sOiB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHByaW9yaXR5IGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgVGhlIGNvbnRhaW5lciB0byBhcHBlbmQgdGhlIHByaW9yaXR5IHRvLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyIHRoZSBldmVudHMgdG8uXHJcbiAgICAgKiBAcGFyYW0gb25SZWFkIE9uIHJlYWQgY2FsbGJhY2suIFJldHVybnMgdGhlIHByaW9yaXR5LlxyXG4gICAgICogQHBhcmFtIG9uV3JpdGUgT24gd3JpdGUgY2FsbGJhY2suIFBhc3NlcyB0aGUgbmV3IHByaW9yaXR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVByaW9yaXR5KFxyXG4gICAgICAgIGNvbnRhaW5lcjogRG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBvblJlYWQ6ICgpID0+IHN0cmluZyxcclxuICAgICAgICBvbldyaXRlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCkge1xyXG4gICAgICAgIG5ldyBFZGl0YWJsZURhdGFWaWV3KGNvbnRhaW5lciwgY29tcG9uZW50KVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5zZXRPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBcIjNcIiwgdGV4dDogTG5nLmd0KFwiSGlnaFByaW9yaXR5XCIpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogXCIyXCIsIHRleHQ6IExuZy5ndChcIk1lZGl1bVByaW9yaXR5XCIpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogXCIxXCIsIHRleHQ6IExuZy5ndChcIkxvd1ByaW9yaXR5XCIpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogXCIwXCIsIHRleHQ6IExuZy5ndChcIk5vUHJpb3JpdHlcIikgfVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIC5zZXRUaXRsZShMbmcuZ3QoXCJQcmlvcml0eVRleHRcIikpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUob25SZWFkKCkpXHJcbiAgICAgICAgICAgICAgICAub25TYXZlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uV3JpdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5lbmFibGVFZGl0YWJpbGl0eSgpXHJcbiAgICAgICAgICAgICAgICAuc2V0Rm9ybWF0b3IoKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpY29uU3RyaW5nOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiM1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwic2lnbmFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBcInNpZ25hbC1tZWRpdW1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwic2lnbmFsLWxvd1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3RyaW5nID0gXCJzaWduYWwtemVyb1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uU3RyaW5nID0gXCJzaWduYWwtemVyb1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEljb24oaWNvbiBhcyB1bmtub3duIGFzIEhUTUxEaXZFbGVtZW50LCBpY29uU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBgJHt2YWx1ZX1gLCBodG1sOiBpY29uIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBsaW5rIHRvIHRoZSBmaWxlIGF0IGBwYXRoYCB3aXRoIHRoZSBgY29yb3Nwb25kaW5nU3ltYm9sYCBhcyBpY29uLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBUaGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgbGluayB0by5cclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZWdpc3RlciB0aGUgZXZlbnRzIHRvLlxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSBjb3Jvc3BvbmRpbmdTeW1ib2wgVGhlIGNvcm9zcG9uZGluZyBzeW1ib2wgZm9yIHRoZSBmaWxlIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlTWV0YWRhdGFMaW5rKFxyXG4gICAgICAgIGNvbnRhaW5lcjogRG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICBwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgdHlwZTogRmlsZVR5cGUgfCB1bmRlZmluZWQgfCBudWxsLFxyXG4gICAgICAgIGNvcm9zcG9uZGluZ1N5bWJvbDogc3RyaW5nKSB7XHJcbiAgICAgICAgbmV3IEVkaXRhYmxlRGF0YVZpZXcoY29udGFpbmVyLCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgIC5hZGRMaW5rKGxpbmsgPT4gbGlua1xyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHBhdGgpXHJcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUoTG5nLmd0KHR5cGUgPz8gXCJGaWxlXCIpKVxyXG4gICAgICAgICAgICAgICAgLnNldExpbmtUeXBlKFwiZmlsZVwiKVxyXG4gICAgICAgICAgICAgICAgLnNldEZvcm1hdG9yKCh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uU3RyaW5nID0gY29yb3Nwb25kaW5nU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEljb24oaWNvbiBhcyB1bmtub3duIGFzIEhUTUxEaXZFbGVtZW50LCBpY29uU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBocmVmOiBgJHt2YWx1ZX1gLCB0ZXh0OiBgJHt2YWx1ZX1gLCBodG1sOiBpY29uIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzcGFuIHdpdGggdGhlIHRvIGB1cmdlbmN5YCBjb3JyZXNwb25kaW5nIHVyZ2VuY3kgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBUaGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgc3BhbiB0by5cclxuICAgICAqIEBwYXJhbSB1cmdlbmN5IFRoZSB1cmdlbmN5IHRvIGdldCB0aGUgc3ltYm9sIGZvci4gKDMgdG8gLTIpXHJcbiAgICAgKiBAc2VlIHtAbGluayBQcmpUYXNrTWFuYWdlbWVudE1vZGVsLmNhbGN1bGF0ZVVyZ2VuY3l9XHJcbiAgICAgKiBAc2VlIHtAbGluayBVcmdlbmN5U3ltYm9sc31cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVUcmFmaWNMaWdodChcclxuICAgICAgICBjb250YWluZXI6IERvY3VtZW50RnJhZ21lbnQsXHJcbiAgICAgICAgdXJnZW5jeTogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgdHJhZmljTGlnaHRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmFmaWNMaWdodFNwYW4pO1xyXG4gICAgICAgIGxldCBpY29uU3RyaW5nOiBVcmdlbmN5U3ltYm9scztcclxuICAgICAgICBzd2l0Y2ggKHVyZ2VuY3kpIHtcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERDM0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERkUwXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERkUxXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERkUyXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgIGljb25TdHJpbmcgPSBcIlx1RDgzRFx1REZFMlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgLTI6XHJcbiAgICAgICAgICAgICAgICBpY29uU3RyaW5nID0gXCJcdUQ4M0RcdUREMzVcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWNvblN0cmluZyA9IFwiXHVEODNEXHVERDM0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhZmljTGlnaHRTcGFuLnRleHRDb250ZW50ID0gaWNvblN0cmluZztcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IFRhYmxlQmxvY2tSZW5kZXJDb21wb25lbnQgZnJvbSBcIi4vVGFibGVCbG9ja1JlbmRlckNvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsIH0gZnJvbSBcInNyYy9tb2RlbHMvUHJqVGFza01hbmFnZW1lbnRNb2RlbFwiO1xyXG5pbXBvcnQgVGFza0RhdGEgZnJvbSBcInNyYy90eXBlcy9UYXNrRGF0YVwiO1xyXG5pbXBvcnQgVG9waWNEYXRhIGZyb20gXCJzcmMvdHlwZXMvVG9waWNEYXRhXCI7XHJcbmltcG9ydCBQcm9qZWN0RGF0YSBmcm9tIFwic3JjL3R5cGVzL1Byb2plY3REYXRhXCI7XHJcbmltcG9ydCB7IElQcm9jZXNzb3JTZXR0aW5ncyB9IGZyb20gXCJzcmMvaW50ZXJmYWNlcy9JUHJvY2Vzc29yU2V0dGluZ3NcIjtcclxuaW1wb3J0IFNlYXJjaCwgeyBTZWFyY2hUZXJtc0FycmF5IH0gZnJvbSBcIi4uL1NlYXJjaFwiO1xyXG5pbXBvcnQgVGFibGUsIHsgUm93LCBSb3dzU3RhdGUsIFRhYmxlSGVhZGVyIH0gZnJvbSBcIi4uL1RhYmxlXCI7XHJcbmltcG9ydCBMbmcgZnJvbSBcInNyYy9jbGFzc2VzL0xuZ1wiO1xyXG5pbXBvcnQgRmlsdGVyQnV0dG9uIGZyb20gXCIuL0lubmVyQ29tcG9uZW50cy9GaWx0ZXJCdXR0b25cIjtcclxuaW1wb3J0IE1heFNob3duTW9kZWxzSW5wdXQgZnJvbSBcIi4vSW5uZXJDb21wb25lbnRzL01heFNob3duTW9kZWxzSW5wdXRcIjtcclxuaW1wb3J0IFNlYXJjaElucHV0IGZyb20gXCIuL0lubmVyQ29tcG9uZW50cy9TZWFyY2hJbnB1dFwiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCIuLi9IZWxwZXJcIjtcclxuaW1wb3J0IHsgVG9waWNNb2RlbCB9IGZyb20gXCJzcmMvbW9kZWxzL1RvcGljTW9kZWxcIjtcclxuaW1wb3J0IHsgUHJvamVjdE1vZGVsIH0gZnJvbSBcInNyYy9tb2RlbHMvUHJvamVjdE1vZGVsXCI7XHJcbmltcG9ydCB7IFRhc2tNb2RlbCB9IGZyb20gXCJzcmMvbW9kZWxzL1Rhc2tNb2RlbFwiO1xyXG5pbXBvcnQgeyBQcmlvcml0eSwgU3RhdHVzIH0gZnJvbSBcInNyYy90eXBlcy9QcmpUeXBlc1wiO1xyXG5pbXBvcnQgRG9jdW1lbnRDb21wb25lbnRzIGZyb20gXCIuL0lubmVyQ29tcG9uZW50cy9Eb2N1bWVudENvbXBvbmVudHNcIjtcclxuaW1wb3J0IFByb2plY3RDb21wb25lbnRzIGZyb20gXCIuL0lubmVyQ29tcG9uZW50cy9Qcm9qZWN0Q29tcG9uZW50c1wiO1xyXG5pbXBvcnQgR2VuZXJhbENvbXBvbmVudHMgZnJvbSBcIi4vSW5uZXJDb21wb25lbnRzL0dlbmVyYWxDb21wb25lbnRzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0QmxvY2tSZW5kZXJDb21wb25lbnQgZXh0ZW5kcyBUYWJsZUJsb2NrUmVuZGVyQ29tcG9uZW50PFByalRhc2tNYW5hZ2VtZW50TW9kZWw8VGFza0RhdGEgfCBUb3BpY0RhdGEgfCBQcm9qZWN0RGF0YT4+IHtcclxuICAgIHByb3RlY3RlZCBzZXR0aW5nczogUHJvamVjdEJsb2NrUmVuZGVyU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgdGFnczogW10sXHJcbiAgICAgICAgdG9waWNTeW1ib2w6IHRoaXMuZ2xvYmFsLnNldHRpbmdzLnByalNldHRpbmdzLnRvcGljU3ltYm9sLFxyXG4gICAgICAgIHByb2plY3RTeW1ib2w6IHRoaXMuZ2xvYmFsLnNldHRpbmdzLnByalNldHRpbmdzLnByb2plY3RTeW1ib2wsXHJcbiAgICAgICAgdGFza1N5bWJvbDogdGhpcy5nbG9iYWwuc2V0dGluZ3MucHJqU2V0dGluZ3MudGFza1N5bWJvbCxcclxuICAgICAgICBvdGhlclN5bWJvbDogXCJkaWFtb25kXCIsXHJcbiAgICAgICAgZmlsdGVyOiBbXCJUb3BpY1wiLCBcIlByb2plY3RcIiwgXCJUYXNrXCJdLFxyXG4gICAgICAgIG1heERvY3VtZW50czogdGhpcy5nbG9iYWwuc2V0dGluZ3MuZGVmYXVsdE1heFNob3csXHJcbiAgICAgICAgc2VhcmNoOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYmF0Y2hTaXplOiA4LFxyXG4gICAgICAgIHNsZWVwQmV0d2VlbkJhdGNoZXM6IDEwXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhYmxlIGhlYWRlcnMuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgdGFibGUgaGVhZGVycyBhcmUgdXNlZCB0byBjcmVhdGUgdGhlIHRhYmxlLlxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0YWJsZUhlYWRlcnM6IFRhYmxlSGVhZGVyW10gPSBbXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJEb2N1bWVudFR5cGVcIiksIGhlYWRlckNsYXNzOiBbXSwgY29sdW1uQ2xhc3M6IFtcImRvbnQtZGVjb3JhdGUtbGlua1wiLCBcImZvbnQtbWVkaXVtXCJdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJUcmFmaWNMaWdodFwiKSwgaGVhZGVyQ2xhc3M6IFtdLCBjb2x1bW5DbGFzczogW10gfSxcclxuICAgICAgICB7IHRleHQ6IExuZy5ndChcIkRlc2NyaXB0aW9uXCIpLCBoZWFkZXJDbGFzczogW10sIGNvbHVtbkNsYXNzOiBbXCJkb250LWRlY29yYXRlLWxpbmtcIiwgXCJsaW5rLXdlaWdodC1ib2xkXCJdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJQcmlvcml0eVwiKSwgaGVhZGVyQ2xhc3M6IFtdLCBjb2x1bW5DbGFzczogW10gfSxcclxuICAgICAgICB7IHRleHQ6IExuZy5ndChcIkR1ZURhdGVcIiksIGhlYWRlckNsYXNzOiBbXSwgY29sdW1uQ2xhc3M6IFtcImZvbnQteHNtYWxsXCJdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJTdGF0dXNcIiksIGhlYWRlckNsYXNzOiBbXSwgY29sdW1uQ2xhc3M6IFtdIH0sXHJcbiAgICAgICAgeyB0ZXh0OiBMbmcuZ3QoXCJUYWdzXCIpLCBoZWFkZXJDbGFzczogW10sIGNvbHVtbkNsYXNzOiBbXCJ0YWdzXCJdIH1cclxuICAgIF07XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IElQcm9jZXNzb3JTZXR0aW5ncykge1xyXG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICB0aGlzLnBhcnNlU2V0dGluZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYnVpbGQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmJ1aWxkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIGRyYXcoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ2V0TW9kZWxzUHJvbWlzZSA9IHRoaXMuZ2V0TW9kZWxzKCk7XHJcbiAgICAgICAgYXdhaXQgc3VwZXIuZHJhdygpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGRUYWJsZSgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGRIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLmdyYXlPdXRIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLm1vZGVscyA9IChhd2FpdCBnZXRNb2RlbHNQcm9taXNlKTtcclxuXHJcbiAgICAgICAgUHJqVGFza01hbmFnZW1lbnRNb2RlbC5zb3J0TW9kZWxzQnlVcmdlbmN5KHRoaXMubW9kZWxzIGFzIChQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFRhc2tEYXRhIHwgVG9waWNEYXRhIHwgUHJvamVjdERhdGE+KVtdKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmFkZERvY3VtZW50c1RvVGFibGUoKTtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZUhlYWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBSZWRyYXcgKGZvciAke3RoaXMubW9kZWxzLmxlbmd0aH0gTW9kZWxzKSBydW5zIGZvciAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXNgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGJ1aWxkVGFibGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy50YWJsZSA9IG5ldyBUYWJsZSh0aGlzLnRhYmxlSGVhZGVycywgXCJwcm9qZWN0LXRhYmxlXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy50YWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlLmRhdGEudGFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgYnVpbGRIZWFkZXIoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gRmlsdGVyIGNvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IGhlYWRlckZpbHRlckJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLmhlYWRlckNvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXJGaWx0ZXJCdXR0b25zKTtcclxuICAgICAgICBoZWFkZXJGaWx0ZXJCdXR0b25zLmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1pdGVtJyk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItc3ltYm9scycpO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgbGFiZWxcclxuICAgICAgICBjb25zdCBmaWx0ZXJMYWJlbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQoZmlsdGVyTGFiZWxDb250YWluZXIpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIGZpbHRlckxhYmVsQ29udGFpbmVyLmFwcGVuZENoaWxkKGZpbHRlckxhYmVsKTtcclxuICAgICAgICBmaWx0ZXJMYWJlbC5jbGFzc0xpc3QuYWRkKCdmaWx0ZXItc3ltYm9sJyk7XHJcbiAgICAgICAgZmlsdGVyTGFiZWwudGV4dENvbnRlbnQgPSBMbmcuZ3QoXCJGaWx0ZXJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvcGljRmlsdGVyQnV0dG9uID0gRmlsdGVyQnV0dG9uLmNyZWF0ZShcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIFwiVG9waWNcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy50b3BpY1N5bWJvbCxcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXIuaW5jbHVkZXMoXCJUb3BpY1wiKSxcclxuICAgICAgICAgICAgdGhpcy5vbkZpbHRlckJ1dHRvbi5iaW5kKHRoaXMpKTtcclxuICAgICAgICBoZWFkZXJGaWx0ZXJCdXR0b25zLmFwcGVuZENoaWxkKHRvcGljRmlsdGVyQnV0dG9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdEZpbHRlckJ1dHRvbiA9IEZpbHRlckJ1dHRvbi5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBcIlByb2plY3RcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5wcm9qZWN0U3ltYm9sLFxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyhcIlByb2plY3RcIiksXHJcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJCdXR0b24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5hcHBlbmRDaGlsZChwcm9qZWN0RmlsdGVyQnV0dG9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGFza0ZpbHRlckJ1dHRvbiA9IEZpbHRlckJ1dHRvbi5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBcIlRhc2tcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy50YXNrU3ltYm9sLFxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyhcIlRhc2tcIiksXHJcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJCdXR0b24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaGVhZGVyRmlsdGVyQnV0dG9ucy5hcHBlbmRDaGlsZCh0YXNrRmlsdGVyQnV0dG9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgZG9uZUZpbHRlckJ1dHRvbiA9IEZpbHRlckJ1dHRvbi5jcmVhdGUoXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBcIkRvbmVcIixcclxuICAgICAgICAgICAgXCJjaGVjay1zcXVhcmVcIixcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maWx0ZXIuaW5jbHVkZXMoXCJEb25lXCIpLFxyXG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyQnV0dG9uLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQoZG9uZUZpbHRlckJ1dHRvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IG1heERvY3VtZW50cyA9IE1heFNob3duTW9kZWxzSW5wdXQuY3JlYXRlKFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tYXhEb2N1bWVudHMsXHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsLnNldHRpbmdzLmRlZmF1bHRNYXhTaG93LFxyXG4gICAgICAgICAgICB0aGlzLm9uTWF4RG9jdW1lbnRzQ2hhbmdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGhlYWRlckZpbHRlckJ1dHRvbnMuYXBwZW5kQ2hpbGQobWF4RG9jdW1lbnRzKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VhcmNoQm94ID0gU2VhcmNoSW5wdXQuY3JlYXRlKFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgdGhpcy5vblNlYXJjaC5iaW5kKHRoaXMpKTtcclxuICAgICAgICBoZWFkZXJGaWx0ZXJCdXR0b25zLmFwcGVuZENoaWxkKHNlYXJjaEJveCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBhZGREb2N1bWVudHNUb1RhYmxlKGJhdGNoU2l6ZSA9IHRoaXMuc2V0dGluZ3MuYmF0Y2hTaXplLCBzbGVlcEJldHdlZW5CYXRjaGVzID0gdGhpcy5zZXR0aW5ncy5zbGVlcEJldHdlZW5CYXRjaGVzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgbGV0IHNsZWVwUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsc0xlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCByb3dzOiBSb3dbXSA9IFtdO1xyXG4gICAgICAgIGxldCByb3dQcm9taXNlOiBQcm9taXNlPFJvdz4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmIChtb2RlbHNMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJvd1Byb21pc2UgPSB0aGlzLmdlbmVyYXRlVGFibGVSb3codGhpcy5tb2RlbHNbMF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB2aXNpYmxlUm93cyA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWxzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBpICsgMSA8IG1vZGVsc0xlbmd0aCA/IHRoaXMubW9kZWxzW2kgKyAxXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByb3cgPSBhd2FpdCByb3dQcm9taXNlO1xyXG4gICAgICAgICAgICByb3dQcm9taXNlID0gbW9kZWwgPyB0aGlzLmdlbmVyYXRlVGFibGVSb3cobW9kZWwpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJvdyAmJiAhcm93LmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGVSb3dzIDwgdGhpcy5zZXR0aW5ncy5tYXhEb2N1bWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlUm93cysrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJvdylcclxuICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xyXG5cclxuICAgICAgICAgICAgaWYgKChpICE9PSAwICYmIGkgJSBiYXRjaFNpemUgPT09IDApIHx8IGkgPT09IG1vZGVsc0xlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFibGUuYWRkUm93cyhyb3dzKTtcclxuICAgICAgICAgICAgICAgIHJvd3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHNsZWVwUHJvbWlzZSA9IEhlbHBlci5zbGVlcChzbGVlcEJldHdlZW5CYXRjaGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVGFibGVSb3cobW9kZWw6IChQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFRhc2tEYXRhIHwgVG9waWNEYXRhIHwgUHJvamVjdERhdGE+KSk6IFByb21pc2U8Um93PiB7XHJcbiAgICAgICAgY29uc3Qgcm93Q2xhc3NMaXN0OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJvd0RhdGE6IERvY3VtZW50RnJhZ21lbnRbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJvd1VpZCA9IHRoaXMuZ2V0VUlEKG1vZGVsKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDAgLS0gTWV0YWRhdGEgTGlua1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTGluayA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICByb3dEYXRhLnB1c2gobWV0YWRhdGFMaW5rKTtcclxuICAgICAgICBHZW5lcmFsQ29tcG9uZW50cy5jcmVhdGVNZXRhZGF0YUxpbmsoXHJcbiAgICAgICAgICAgIG1ldGFkYXRhTGluayxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIG1vZGVsLmZpbGUucGF0aCxcclxuICAgICAgICAgICAgbW9kZWwuZGF0YS50eXBlLFxyXG4gICAgICAgICAgICBtb2RlbC5nZXRDb3Jvc3BvbmRpbmdTeW1ib2woKSk7XHJcblxyXG4gICAgICAgIC8vIFJvdyAxIC0tIFRyYWZpYyBMaWdodFxyXG4gICAgICAgIGNvbnN0IHRyYWZpY0xpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIHJvd0RhdGEucHVzaCh0cmFmaWNMaWdodCk7XHJcbiAgICAgICAgUHJvamVjdENvbXBvbmVudHMuY3JlYXRlVHJhZmljTGlnaHQodHJhZmljTGlnaHQsIG1vZGVsLmdldFVyZ2VuY3koKSk7XHJcblxyXG4gICAgICAgIC8vIFJvdyAyIC0tIFRpdGxlICYgRGVzY3JpcHRpb25cclxuICAgICAgICBjb25zdCB0aXRsZUFuZFN1bW1hcnkgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgcm93RGF0YS5wdXNoKHRpdGxlQW5kU3VtbWFyeSk7XHJcbiAgICAgICAgUHJvamVjdENvbXBvbmVudHMuY3JlYXRlVGl0bGUoXHJcbiAgICAgICAgICAgIHRpdGxlQW5kU3VtbWFyeSxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIG1vZGVsLmZpbGUucGF0aCxcclxuICAgICAgICAgICAgKCkgPT4gbW9kZWwuZGF0YS50aXRsZSA/PyBcIlwiLFxyXG4gICAgICAgICAgICBhc3luYyAodmFsdWU6IHN0cmluZykgPT4gbW9kZWwuZGF0YS50aXRsZSA9IHZhbHVlKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGluZUJyZWFrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcclxuICAgICAgICB0aXRsZUFuZFN1bW1hcnkuYXBwZW5kQ2hpbGQobGluZUJyZWFrKTtcclxuXHJcbiAgICAgICAgUHJvamVjdENvbXBvbmVudHMuY3JlYXRlU3VtbWFyeShcclxuICAgICAgICAgICAgdGl0bGVBbmRTdW1tYXJ5LFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgbW9kZWwuZGF0YS5kZXNjcmlwdGlvbiA/PyBcIlwiLFxyXG4gICAgICAgICAgICAodmFsdWU6IHN0cmluZykgPT4gbW9kZWwuZGF0YS5kZXNjcmlwdGlvbiA9IHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDMgLS0gUHJpb3JpdHlcclxuICAgICAgICBjb25zdCBwcmlvcml0eSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICByb3dEYXRhLnB1c2gocHJpb3JpdHkpO1xyXG4gICAgICAgIFByb2plY3RDb21wb25lbnRzLmNyZWF0ZVByaW9yaXR5KFxyXG4gICAgICAgICAgICBwcmlvcml0eSxcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgICgpID0+IG1vZGVsLmRhdGEucHJpb3JpdHk/LnRvU3RyaW5nKCkgPz8gXCIwXCIsXHJcbiAgICAgICAgICAgIGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiBtb2RlbC5kYXRhLnByaW9yaXR5ID0gdmFsdWUgYXMgdW5rbm93biBhcyBQcmlvcml0eSk7XHJcblxyXG4gICAgICAgIC8vIFJvdyA0IC0tIER1ZSBEYXRlXHJcbiAgICAgICAgY29uc3QgZHVlRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICByb3dEYXRhLnB1c2goZHVlRGF0ZSk7XHJcbiAgICAgICAgR2VuZXJhbENvbXBvbmVudHMuY3JlYXRlQ2VsbERhdGUoXHJcbiAgICAgICAgICAgIGR1ZURhdGUsXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LFxyXG4gICAgICAgICAgICBMbmcuZ3QoXCJEdWVEYXRlXCIpLFxyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbC5zZXR0aW5ncy5kYXRlRm9ybWF0LFxyXG4gICAgICAgICAgICAoKSA9PiBtb2RlbC5kYXRhLmR1ZSA/PyBcIm5hXCIsXHJcbiAgICAgICAgICAgIGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiBtb2RlbC5kYXRhLmR1ZSA9IHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8gUm93IDUgLS0gU3RhdHVzXHJcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIHJvd0RhdGEucHVzaChzdGF0dXMpO1xyXG4gICAgICAgIFByb2plY3RDb21wb25lbnRzLmNyZWF0ZVN0YXR1cyhcclxuICAgICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgKCkgPT4gbW9kZWwuZGF0YS5zdGF0dXMgPz8gXCJBY3RpdmVcIixcclxuICAgICAgICAgICAgYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IG1vZGVsLmRhdGEuc3RhdHVzID0gdmFsdWUgYXMgdW5rbm93biBhcyBTdGF0dXMpO1xyXG5cclxuICAgICAgICAvLyBSb3cgNiAtLSBUYWdzXHJcbiAgICAgICAgY29uc3QgdGFncyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICByb3dEYXRhLnB1c2godGFncyk7XHJcbiAgICAgICAgRG9jdW1lbnRDb21wb25lbnRzLmNyZWF0ZUNlbGxUYWdzKFxyXG4gICAgICAgICAgICB0YWdzLFxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgbW9kZWwuZ2V0VGFncygpKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGhpZGUgPSB0aGlzLmdldEhpZGVTdGF0ZShtb2RlbCwgdGhpcy5zZXR0aW5ncy5tYXhEb2N1bWVudHMpO1xyXG5cclxuICAgICAgICBjb25zdCByb3cgPSB7XHJcbiAgICAgICAgICAgIHJvd1VpZCxcclxuICAgICAgICAgICAgcm93RGF0YSxcclxuICAgICAgICAgICAgcm93Q2xhc3NMaXN0LFxyXG4gICAgICAgICAgICBoaWRkZW46IGhpZGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByb3c7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBvbkZpbHRlckJ1dHRvbih0eXBlOiBzdHJpbmcsIHN0YXR1czogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyh0eXBlIGFzIEZpbHRlcmVkTW9kZWxzKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZpbHRlciA9IHRoaXMuc2V0dGluZ3MuZmlsdGVyLmZpbHRlcih2ID0+IHYgIT09IHR5cGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZmlsdGVyLnB1c2godHlwZSBhcyBGaWx0ZXJlZE1vZGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25GaWx0ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uTWF4RG9jdW1lbnRzQ2hhbmdlKG1heERvY3VtZW50czogbnVtYmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzLm1heERvY3VtZW50cyA9IG1heERvY3VtZW50cztcclxuICAgICAgICB0aGlzLm9uRmlsdGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uU2VhcmNoKHNlYXJjaDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2ggIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2VhcmNoID0gU2VhcmNoLnBhcnNlU2VhcmNoVGV4dChzZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkZpbHRlcigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zZWFyY2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJFc2NhcGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNlYXJjaCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbkZpbHRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uRmlsdGVyKCkge1xyXG4gICAgICAgIHRoaXMuZ3JheU91dEhlYWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IHRoaXMuc2V0dGluZ3MuYmF0Y2hTaXplO1xyXG4gICAgICAgIGNvbnN0IHNsZWVwQmV0d2VlbkJhdGNoZXMgPSB0aGlzLnNldHRpbmdzLnNsZWVwQmV0d2VlbkJhdGNoZXM7XHJcbiAgICAgICAgbGV0IHNsZWVwUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50c0xlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCByb3dzOiBSb3dzU3RhdGVbXSA9IFtdO1xyXG4gICAgICAgIGxldCB2aXNpYmxlUm93cyA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jdW1lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1vZGVsc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJvd1VpZCA9IHRoaXMuZ2V0VUlEKGRvY3VtZW50KTtcclxuICAgICAgICAgICAgbGV0IGhpZGUgPSB0aGlzLmdldEhpZGVTdGF0ZShkb2N1bWVudCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgaWYgKHZpc2libGVSb3dzID49IHRoaXMuc2V0dGluZ3MubWF4RG9jdW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBoaWRlID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaGlkZSkge1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHsgcm93VWlkLCBoaWRkZW46IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUm93cysrO1xyXG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHsgcm93VWlkLCBoaWRkZW46IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKGkgIT09IDAgJiYgaSAlIGJhdGNoU2l6ZSA9PT0gMCkgfHwgaSA9PT0gZG9jdW1lbnRzTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXBQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZS5jaGFuZ2VTaG93SGlkZVN0YXRlUm93cyhyb3dzKTtcclxuICAgICAgICAgICAgICAgIHJvd3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHNsZWVwUHJvbWlzZSA9IEhlbHBlci5zbGVlcChzbGVlcEJldHdlZW5CYXRjaGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ub3JtYWxpemVIZWFkZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEhpZGVTdGF0ZShtb2RlbDogKFByalRhc2tNYW5hZ2VtZW50TW9kZWw8VGFza0RhdGEgfCBUb3BpY0RhdGEgfCBQcm9qZWN0RGF0YT4pLCBtYXhWaXNpYmxlUm93czogbnVtYmVyIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IHNlYXJjaFJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBtYXhSb3dzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5maWx0ZXIuaW5jbHVkZXMoXCJEb25lXCIpICYmIG1vZGVsLmRhdGEuc3RhdHVzID09PSBcIkRvbmVcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlYXJjaCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgc2VhcmNoUmVzdWx0ID0gU2VhcmNoLmFwcGx5U2VhcmNoTG9naWModGhpcy5zZXR0aW5ncy5zZWFyY2gsIHRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1heFZpc2libGVSb3dzICYmIG1heFZpc2libGVSb3dzID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCByb3dTdGF0cyA9IHRoaXMudGFibGUuZ2V0Um93U3RhdHMoKTtcclxuICAgICAgICAgICAgbWF4Um93cyA9IHJvd1N0YXRzLnZpc2libGVSb3dzID49IG1heFZpc2libGVSb3dzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaGlkZSA9IHRoaXMuZGV0ZXJtaW5lSGlkZVN0YXRlKG1vZGVsKTtcclxuXHJcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCAmJiAhaGlkZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFNob3dzIHRoZSBkb2N1bWVudCwgaWYgaXQgaXMgbm90IGhpZGRlbiBhbmQgdGhlIHNlYXJjaCB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zZWFyY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEhpZGUgdGhlIGRvY3VtZW50LCBpZiB0aGUgc2VhcmNoIHdhcyBub3Qgc3VjY2Vzc2Z1bCBhbmQgYXBsaWNhYmxlXHJcbiAgICAgICAgfSBlbHNlIGlmICghc2VhcmNoUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhSb3dzIHx8IGhpZGU7IC8vIEVsc2UgdGhlIGRvY3VtZW50IGlzIGhpZGRlbiwgaWYgdGhlIG1heCByb3dzIGFyZSByZWFjaGVkIG9yIHRoZSBkb2N1bWVudCB0eXBlIGlzIGhpZGRlblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhpZGU7IC8vIFN0YW5kYXJkLVZlcmhhbHRlblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGV0ZXJtaW5lSGlkZVN0YXRlKG1vZGVsOiAoUHJqVGFza01hbmFnZW1lbnRNb2RlbDxUYXNrRGF0YSB8IFRvcGljRGF0YSB8IFByb2plY3REYXRhPikpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5maWx0ZXIuaW5jbHVkZXMoXCJUb3BpY1wiKSAmJiBtb2RlbC5kYXRhLnR5cGUgPT09IFwiVG9waWNcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyhcIlByb2plY3RcIikgJiYgbW9kZWwuZGF0YS50eXBlID09PSBcIlByb2plY3RcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZpbHRlci5pbmNsdWRlcyhcIlRhc2tcIikgJiYgbW9kZWwuZGF0YS50eXBlID09PSBcIlRhc2tcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBwYXJzZVNldHRpbmdzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yU2V0dGluZ3Mub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidGFnc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24udmFsdWUgPT09IFwiYWxsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy50YWdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24udmFsdWUgPT09IFwidGhpc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLnByb2Nlc3NvclNldHRpbmdzPy5mcm9udG1hdHRlcj8udGFncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudGFncy5wdXNoKC4uLnRhZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudGFncy5wdXNoKHRhZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy50YWdzID0gb3B0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXhEb2N1bWVudHNcIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1heERvY3VtZW50cyA9IG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZpbHRlciA9IG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgZ2V0TW9kZWxzKCk6IFByb21pc2U8KFByalRhc2tNYW5hZ2VtZW50TW9kZWw8VGFza0RhdGEgfCBUb3BpY0RhdGEgfCBQcm9qZWN0RGF0YT4pW10+IHtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZUZvbGRlciA9IHRoaXMuZ2xvYmFsLnNldHRpbmdzLnRlbXBsYXRlRm9sZGVyO1xyXG4gICAgICAgIGNvbnN0IGFsbE1vZGVsRmlsZXMgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZmlsdGVyKGZpbGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RmlsdGVyID0gKGZpbGUubWV0YWRhdGEuZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiVG9waWNcIiB8fCBmaWxlLm1ldGFkYXRhLmZyb250bWF0dGVyPy50eXBlID09PSBcIlByb2plY3RcIiB8fCBmaWxlLm1ldGFkYXRhLmZyb250bWF0dGVyPy50eXBlID09PSBcIlRhc2tcIikgJiZcclxuICAgICAgICAgICAgICAgIGZpbGUuZmlsZS5wYXRoICE9PSB0aGlzLnByb2Nlc3NvclNldHRpbmdzLnNvdXJjZSAmJlxyXG4gICAgICAgICAgICAgICAgIWZpbGUuZmlsZS5wYXRoLnN0YXJ0c1dpdGgodGVtcGxhdGVGb2xkZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50YWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0ZpbHRlciA9IEhlbHBlci5pc1RhZ0luY2x1ZGVkKHRoaXMuc2V0dGluZ3MudGFncywgZmlsZS5tZXRhZGF0YS5mcm9udG1hdHRlcj8udGFncyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlciAmJiB0YWdGaWx0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbW9kZWxzOiAoUHJqVGFza01hbmFnZW1lbnRNb2RlbDxUYXNrRGF0YSB8IFRvcGljRGF0YSB8IFByb2plY3REYXRhPilbXSA9IFtdO1xyXG4gICAgICAgIGFsbE1vZGVsRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWxlLm1ldGFkYXRhLmZyb250bWF0dGVyPy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVG9waWNcIjpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChuZXcgVG9waWNNb2RlbChmaWxlLmZpbGUpIGFzIFByalRhc2tNYW5hZ2VtZW50TW9kZWw8VG9waWNEYXRhPik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiUHJvamVjdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVscy5wdXNoKG5ldyBQcm9qZWN0TW9kZWwoZmlsZS5maWxlKSBhcyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFByb2plY3REYXRhPik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVGFza1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVscy5wdXNoKG5ldyBUYXNrTW9kZWwoZmlsZS5maWxlKSBhcyBQcmpUYXNrTWFuYWdlbWVudE1vZGVsPFRhc2tEYXRhPik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVscztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSB0eXBlcyBvZiBtb2RlbHMgdG8gc2hvdy5cclxuICogQHJlbWFya3MgLSBgVG9waWNgIGluY2x1ZGVzIGFsbCB0b3BpY3MuXHJcbiAqIC0gYFByb2plY3RgIGluY2x1ZGVzIGFsbCBwcm9qZWN0cy5cclxuICogLSBgVGFza2AgaW5jbHVkZXMgYWxsIHRhc2tzLlxyXG4gKi9cclxudHlwZSBGaWx0ZXJlZE1vZGVscyA9IFwiVG9waWNcIiB8IFwiUHJvamVjdFwiIHwgXCJUYXNrXCIgfCBcIkRvbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2V0dGluZ3MgZm9yIHRoZSBwcm9qZWN0IGJsb2NrIHJlbmRlciBjb21wb25lbnQuXHJcbiAqIEByZW1hcmtzIFRoZSBzZXR0aW5ncyBhcmUgcGFyc2VkIGZyb20gdGhlIFlBTUwgb3B0aW9ucyBpbiB0aGUgY29kZSBibG9jay5cclxuICovXHJcbnR5cGUgUHJvamVjdEJsb2NrUmVuZGVyU2V0dGluZ3MgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZG9jdW1lbnRzLlxyXG4gICAgICogQ2FuIGJlIGBhbGxgLCBgdGhpc2Agb3IgYSBsaXN0IG9mIHNwZWNpZmljIHRhZ3MuXHJcbiAgICAgKiBgYWxsYCBpbmNsdWRlcyBhbGwgZG9jdW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgdGFncy5cclxuICAgICAqIGB0aGlzYCBpbmNsdWRlcyBkb2N1bWVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIHRhZ3MgYXMgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHRhZ3M6IHN0cmluZ1tdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ltYm9sIHJlcHJlc2VudGluZyBhIHRvcGljLlxyXG4gICAgICovXHJcbiAgICB0b3BpY1N5bWJvbDogc3RyaW5nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ltYm9sIHJlcHJlc2VudGluZyBhIHByb2plY3QuXHJcbiAgICAgKi9cclxuICAgIHByb2plY3RTeW1ib2w6IHN0cmluZyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN5bWJvbCByZXByZXNlbnRpbmcgYSB0YXNrLlxyXG4gICAgICovXHJcbiAgICB0YXNrU3ltYm9sOiBzdHJpbmcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTeW1ib2wgdXNlZCBmb3IgZG9jdW1lbnRzIHRoYXQgZG9uJ3QgZml0IGFueSBvdGhlciBjYXRlZ29yeS5cclxuICAgICAqL1xyXG4gICAgb3RoZXJTeW1ib2w6IHN0cmluZyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlciBmb3IgdGhlIG1vZGVsIHR5cGVzIHRvIGRpc3BsYXkuXHJcbiAgICAgKiBNdXN0IGJlIGFuIGFycmF5IGNvbnRhaW5pbmcgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gICAgICogYFRvcGljYCwgYFByb2plY3RgLCBgVGFza2AuXHJcbiAgICAgKiBPbmx5IHRoZSB0eXBlcyBsaXN0ZWQgaW4gdGhlIGFycmF5IHdpbGwgYmUgc2hvd24uXHJcbiAgICAgKi9cclxuICAgIGZpbHRlcjogRmlsdGVyZWRNb2RlbHNbXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtb2RlbHMgdG8gc2hvdyBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICBtYXhEb2N1bWVudHM6IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCB0ZXJtcyBhcnJheSB1c2VkIHRvIGZpbHRlciB0aGUgbW9kZWxzLlxyXG4gICAgICogSWYgdW5kZWZpbmVkLCBubyBzZWFyY2ggZmlsdGVyIGlzIGFwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHNlYXJjaDogU2VhcmNoVGVybXNBcnJheSB8IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9kZWxzIHRvIHByb2Nlc3MgaW4gb25lIGJhdGNoLlxyXG4gICAgICovXHJcbiAgICBiYXRjaFNpemU6IG51bWJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW1lIHRvIHdhaXQgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiBwcm9jZXNzaW5nIGJhdGNoZXMgb2YgbW9kZWxzLlxyXG4gICAgICovXHJcbiAgICBzbGVlcEJldHdlZW5CYXRjaGVzOiBudW1iZXJcclxufTtcclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IFByaiBmcm9tICdzcmMvbWFpbic7XHJcbmltcG9ydCBHbG9iYWwgZnJvbSAnLi9HbG9iYWwnO1xyXG5pbXBvcnQgeyBMb2dnaW5nTGV2ZWwgfSBmcm9tICcuL0xvZ2dpbmcnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgICBwbHVnaW46IFByajtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQcmopIHtcclxuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICAvLyBMb2cgTGV2ZWxcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0xvZyBMZXZlbCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbG9nIGxldmVsIHRvIHVzZScpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgICdub25lJzogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICd0cmFjZSc6ICd0cmFjZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RlYnVnJzogJ2RlYnVnJyxcclxuICAgICAgICAgICAgICAgICAgICAnaW5mbyc6ICdpbmZvJyxcclxuICAgICAgICAgICAgICAgICAgICAnd2Fybic6ICd3YXJuJyxcclxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InOiAnZXJyb3InXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmxvZ0xldmVsKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmxvZ0xldmVsID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgR2xvYmFsLmdldEluc3RhbmNlKCkubG9nZ2VyLnNldExvZ0xldmVsKHZhbHVlIGFzIExvZ2dpbmdMZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIEVkaXRhYmlsaXR5XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdQZXJmb3JtYW5jZSBNb2RlIChvbmx5IE1vYmlsZSknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBwbHVnaW4gaXMgYWZmZWN0ZWQgYnkgdGhpcyBzZXR0aW5nLiBJZiBkaXNhYmxlZCwgdGhlIGVkaXRhYmlsaXR5IG9mIHRoZSBibG9ja3MgaXMgZGlzYWJsZWQuIE5vIGVmZmVjdCBvbiBEZXNrdG9wIScpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm1vYmlsZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2JpbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gTG9jYWxpc2F0aW9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXRIZWFkaW5nKClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0xvY2FsaXNhdGlvbicpO1xyXG5cclxuICAgICAgICAvLyBMYW5ndWFnZVxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnTGFuZ3VhZ2UnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIGxhbmd1YWdlIHRvIHVzZScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlbiB8IGRlJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5sYW5ndWFnZSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5sYW5ndWFnZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBEYXRlIGZvcm1hdFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGF0ZSBGb3JtYXQnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIERhdGUgZm9ybWF0IHRvIHVzZScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdERC5NTS5ZWVlZJylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kYXRlRm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRhdGVGb3JtYXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gRGF0ZSBmb3JtYXQgc2hvcnRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1Nob3J0IGRhdGUgZm9ybWF0JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBzaG9ydCBEYXRlIGZvcm1hdCB0byB1c2UnKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignREQuTU0uWVknKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRhdGVGb3JtYXRTaG9ydClcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kYXRlRm9ybWF0U2hvcnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gQmFzZSB0YWcgZm9yIGFsbCByZWxhdGVkIGZpbGVzXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdCYXNlIFRhZycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgQmFzZSBUYWcgZm9yIGFsbCBFbGVtZW50cycpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCcjWW91ckJhc2VUYWcnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VUYWcpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFzZVRhZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBUZW1wbGF0ZSBGb2xkZXJcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1RlbXBsYXRlIEZvbGRlcicpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgRm9sZGVyIHdoZXJlIGFsbCBUZW1wbGF0ZXMgYXJlIHN0b3JlZCcpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZb3VyVGVtcGxhdGVGb2xkZXInKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRlbXBsYXRlRm9sZGVyKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnRlbXBsYXRlRm9sZGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIFVzZXIgaW5mb3JtYXRpb25cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlciBJbmZvcm1hdGlvbicpO1xyXG5cclxuICAgICAgICAvLyBVc2VyIE5hbWVcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1VzZXI6IE5hbWUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBuYW1lJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lvdXIgbmFtZScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci5uYW1lKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZXIubmFtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBVc2VyIE5hbWUgU2hvcnRcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1VzZXI6IFNob3J0IG5hbWUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBuYW1lIHNob3J0IG5hbWUnKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignWW91ciBuYW1lIHNob3J0ZW5lZCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci5zaG9ydE5hbWUpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci5zaG9ydE5hbWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gVXNlciBFbWFpbFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlcjogRW1haWwnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBFLU1haWwgYWRyZXNzJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lvdXIgZW1haWwnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZXIuZW1haWwpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci5lbWFpbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBVc2VyIFN0cmVldFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlcjogU3RyZWV0JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1lvdXIgc3RyZWV0JylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lvdXIgc3RyZWV0JylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyLnN0cmVldClcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyLnN0cmVldCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBVc2VyIENpdHlcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ1VzZXI6IENpdHknKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBjaXR5JylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1lvdXIgY2l0eScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci5jaXR5KVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZXIuY2l0eSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBVc2VyIFppcFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnVXNlcjogWmlwIENvZGUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciB6aXAgY29kZScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZb3VyIHppcCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci56aXApXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlci56aXAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gVXNlciBDb3VudHJ5XHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdVc2VyOiBDb3VudHJ5JylcclxuICAgICAgICAgICAgLnNldERlc2MoJ1lvdXIgY291bnRyeScpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdZb3VyIGNvdW50cnknKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnVzZXIuY291bnRyeSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyLmNvdW50cnkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgLy8gRG9jdW1lbnQgU2V0dGluZ3NcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRG9jdW1lbnQgU2V0dGluZ3MnKTtcclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBNYXggU2hvd1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVmYXVsdCBNYXggU2hvdycpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZGVmYXVsdCBtYXggc2hvdyBmb3IgVGFibGUgRW50cnlzJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJzIwMCcpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdE1heFNob3cudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0TWF4U2hvdyA9IHZhbHVlIGFzIHVua25vd24gYXMgbnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBTeW1ib2xcclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLnNldE5hbWUoJ0RvY3VtZW50IFN5bWJvbCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgU3ltYm9sIGZvciByZWd1bGFyIERvY3VtZW50cycpXHJcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdmaWxlLXRleHQnKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3Muc3ltYm9sKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3Muc3ltYm9sID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIEhpZGUgU3ltYm9sXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKCdIaWRlIFN5bWJvbCcpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgU3ltYm9sIGZvciBoaWRkZW4gRG9jdW1lbnRzJylcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2ZpbGUtbWludXMtMicpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5oaWRlU3ltYm9sKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3MuaGlkZVN5bWJvbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAvLyBDbHVzdGVyIFN5bWJvbFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ2x1c3RlciBTeW1ib2wnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIFN5bWJvbCBmb3IgQ2x1c3RlciBEb2N1bWVudHMnKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignbGlicmFyeScpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZG9jdW1lbnRTZXR0aW5ncy5jbHVzdGVyU3ltYm9sKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRvY3VtZW50U2V0dGluZ3MuY2x1c3RlclN5bWJvbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG59XHJcbiIsICJleHBvcnQgaW50ZXJmYWNlIFByalNldHRpbmdzIHtcclxuICAgIGxvZ0xldmVsOiBzdHJpbmc7XHJcbiAgICBtb2JpbGU6IGJvb2xlYW47XHJcbiAgICBsYW5ndWFnZTogc3RyaW5nO1xyXG4gICAgdXNlcjoge1xyXG4gICAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgICBzaG9ydE5hbWU6IHN0cmluZztcclxuICAgICAgICBlbWFpbDogc3RyaW5nO1xyXG4gICAgICAgIHN0cmVldDogc3RyaW5nO1xyXG4gICAgICAgIGNpdHk6IHN0cmluZztcclxuICAgICAgICB6aXA6IHN0cmluZztcclxuICAgICAgICBjb3VudHJ5OiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgZGF0ZUZvcm1hdDogc3RyaW5nO1xyXG4gICAgZGF0ZUZvcm1hdFNob3J0OiBzdHJpbmc7XHJcbiAgICBkZWZhdWx0TWF4U2hvdzogbnVtYmVyO1xyXG4gICAgYmF0Y2hTaXplU2hvdzogbnVtYmVyO1xyXG4gICAgZG9jdW1lbnRTZXR0aW5nczoge1xyXG4gICAgICAgIHN5bWJvbDogc3RyaW5nO1xyXG4gICAgICAgIGhpZGVTeW1ib2w6IHN0cmluZztcclxuICAgICAgICBjbHVzdGVyU3ltYm9sOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgcHJqU2V0dGluZ3M6IHtcclxuICAgICAgICB0b3BpY1N5bWJvbDogc3RyaW5nO1xyXG4gICAgICAgIHByb2plY3RTeW1ib2w6IHN0cmluZztcclxuICAgICAgICB0YXNrU3ltYm9sOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgYmFzZVRhZzogc3RyaW5nO1xyXG4gICAgdGVtcGxhdGVGb2xkZXI6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFByalNldHRpbmdzID0ge1xyXG4gICAgbG9nTGV2ZWw6IFwibm9uZVwiLFxyXG4gICAgbW9iaWxlOiBmYWxzZSxcclxuICAgIGxhbmd1YWdlOiBcImVuXCIsXHJcbiAgICBkYXRlRm9ybWF0OiBcIkRELk1NLllZWVlcIixcclxuICAgIGRhdGVGb3JtYXRTaG9ydDogXCJERC5NTS5ZWVwiLFxyXG4gICAgdXNlcjoge1xyXG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxyXG4gICAgICAgIFwic2hvcnROYW1lXCI6IFwiXCIsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBcIlwiLFxyXG4gICAgICAgIFwic3RyZWV0XCI6IFwiXCIsXHJcbiAgICAgICAgXCJjaXR5XCI6IFwiXCIsXHJcbiAgICAgICAgXCJ6aXBcIjogXCJcIixcclxuICAgICAgICBcImNvdW50cnlcIjogXCJcIixcclxuICAgIH0sXHJcbiAgICBcImRlZmF1bHRNYXhTaG93XCI6IDIwMCxcclxuICAgIFwiYmF0Y2hTaXplU2hvd1wiOiAyNSxcclxuICAgIGRvY3VtZW50U2V0dGluZ3M6IHtcclxuICAgICAgICBcInN5bWJvbFwiOiBcImZpbGUtdGV4dFwiLFxyXG4gICAgICAgIFwiaGlkZVN5bWJvbFwiOiBcImZpbGUtbWludXMtMlwiLFxyXG4gICAgICAgIFwiY2x1c3RlclN5bWJvbFwiOiBcImxpYnJhcnlcIlxyXG4gICAgfSxcclxuICAgIHByalNldHRpbmdzOiB7XHJcbiAgICAgICAgXCJ0b3BpY1N5bWJvbFwiOiBcImFsYnVtXCIsXHJcbiAgICAgICAgXCJwcm9qZWN0U3ltYm9sXCI6IFwibGF5b3V0LWxpc3RcIixcclxuICAgICAgICBcInRhc2tTeW1ib2xcIjogXCJjbGlwYm9hcmRcIlxyXG4gICAgfSxcclxuICAgIGJhc2VUYWc6ICdQUkonLFxyXG4gICAgdGVtcGxhdGVGb2xkZXI6ICdWb3JsYWdlbi8nXHJcbn07XHJcbiIsICJpbXBvcnQgeyBNZW51LCBUQWJzdHJhY3RGaWxlLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgR2xvYmFsIGZyb20gXCJzcmMvY2xhc3Nlcy9HbG9iYWxcIjtcclxuaW1wb3J0IExuZyBmcm9tIFwic3JjL2NsYXNzZXMvTG5nXCI7XHJcbmltcG9ydCB7IERvY3VtZW50TW9kZWwgfSBmcm9tIFwic3JjL21vZGVscy9Eb2N1bWVudE1vZGVsXCI7XHJcbmltcG9ydCB7IEZpbGVUeXBlIH0gZnJvbSBcInNyYy90eXBlcy9QcmpUeXBlc1wiO1xyXG5pbXBvcnQgeyBGaWxlTWV0YWRhdGEgfSBmcm9tIFwiLi4vTWV0YWRhdGFDYWNoZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2V0TWV0YWRhdGEge1xyXG4gICAgc3RhdGljIGluc3RhbmNlOiBHZXRNZXRhZGF0YTtcclxuICAgIHByaXZhdGUgYXBwID0gR2xvYmFsLmdldEluc3RhbmNlKCkuYXBwO1xyXG4gICAgcHJpdmF0ZSBsb2dnZXIgPSBHbG9iYWwuZ2V0SW5zdGFuY2UoKS5sb2dnZXI7XHJcbiAgICBwcml2YXRlIHBsdWdpbiA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLnBsdWdpbjtcclxuICAgIHByaXZhdGUgbWV0YWRhdGFDYWNoZSA9IEdsb2JhbC5nZXRJbnN0YW5jZSgpLm1ldGFkYXRhQ2FjaGUuQ2FjaGU7XHJcbiAgICBwcm90ZWN0ZWQgZXZlbnRzUmVnaXN0ZXJlZCA9IGZhbHNlO1xyXG4gICAgcHJvdGVjdGVkIGJpbmRDb250ZXh0TWVudSA9IHRoaXMub25Db250ZXh0TWVudS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJJbml0aWFsaXppbmcgR2V0TWV0YWRhdGFcIik7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb21tYW5kcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBHZXRNZXRhZGF0YSB7XHJcbiAgICAgICAgaWYgKCFHZXRNZXRhZGF0YS5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBHZXRNZXRhZGF0YS5pbnN0YW5jZSA9IG5ldyBHZXRNZXRhZGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2V0TWV0YWRhdGEuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvbnN0cnVjdHMgdGhlICdHZXRNZXRhZGF0YScgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLmV2ZW50c1JlZ2lzdGVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5sb2dnZXIudHJhY2UoXCJEZWNvbnN0cnVjdGluZyAnR2V0TWV0YWRhdGEnIGV2ZW50c1wiKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5hcHAud29ya3NwYWNlLm9mZignZmlsZS1tZW51JywgdGhpcy5pbnN0YW5jZS5iaW5kQ29udGV4dE1lbnUpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmV2ZW50c1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmxvZ2dlci50cmFjZShcIk5vICdHZXRNZXRhZGF0YScgZXZlbnRzIHRvIGRlY29uc3RydWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyB0aGUgJ0dldE1ldGFkYXRhJyBldmVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdpc3RlckV2ZW50cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzUmVnaXN0ZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlJlZ2lzdGVyaW5nICdHZXRNZXRhZGF0YScgZXZlbnRzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtbWVudScsIHRoaXMuYmluZENvbnRleHRNZW51KTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHNSZWdpc3RlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgdGhlICdHZXRNZXRhZGF0YScgY29tbWFuZHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdpc3RlckNvbW1hbmRzKCkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUmVnaXN0ZXJpbmcgJ0dldE1ldGFkYXRhJyBjb21tYW5kc1wiKTtcclxuICAgICAgICB0aGlzLnBsdWdpbi5hZGRDb21tYW5kKHtcclxuICAgICAgICAgICAgaWQ6IFwiZ2V0LW1ldGFkYXRhLWZpbGVcIixcclxuICAgICAgICAgICAgbmFtZTogTG5nLmd0KFwiU2hvd01ldGFkYXRhRmlsZVwiKSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIEdldE1ldGFkYXRhLmdldEluc3RhbmNlKCkuaW52b2tlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlICdHZXRNZXRhZGF0YScgY29udGV4dCBtZW51IGl0ZW1cclxuICAgICAqIEBwYXJhbSBtZW51IFRoZSBjb250ZXh0IG1lbnVcclxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIGFkZCB0aGUgY29udGV4dCBtZW51IGl0ZW0gdG9cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvbkNvbnRleHRNZW51KG1lbnU6IE1lbnUsIGZpbGU6IFRBYnN0cmFjdEZpbGUpIHtcclxuICAgICAgICAvLyBBbGxvdyBvbmx5IHBkZiBmaWxlc1xyXG4gICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIWZpbGUucGF0aC5lbmRzV2l0aChcIi5wZGZcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXRhZGF0YUZpbGUgPSB0aGlzLmdldENvcnJlc3BvbmRpbmdNZXRhZGF0YUZpbGUoZmlsZSk7XHJcbiAgICAgICAgaWYgKCFtZXRhZGF0YUZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IG5ldyBEb2N1bWVudE1vZGVsKG1ldGFkYXRhRmlsZS5maWxlKTtcclxuICAgICAgICBpZiAobWV0YWRhdGFGaWxlKSB7XHJcbiAgICAgICAgICAgIG1lbnUuYWRkU2VwYXJhdG9yKCk7XHJcbiAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShMbmcuZ3QoXCJTaG93TWV0YWRhdGFGaWxlXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKGRvY3VtZW50LmdldENvcm9zcG9uZGluZ1N5bWJvbCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcGVuTWV0YWRhdGFGaWxlKGRvY3VtZW50LmZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmaWxlIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgKGUuZy4gcGRmKSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZG9jdW1lbnQgZmlsZVxyXG4gICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIGZpbGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENvcnJlc3BvbmRpbmdNZXRhZGF0YUZpbGUoZmlsZTogVEZpbGUpOiBGaWxlTWV0YWRhdGEgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhQ2FjaGUuZmluZChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXRhZGF0YS5tZXRhZGF0YS5mcm9udG1hdHRlcj8udHlwZSBhcyBGaWxlVHlwZSB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVMaW5rID0gbWV0YWRhdGEubWV0YWRhdGEuZnJvbnRtYXR0ZXI/LmZpbGUgYXMgc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgZmlsZUxpbmsgJiYgdHlwZSA9PT0gXCJNZXRhZGF0YVwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUxpbmsuY29udGFpbnMoZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIG1ldGFkYXRhIGZpbGUgZm9yIHRoZSBhY3RpdmUgKGUuZy4gcGRmKSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnZva2UoKSB7XHJcbiAgICAgICAgY29uc3Qgd29ya3NwYWNlID0gdGhpcy5hcHAud29ya3NwYWNlO1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB3b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmICghYWN0aXZlRmlsZSB8fCAhKGFjdGl2ZUZpbGUgaW5zdGFuY2VvZiBURmlsZSkgfHwgIWFjdGl2ZUZpbGUucGF0aC5lbmRzV2l0aChcIi5wZGZcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vIGFjdGl2ZSBwZGYgZmlsZSBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFGaWxlID0gdGhpcy5nZXRDb3JyZXNwb25kaW5nTWV0YWRhdGFGaWxlKGFjdGl2ZUZpbGUpO1xyXG4gICAgICAgIGlmICghbWV0YWRhdGFGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBtZXRhZGF0YSBmaWxlIHRvIHRoZSBhY3RpdmUgcGRmIGZpbGUgZm91bmQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gbmV3IERvY3VtZW50TW9kZWwobWV0YWRhdGFGaWxlLmZpbGUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMub3Blbk1ldGFkYXRhRmlsZShkb2N1bWVudC5maWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG9wZW5NZXRhZGF0YUZpbGUoZmlsZTogVEZpbGUpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgT3BlbmluZyBtZXRhZGF0YSBmaWxlIGZvciAke2ZpbGUubmFtZX1gKTtcclxuICAgICAgICBjb25zdCB3b3Jrc3BhY2UgPSB0aGlzLmFwcC53b3Jrc3BhY2U7XHJcbiAgICAgICAgY29uc3QgbmV3TGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKHRydWUpO1xyXG4gICAgICAgIGF3YWl0IG5ld0xlYWYub3BlbkZpbGUoZmlsZSk7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IG5ld0xlYWYuZ2V0Vmlld1N0YXRlKCk7XHJcbiAgICAgICAgdmlldy5zdGF0ZS5tb2RlID0gJ3ByZXZpZXcnO1xyXG4gICAgICAgIG5ld0xlYWYuc2V0Vmlld1N0YXRlKHZpZXcpO1xyXG4gICAgfVxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsNENBQUFBLFNBQUE7QUFBQyxLQUFDLFNBQVUsTUFBTSxTQUFTO0FBQzFCLFVBQUksT0FBTyxZQUFZLFVBQVU7QUFFaEMsUUFBQUEsUUFBTyxVQUFVLFVBQVUsUUFBUTtBQUFBLE1BQ3BDLFdBQ1MsT0FBTyxXQUFXLGNBQWMsT0FBTyxLQUFLO0FBRXBELGVBQU8sQ0FBQyxHQUFHLE9BQU87QUFBQSxNQUNuQixPQUNLO0FBRUosYUFBSyxXQUFXLFFBQVE7QUFBQSxNQUN6QjtBQUFBLElBQ0QsR0FBRSxTQUFNLFdBQVk7QUFPbkIsVUFBSSxXQUFXLFlBQWEs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QUN4QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLElBQUksRUFBRSxDQUFDLENBQUM7QUFDeEMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsYUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLEdBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsYUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFFekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQWEsR0FBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLEdBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLEdBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsR0FBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsR0FBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUV6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsYUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLEdBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsR0FBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxHQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxhQUFhLElBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLGFBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBRXpDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxZQUFhLEdBQUksRUFBRSxFQUFFLENBQUM7QUFDekMsZ0JBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLFlBQWEsSUFBSSxFQUFFLEVBQUUsQ0FBQztBQUN6QyxnQkFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsYUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3pDLGdCQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FB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S0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJNYXRoIiwgInVuZGVmaW5lZCIsICJtb2R1bGUiLCAiTWF0aCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImV4Y2VwdGlvbiIsICJtYXAiLCAic2NoZW1hIiwgInR5cGUiLCAiZXh0ZW5kIiwgInN0ciIsICJzdHJpbmciLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInR5cGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgInR5cGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0eXBlIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZG9jdW1lbnQiLCAic2VsZiIsICJfYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAidHlwZSIsICJkYXRlIiwgInR5cGUiLCAiZG9jdW1lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgInR5cGUiLCAiX2EiLCAidHlwZSIsICJkb2N1bWVudCIsICJnbG9iYWwiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJkb2N1bWVudCIsICJ0eXBlIl0KfQo=
